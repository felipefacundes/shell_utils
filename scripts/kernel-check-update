#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
This Bash script is designed to monitor kernel updates on a Linux system and prompt the user to reboot 
when an update is detected. 

Purpose:
- To ensure that the system is running the latest kernel version by notifying the user when an update 
occurs and facilitating a reboot.

Strengths:
1. Signal Handling: The script captures termination signals to cleanly manage background jobs.
2. Kernel Update Detection: It checks if the kernel has been updated by comparing the current 
and installed kernel versions.
3. User Notification: Utilizes graphical notifications to inform the user about the need for 
a reboot after a kernel update.
4. Sound Alerts: Plays a sound alert to draw attention to the reboot prompt.
5. User Interaction: Provides a user-friendly interface for confirming the reboot through a dialog box.

Capabilities:
- Monitors kernel updates continuously.
- Sends notifications and plays sounds to alert the user.
- Offers a simple yes/no dialog for reboot confirmation.
- Manages background processes effectively to ensure smooth operation.
DOCUMENTATION

# Define a signal handler to capture SIGINT (Ctrl+C)
trap 'kill $(jobs -p)' SIGTERM #SIGHUP #SIGINT #SIGQUIT #SIGABRT #SIGKILL #SIGALRM #SIGTERM

TMPDIR="${TMPDIR:-/tmp}"
SCRIPT_TMPDIR="${TMPDIR}/kernel_monitor"
[[ ! -d "$SCRIPT_TMPDIR" ]] && mkdir -p "$SCRIPT_TMPDIR"

CHECK_INTERVAL=10
KERNEL_TIMESTAMP_FILE="${SCRIPT_TMPDIR}/kernel_monitor.initramfs_timestamp"

show_help() {
    cat <<EOF
NAME
    ${0##*/} - Monitors kernel updates and prompts for system reboot.

SYNOPSIS
    ${0##*/} [-h | --help]
    ${0##*/} [-d | --daemon]

DESCRIPTION
    This script continuously monitors for kernel updates on the system. When a kernel update is detected, it notifies the user graphically and prompts for a system reboot to complete the update process.

OPTIONS
    -h, --help
        Display this help message and exit.

    -d, --daemon
        Run the script in daemon mode. This is the primary mode of operation, initiating the kernel update monitoring process.

OPERATION
    The script operates by comparing:
    1. The currently running kernel version (via 'uname -r').
    2. The latest installed kernel version (via 'pacman').
    3. The timestamp of the kernel's initramfs file in /boot.

    When a discrepancy between the running and installed kernel is detected, and the initramfs has been updated, the script concludes a kernel update has occurred. It then:
    - Sends a critical desktop notification.
    - Plays an audible alert.
    - Displays a system tray icon with a reminder.
    - Presents a graphical dialog (via zenity) asking the user to confirm an immediate reboot.

    The script uses lock files in the system's temporary directory to prevent repeated prompts for the same update event.

SIGNAL HANDLING
    The script traps the SIGTERM signal to gracefully terminate all its background child processes upon exit.

DEPENDENCIES
    - bash
    - zenity (for the graphical reboot dialog)
    - notify-send (for desktop notifications, typically from 'libnotify')
    - paplay (from PulseAudio, for playing the sound alert)
    - pactl (from PulseAudio, for uploading the sound sample)
    - pacman (the package manager, for querying the installed kernel version)
    - systemctl (for initiating the reboot)
    - A custom Python script: ~/.shell_utils/scripts/systray-icon.py

FILES
    ${SCRIPT_TMPDIR}/kernel_monitor.initramfs_timestamp
        Stores the timestamp of the initramfs file when the script first runs or after a successful check.

    ${SCRIPT_TMPDIR}/kernel_monitor.reboot_prompted.lock
        Created after prompting the user for a reboot to prevent duplicate prompts for the same update event.

    ${SCRIPT_TMPDIR}/kernel_monitor.reboot_prompted.lock.notification
        Used to manage desktop notifications.

    ~/.shell_utils/sounds/system_reboot_pearl.ogg
        The sound file played as an alert.

    ~/.shell_utils/icons/exclamation.png
        The icon used for notifications and the system tray.

NOTES
    - The script is designed for systems using the 'pacman' package manager and a specific kernel/initramfs naming convention (/boot/initramfs-linux.img).
    - It checks that no 'pacman' process is running before triggering the reboot prompt to avoid interference with ongoing updates.
    - The user must run the script with the '-d' or '--daemon' option for it to start monitoring.

AUTHOR
    Felipe Facundes

LICENSE
    GPLv3
EOF
}

[[ "$1" == "-h" || "$1" == "--help" ]] && show_help && exit 0
if [[ "$1" != "-d" && "$1" != "--daemon" ]]; then
    show_help
    exit 1
fi

# SUPPORTED_KERNELS - Array of supported kernels (customizable)
SUPPORTED_KERNELS=("linux" "linux-cachyos" "linux-lts" "linux-zen" "linux-hardened")

# Function to get timestamp of an initramfs file
_initramfs_timestamp() {
    local arg=$1
    if [[ -f "$arg" ]]; then
        LC_ALL=c ls -l "$arg" | awk '{print $6 $7 $8}'
        return 0
    fi
    return 1
}

# Function to check ANY initramfs file (more robust)
_get_initramfs_timestamp() {
    # First, try the running kernel
    local running_kernel=$(uname -r | sed 's/-.*//')  # Get "linux", "linux-lts", etc
    
    # Check initramfs for the running kernel
    local initramfs_file="/boot/initramfs-${running_kernel}.img"
    if [[ -f "$initramfs_file" ]]; then
        _initramfs_timestamp "$initramfs_file"
        return 0
    fi
    
    # Fallback: check all supported kernels
    for kernel in "${SUPPORTED_KERNELS[@]}"; do
        initramfs_file="/boot/initramfs-${kernel}.img"
        if [[ -f "$initramfs_file" ]]; then
            _initramfs_timestamp "$initramfs_file"
            return 0
        fi
    done
    
    # Ultimate fallback: any initramfs-*.img file
    local any_initramfs=$(ls /boot/initramfs-*.img 2>/dev/null | head -1)
    if [[ -n "$any_initramfs" ]]; then
        _initramfs_timestamp "$any_initramfs"
        return 0
    fi
    
    return 1
}

# Function to get installed kernel version (more reliable)
_get_installed_kernel_version() {
    # Get the ACTUALLY RUNNING kernel package name
    local running_kernel=$(uname -r | sed 's/-.*//')
    
    # Try to get version of the running kernel package
    local version=$(LC_ALL=en pacman -Si "$running_kernel" 2>/dev/null | 
                    grep -i "^Version" | awk '{print $3}' | sed 's|-|.|g')
    
    if [[ -n "$version" ]]; then
        echo "$version"
        return 0
    fi
    
    # Fallback: get version from /usr/lib/modules (most reliable method)
    local modules_dir="/usr/lib/modules"
    if [[ -d "$modules_dir" ]]; then
        # Get all installed kernel modules, exclude currently running, sort by version
        local latest_module=$(ls -1 "$modules_dir" | grep -v "$(uname -r)" | sort -V | tail -1)
        if [[ -n "$latest_module" ]]; then
            echo "$latest_module" | sed 's/-/./g'
            return 0
        fi
    fi
    
    # Last resort: try all supported kernel packages
    for kernel in "${SUPPORTED_KERNELS[@]}"; do
        version=$(LC_ALL=en pacman -Si "$kernel" 2>/dev/null | 
                  grep -i "^Version" | awk '{print $3}' | sed 's|-|.|g')
        if [[ -n "$version" ]]; then
            echo "$version"
            return 0
        fi
    done
    
    return 1
}

# Initialize timestamp
if [[ ! -f "${KERNEL_TIMESTAMP_FILE}" ]]; then
    touch "${KERNEL_TIMESTAMP_FILE}"
    _get_initramfs_timestamp | tee "${KERNEL_TIMESTAMP_FILE}"
fi

notify_with_sound() {
    ALERT_SOUND_FILE=~/.shell_utils/sounds/system_reboot_pearl.ogg
    pactl upload-sample "$ALERT_SOUND_FILE"
    paplay "$ALERT_SOUND_FILE" --volume=76767
}

prompt_for_reboot() {
    REBOOT_CONFIRMATION=$(zenity --title='System restart?' --list --text='Kernel updated successfully, system restart?' --radiolist --column 'Choice' --radiolist --column 'Choice' False 'Yes' True 'No')
    if [[ "$REBOOT_CONFIRMATION" == 'Yes' ]]; then
        systemctl reboot -i 
    fi
}

monitor_kernel_updates() {
    STORED_INITRAMFS_TIMESTAMP=$(cat "${KERNEL_TIMESTAMP_FILE}")
    CURRENT_KERNEL_VERSION="$(uname -r | sed 's|-|.|g')"
    
    # Variables for continuous notification
    local last_notification_time=0
    local notification_interval=300  # 5 minutes between notifications
    local last_prompt_time=0
    local prompt_interval=900  # 15 minutes between prompts
    local notification_count=0

    while true
    do
        sleep "$CHECK_INTERVAL"
        
        # Get current installed version
        INSTALLED_KERNEL_VERSION=$(_get_installed_kernel_version)
        CURRENT_INITRAMFS_TIMESTAMP=$(_get_initramfs_timestamp)
        
        KERNEL_UPDATE_LOCK_FILE="${SCRIPT_TMPDIR}/kernel_monitor.reboot_prompted.lock"
        ALERT_ICON_PATH=~/.shell_utils/icons/exclamation.png
        current_time=$(date +%s)

        # Check if kernel update is detected
        if [[ -n "$INSTALLED_KERNEL_VERSION" ]] && \
           [[ -n "$CURRENT_INITRAMFS_TIMESTAMP" ]] && \
           [[ "$CURRENT_KERNEL_VERSION" != "$INSTALLED_KERNEL_VERSION" ]] && \
           [[ "$STORED_INITRAMFS_TIMESTAMP" != "$CURRENT_INITRAMFS_TIMESTAMP" ]] && \
           ! pidof pacman >/dev/null; then
            
            # Send periodic desktop notifications (every 5 minutes)
            if (( current_time - last_notification_time >= notification_interval )); then
                notify-send -i "$ALERT_ICON_PATH" -u critical \
                    "KERNEL UPDATED - REBOOT REQUIRED" \
                    "System is running old kernel $(uname -r)\nNew kernel $INSTALLED_KERNEL_VERSION is installed\nPlease reboot to avoid system instability"
                last_notification_time=$current_time
                notification_count=$((notification_count + 1))
                
                # Play sound with first few notifications
                if (( notification_count <= 3 )); then
                    notify_with_sound &
                fi
            fi
            
            # Show system tray icon continuously
            if ! pgrep -f "systray-icon.py.*Reboot" >/dev/null; then
                ~/.shell_utils/scripts/systray-icon.py -i "$ALERT_ICON_PATH" \
                    -t "REBOOT REQUIRED" \
                    -m "Kernel Updated" \
                    -n "System running: $(uname -r)\nNew kernel: $INSTALLED_KERNEL_VERSION" &
            fi
            
            # Show interactive prompt periodically (every 15 minutes)
            if (( current_time - last_prompt_time >= prompt_interval )); then
                # Check if zenity is already running to avoid multiple prompts
                if ! pgrep -f "zenity.*System.restart" >/dev/null; then
                    prompt_for_reboot &
                    last_prompt_time=$current_time
                fi
            fi
            
            # Create lock file to mark detection but DON'T update timestamp
            # This ensures continuous notifications
            if [[ ! -f "$KERNEL_UPDATE_LOCK_FILE" ]]; then
                touch "$KERNEL_UPDATE_LOCK_FILE"
            fi
            
        else
            # Reset notification counter if no update detected
            notification_count=0
            
            # Kill system tray icon if no update needed
            pkill -f "systray-icon.py.*Reboot" 2>/dev/null || true
            
            # Remove lock file if kernel is up to date
            if [[ -f "$KERNEL_UPDATE_LOCK_FILE" ]] && \
               [[ "$CURRENT_KERNEL_VERSION" == "$INSTALLED_KERNEL_VERSION" ]]; then
                rm -f "$KERNEL_UPDATE_LOCK_FILE"
                # Update timestamp only when kernel is up to date
                echo "$CURRENT_INITRAMFS_TIMESTAMP" > "${KERNEL_TIMESTAMP_FILE}"
            fi
        fi
        
        sleep 15
    done
}

monitor_kernel_updates &
BACKGROUND_PID=$!

# Wait for all child processes to finish
wait "$BACKGROUND_PID"