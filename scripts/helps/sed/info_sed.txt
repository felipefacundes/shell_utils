
        Arquivo: sed.info, Node: Top, Next: Introdução, Up: (dir)

       GNU 'sed'
       *********


       Este arquivo documenta a versão 4.9 do GNU 'sed', um editor de fluxo.

             Copyright © 1998–2022 Free Software Foundation, Inc.

                 É concedida permissão para copiar, distribuir e/ou modificar este documento sob os termos da GNU
                 Free Documentation License, Versão 1.3 ou qualquer versão posterior publicada pela Free Software
                 Foundation; sem seções invariantes, sem textos de capa frontal e sem textos de contracapa. Uma cópia
                 da licença está incluída na seção intitulada “GNU Free Documentation License”.



        *   Cardápio:


        * Introdução::                                       Introdução
        * Invocando sed::                                    Invocação *
        scripts sed:: scripts 'sed' * endereços sed::
                                                            Endereços: selecionando linhas * sed
        expressões regulares::                               Expressões regulares: selecionando texto * sed avançado::
                                                            'sed' avançado: ciclos e buffers
        * Exemplos::                                        Alguns exemplos de scripts
        * Limitações::                                  Limitações e (não-)limitações do GNU 'sed'
        * Outros recursos::                             Outros recursos para aprender sobre 'sed'
        * Relatando Bugs::                              Relatando erros
        *
            GNU Free Documentation License:: Copiar e compartilhar este manual
        *
            Índice de Conceitos::                       Um menu com todos os tópicos deste manual.
        * Índice de comandos e opções:: Um menu com todos os comandos 'sed' e
                                                            opções de linha de comando.

        Arquivo: sed.info, Nó: Introdução, Próximo: Chamando sed, Anterior: Início, Acima: Início

       1. Introdução
       **************


       'sed' é um editor de fluxo. Um editor de fluxo é usado para executar transformações básicas de texto em um fluxo de
       entrada (um arquivo ou entrada de um pipeline).
       Embora de certa forma semelhante a um editor que permite edições com script (como 'ed'), 'sed' funciona fazendo
       apenas uma passagem sobre a(s) entrada(s) e, conseqüentemente, é mais eficiente. Mas é a capacidade do 'sed'
       de filtrar o texto em um pipeline que o distingue particularmente de outros tipos de editores.




        Arquivo: sed.info, Nó: Chamando sed, Avançar: scripts sed, Anterior: Introdução, Acima: Início



       2 Sed em execução
        *************


       Este capítulo aborda como executar o 'sed'. Detalhes de scripts 'sed' e comandos 'sed' individuais são discutidos
       no próximo capítulo.

        *   Cardápio:


        * Visão geral::
        * Opções de linha de comando::
        * Estado de saída::


        Arquivo: sed.info, Nó: Visão geral, Próximo: Opções de linha de comando, Acima: Chamando sed

       2.1 Visão geral


       ============

       Normalmente 'sed' é invocado assim:

              sed SCRIPT ARQUIVO DE ENTRADA...


           Por exemplo, para alterar cada 'hello' para 'world' no arquivo 'input.txt':


              sed 's/hello/world/g' input.txt > output.txt

           Sem o modificador 'g' (global), 'sed' afeta apenas a primeira instância por linha.


           Se você não especificar INPUTFILE, ou se INPUTFILE for '-', 'sed' filtrará o conteúdo
       da entrada padrão. Os seguintes comandos são equivalentes:


              sed 's/olá/mundo/g' input.txt > output.txt sed 's/olá/mundo/g' <
              input.txt > output.txt cat input.txt | sed 's/hello/world/g' - > output.txt


            'sed' grava a saída na saída padrão. Use '-i' para editar arquivos no local em vez de
       imprimir na saída padrão. Consulte também os comandos 'W' e 's///w' para gravar a saída em
        outros arquivos. O seguinte comando modifica 'file.txt' e não produz nenhuma saída:


              sed -i 's/olá/mundo/' arquivo.txt


           Por padrão, 'sed' imprime todas as entradas processadas (exceto entradas que foram
       modificadas/excluídas por comandos como 'd'). Use '-n' para suprimir a saída e o comando 'p'
       para imprimir linhas específicas. O seguinte comando imprime apenas a linha 45 do arquivo de
       entrada:

              sed -n '45p' arquivo.txt

           'sed' trata vários arquivos de entrada como um fluxo longo. O exemplo a seguir imprime a
       primeira linha do primeiro arquivo ('one.txt') e a última linha do último arquivo ('three.txt'). Use '-s' para
       reverter esse comportamento.

              sed -n '1p ; $p' um.txt dois.txt três.txt

           Sem as opções '-e' ou '-f', 'sed' usa o primeiro parâmetro sem opção como o SCRIPT
       e os seguintes parâmetros sem opção como arquivos de entrada. Se as opções '-e' ou '-f' forem
       usadas para especificar um SCRIPT, todos os parâmetros não opcionais serão considerados como
       arquivos de entrada. As opções '-e' e '-f' podem ser combinadas e podem aparecer várias vezes
       (nesse caso, o SCRIPT efetivo final será a concatenação de todos os SCRIPTs individuais).


           Os exemplos a seguir são equivalentes:

              sed 's/hello/world/' input.txt > output.txt

              sed -e 's/hello/world/' input.txt > output.txt sed --expression='s/
              hello/world/' input.txt > output.txt

              echo 's/hello/world/' > myscript.sed sed -f
              myscript.sed input.txt > output.txt sed --file=myscript.sed
              input.txt > output.txt

       Arquivo: sed.info, Nó: Opções de linha de comando, Próximo: Status de saída, Anterior: Visão geral,
       Acima: Chamando sed

       2.2 Opções de linha de comando



       ========================


       O formato completo para invocar 'sed' é:

                   sed OPÇÕES... [SCRIPT] [INPUTFILE...]

               'sed' pode ser invocado com as seguintes opções de linha de comando:

        '--version' Imprima
                   a versão de 'sed' que está sendo executada e um aviso de direitos autorais e, em seguida, saia.



        '--help'
                   Imprima uma mensagem de uso resumindo brevemente essas opções de linha de comando e o
                    endereço de relatório de bug e, em seguida, saia.

        '-n' '--
        quiet' '--silent'
        Por padrão,
                   'sed' imprime o espaço padrão no final de cada ciclo do script (*observe como 'sed' funciona: Ciclo de
                   execução.).
                   Essas opções desativam essa impressão automática e 'sed' só produz saída quando explicitamente
                   informado por meio do comando 'p'.

        '--debug'
                Imprime o programa sed de entrada na forma canônica e anota a execução do programa. $ eco 1 | sed '\
                %1%s21232' 3




                            $ eco 1 | sed --debug '\%1%s21232'
                            PROGRAMA SED: /
                               1/ s/1/3/
                            ENTRADA:        'STDIN' linha 1
                            PADRÃO: 1
                            COMANDO: /1/ s/1/3/
                            PADRÃO: 3
                            FIM DE CICLO: 3



        '-e SCRIPT' '--
        expressão=SCRIPT' Adiciona os
               comandos no SCRIPT ao conjunto de comandos a serem executados durante o processamento da entrada.



        '-f SCRIPT-FILE' '--
        file=SCRIPT-FILE' Adiciona os
                comandos contidos no arquivo SCRIPT-FILE ao conjunto de comandos a serem executados durante o
                   processamento da entrada.

        '-i[SUFFIX]' '--in-
        place[=SUFFIX]' Esta opção
                especifica que os arquivos devem ser editados no local. GNU 'sed' faz isso criando um arquivo temporário
                e enviando a saída para este arquivo em vez da saída padrão.(1).



                   Esta opção implica '-s'.

                   Quando o final do arquivo é atingido, o arquivo temporário é renomeado para o nome original do arquivo de
                   saída. A extensão, se fornecida, é usada para modificar o nome do arquivo antigo antes de renomear o arquivo
                   temporário, fazendo assim uma cópia de segurança (2)).



                   Esta regra é seguida: se a extensão não contém um '*', então



              é anexado ao final do nome do arquivo atual como um sufixo; se a extensão contiver um
              ou mais caracteres '*', _cada_ asterisco será substituído pelo nome do arquivo atual. Isso
              permite adicionar um prefixo ao arquivo de backup, em vez de (ou além de) um sufixo, ou até
              mesmo colocar cópias de backup dos arquivos originais em outro diretório (desde que o
              diretório já exista).


              Se nenhuma extensão for fornecida, o arquivo original será substituído sem fazer
              um backup.

              Como '-i' aceita um argumento opcional, ele não deve ser seguido por outras opções curtas:
              'sed -Ei '...' FILE' Igual a '-E -i'
               sem sufixo de backup -
                     'FILE' será editado no local sem criar um backup.


               'sed -iE '...' FILE' Isto é
                      equivalente a '--in-place=E', criando 'FILEE' como backup de 'FILE'


              Tenha cuidado ao usar '-n' com '-i': o primeiro desativa a impressão automática de linhas e
              o último altera o arquivo no local sem um backup. Usado sem cuidado (e sem um comando
              'p' explícito), o arquivo de saída estará vazio: # WRONG USAGE: 'FILE' will be truncated.
              sed -ni 's/foo/bar/' ARQUIVO



        '-l N' '--
        line-length=N'
                  Especifique o comprimento de quebra de linha padrão para o comando 'l'. Um comprimento
                  de 0 (zero) significa nunca quebrar linhas longas. Se não for especificado, será considerado
                  70.

        '--posix'
                GNU 'sed' inclui várias extensões para POSIX sed. Para simplificar a escrita de scripts
                portáteis, esta opção desativa todas as extensões que este manual documenta,
                incluindo comandos adicionais. A maioria das extensões aceita programas 'sed'
                que estão fora da sintaxe exigida pelo POSIX, mas alguns deles (como o comportamento
                do comando 'N' descrito em *note Reporting Bugs::) realmente violam o padrão. Se você
                deseja desativar apenas o último tipo de extensão, pode definir a variável
                'POSIXLY_CORRECT' para um valor não vazio.



        '-b'
        '--binary' Esta
                opção está disponível em todas as plataformas, mas só é efetiva quando o sistema
                operacional faz distinção entre arquivos de texto e arquivos binários. Quando essa
                distinção é feita - como é o caso do MS-DOS, Windows, Cygwin - os arquivos de texto são
                compostos de linhas separadas por um retorno de carro _e_ um caractere de
                alimentação de linha, e 'sed' não vê o CR final. Quando esta opção é especificada, 'sed'
                abrirá arquivos de entrada em modo binário, não solicitando, portanto, este
                processamento especial e considerando as linhas para terminar em uma alimentação
                de linha.


        '--follow-symlinks' Esta
                opção está disponível apenas em plataformas que suportam links simbólicos e tem efeito
                 somente se a opção '-i' for especificada. Nesse caso, se o arquivo especificado na linha de
                comando for um link simbólico, 'sed' seguirá o link e editará o destino final do link.
                O comportamento padrão é quebrar o link simbólico, para que o destino do link não
                seja modificado.


        '-E' '-
        r' '--
        regexp-extended' Use
                expressões regulares estendidas em vez de expressões regulares básicas. Regexps
                estendidos são aqueles que 'egrep' aceita; eles podem ser mais claros porque geralmente têm
                menos barras invertidas.
                Historicamente, esta era uma extensão GNU, mas a extensão '-E' foi adicionada ao padrão
                POSIX (http://austingroupbugs.net/view.php?id=528),
                então use '-E' para portabilidade. O sed GNU aceitou '-E' como uma opção não
                documentada por anos, e os seds *BSD também aceitaram '-E' por anos, mas os scripts que
                usam '-E' podem não portar para outros sistemas mais antigos. *Observação Expressões
                regulares estendidas: sintaxe ERE.


        '-s' '--
        separate' Por
                 padrão, 'sed' considerará os arquivos especificados na linha de comando como um único fluxo
                 longo e contínuo. Esta extensão GNU 'sed' permite ao usuário considerá-los como arquivos
                 separados: endereços de intervalo (como '/abc/,/def/') não podem abranger vários arquivos,
                 números de linha são relativos ao início de cada arquivo, '$' refere-se à última linha de cada
                 arquivo e os arquivos chamados dos comandos 'R' são rebobinados no início de cada arquivo.



        '--sandbox' No
               modo sandbox, os comandos 'e/w/r' são rejeitados - os programas que os contêm
               serão abortados sem serem executados. O modo Sandbox garante que 'sed' opere apenas
               nos arquivos de entrada designados na linha de comando e não pode executar programas
               externos.

        '-u' '--
        sem buffer'
                 Armazene tanto a entrada quanto a saída o mínimo possível. (Isso é particularmente útil se a
                 entrada vier de algo como 'tail -f' e você deseja ver a saída transformada o mais rápido possível.)



        '-z' '--
        null-data' '--zero-
        terminated' Trate a entrada
                 como um conjunto de linhas, cada uma terminada por um byte zero (o caractere ASCII 'NUL')
                 em vez de uma nova linha. Esta opção pode ser usada com comandos como 'sort -z' e 'find
                 -print0' para processar nomes de arquivos arbitrários.


            Se nenhuma opção '-e', '-f', '--expression' ou '--file' for fornecida na linha de comando, o primeiro
        argumento sem opção na linha de comando será considerado o SCRIPT para ser executado.


           Se algum parâmetro de linha de comando permanecer após o processamento acima,
       esses parâmetros são interpretados como os nomes dos arquivos de entrada a serem
       processados. Um nome de arquivo '-' refere-se ao fluxo de entrada padrão. A entrada padrão será
       processada se nenhum nome de arquivo for especificado.

            ---------- Notas de rodapé ----------


           (1) Isso se aplica a comandos como '=', 'a', 'c', 'i', 'l', 'p'.
       Você ainda pode gravar na saída padrão usando os comandos 'w' ou 'W' junto com o arquivo
       especial '/dev/stdout'

           (2) Observe que GNU 'sed' cria o arquivo de backup independentemente de qualquer saída ser
       realmente alterada ou não.

        Arquivo: sed.info, Nó: Status de saída, Anterior: Opções de linha de comando, Acima: Invocação


       sed

       2.3 Status de saída
       ===============

       Um status de saída de zero indica sucesso e um valor diferente de zero indica falha. GNU 'sed' retorna
       os seguintes valores de erro de status de saída:

       0
                 Conclusão bem-sucedida.

       1
                 Comando inválido, sintaxe inválida, expressão regular inválida ou um comando de extensão
                 GNU 'sed' usado com '--posix'.

       2
                 Um ou mais arquivos de entrada especificados na linha de comando não puderam ser abertos
                 (por exemplo, se um arquivo não for encontrado ou se a permissão de leitura for negada). O
                 processamento continuou com outros arquivos.

       4
                 Um erro de E/S ou um erro grave de processamento durante o tempo de execução, GNU
                 'sed' abortado imediatamente.

          Além disso, os comandos 'q' e 'Q' podem ser usados para encerrar 'sed'
       com um valor de código de saída personalizado (esta é uma extensão GNU 'sed'):

                 $ eco | sed 'Q42'; eco $? 42


        Arquivo: sed.info, Nó: scripts sed, Avançar: endereços sed, Anterior: Chamar sed, Acima: Início


       3 scripts 'sed'
       ***************

        *   Cardápio:


        * visão geral do script sed:: *         Visão geral do script 'sed'
        lista de comandos sed::                 Resumo dos comandos 'sed'
        * O comando "s"::                       Canivete suíço do 'sed'
        * Comandos Comuns::                     Comandos mais usados
        * Outros Comandos::                     Comandos menos usados
        * Comandos de Programação::             Comandos para gurus 'sed'
        * Comandos Estendidos::                 Comandos específicos do GNU 'sed'
        * Sintaxe de vários comandos:: Extensão para scripts mais fáceis

        Arquivo: sed.info, Nó: visão geral do script sed, Avançar: lista de comandos sed, Acima: scripts sed


       3.1 Visão geral do script 'sed'
       =========================

       Um programa 'sed' consiste em um ou mais comandos 'sed', passados por uma ou mais das opções '-
       e', '-f', '--expression' e '--file', ou a primeira argumento sem opção se nenhuma dessas opções for
       usada. Este documento se referirá ao script 'sed'; isso significa a concatenação em ordem de
       todos os SCRIPTs e SCRIPT-FILEs transmitidos. *Visão geral da observação::.



              Os comandos 'sed' seguem esta sintaxe:

                  [addr]X[opções]


           X é um comando 'sed' de uma única letra. '[addr]' é um endereço de linha opcional. Se
       '[addr]' for especificado, o comando X será executado apenas nas linhas correspondentes. '[addr]'
       pode ser um único número de linha, uma expressão regular ou um intervalo de linhas (*observe
       os endereços sed::). '[opções]' adicionais são usadas para alguns comandos 'sed'.


            O exemplo a seguir exclui as linhas 30 a 35 na entrada. '30,35' é um intervalo de endereços.
       'd' é o comando de exclusão:

              sed '30,35d' input.txt > output.txt

            O exemplo a seguir imprime todas as entradas até que uma linha começando com a string 'foo'
       seja encontrada. Se tal linha for encontrada, 'sed' terminará com status de saída 42. Se tal linha não
       for encontrada (e nenhum outro erro ocorreu), 'sed' sairá com status 0. '/^foo/' é uma
       expressão regular endereço. 'q' é o comando de saída. '42' é a opção de
       comando.


              sed '/^foo/q42' input.txt > output.txt

           Os comandos dentro de um SCRIPT ou SCRIPT-FILE podem ser separados por
       ponto e vírgula (';') ou novas linhas (ASCII 10). Vários scripts podem ser especificados
       com as opções '-e' ou '-f'.

           Os exemplos a seguir são todos equivalentes. Eles executam duas operações 'sed':
       excluindo todas as linhas correspondentes à expressão regular '/^foo/' e substituindo todas as
       ocorrências da string 'hello' por 'world':

              sed '/^foo/d ; s/hello/world/g' input.txt > output.txt

              sed -e '/^foo/d' -e 's/olá/mundo/g' input.txt > output.txt

              echo '/^foo/d' > script.sed echo 's/
              hello/world/g' >> script.sed sed -f script.sed
              input.txt > output.txt

              echo 's/hello/world/g' > script2.sed sed -e '/^foo/d'
              -f script2.sed input.txt > output.txt

            Os comandos 'a', 'c', 'i', devido à sua sintaxe, não podem ser seguidos de ponto-e-vírgula
       funcionando como separadores de comandos e, portanto, devem ser terminados com novas
       linhas ou colocados no final de um SCRIPT ou SCRIPT-FILE.
       Os comandos também podem ser precedidos por caracteres de espaço em branco não
       significativos opcionais. *Observação Sintaxe de comandos múltiplos::.

       Arquivo: sed.info, Nó: lista de comandos sed, Avançar: O comando "s", Anterior: visão geral do script sed,
       Acima: scripts sed

       3.2 resumo dos comandos 'sed'
       ============================

       Os seguintes comandos são suportados no GNU 'sed'. Alguns são comandos POSIX padrão,
       enquanto outros são extensões GNU. Detalhes e exemplos para cada comando estão nas
       seções a seguir. (Mnemônicos) são mostrados entre parênteses.


        'a\'
        'TEXT'
              Acrescentar TEXTO após uma linha.

        'um texto'
              Acrescente TEXTO após uma linha (sintaxe alternativa).

        'b ETIQUETA'


               Ramifique incondicionalmente para LABEL. O LABEL pode ser omitido, caso em que
               o próximo ciclo é iniciado.

        'c\'
        'TEXT'
                 Substituir (alterar) linhas por TEXT.

        'c TEXTO'
              Substitua (altere) linhas por TEXT (sintaxe alternativa).

        'd'
                 Exclua o espaço padrão; iniciar imediatamente o próximo ciclo.

        'D'
                 Se o espaço do padrão contiver novas linhas, exclua o texto no espaço do padrão até
                 a primeira nova linha e reinicie o ciclo com o espaço do padrão resultante, sem ler uma nova
                 linha de entrada.

                 Se o espaço padrão não contiver nova linha, inicie um novo ciclo normal como se o
                 comando 'd' tivesse sido emitido.

        'e'
                 Executa o comando encontrado no espaço padrão e substitui o espaço padrão pela
                 saída; uma nova linha à direita é suprimida.


        'e COMMAND'
              Executa COMMAND e envia sua saída para o fluxo de saída. O comando pode ser
              executado em várias linhas, todas exceto a última terminando com uma barra invertida.


        'F'
                 (nome do arquivo) Imprime o nome do arquivo de entrada atual (com uma nova linha à
                 direita).

        'g'
                 Substitua o conteúdo do espaço padrão pelo conteúdo do espaço de espera.


        'G'
               Acrescente uma nova linha ao conteúdo do espaço do padrão e, em seguida, acrescente
               o conteúdo do espaço de retenção ao do espaço do padrão.

        'h'
                 (manter) Substitua o conteúdo do espaço de retenção pelo conteúdo do espaço do padrão.


        'H'
               Anexe uma nova linha ao conteúdo do espaço de retenção e, em seguida, anexe o conteúdo
               do espaço padrão ao do espaço de retenção.

        'i\'
        'TEXT'
                 inserir TEXTO antes de uma linha.

        'eu TEXTO'
                 inserir TEXTO antes de uma linha (sintaxe alternativa).

        'eu'
                 Imprima o espaço padrão de forma inequívoca.

        'n'
                 (próximo) Se a impressão automática não estiver desativada, imprima o espaço do
                 padrão e, independentemente disso, substitua o espaço do padrão pela próxima linha de


                entrada. Se não houver mais entrada, 'sed' sairá sem processar mais nenhum comando.



        'N'
               Adicione uma nova linha ao espaço do padrão e, em seguida, anexe a próxima linha de entrada ao espaço do
               padrão. Se não houver mais entrada, 'sed' sairá sem processar mais nenhum comando.



        'p'
                Imprima o espaço do padrão.

        'P'
                Imprima o espaço do padrão, até a primeira <nova linha>.

        'q[CÓDIGO DE SAÍDA]'
               (sair) Sai do 'sed' sem processar mais nenhum comando ou entrada.

        'Q[CÓDIGO DE SAÍDA]'
                (sair) Este comando é o mesmo que 'q', mas não imprimirá o conteúdo do espaço padrão. Como 'q', ele
                fornece a capacidade de retornar um código de saída para o chamador.



        'r nome do arquivo'
                Lê o arquivo FILENAME.

        'R nome do arquivo'
                Coloque uma linha de FILENAME na fila para ser lida e inserida no fluxo de saída no final do ciclo atual ou
                quando a próxima linha de entrada for lida.



        's/REGEXP/REPLACEMENT/[SINIZADORES]'
                (substituir) Combine a expressão regular com o conteúdo do espaço padrão. Se encontrado, substitua a string
                correspondente por REPLACEMENT.



        't LABEL'
                (teste) Desviar para LABEL somente se houver uma substituição de 's' bem-sucedida desde que a
                última linha de entrada foi lida ou desvio condicional foi feito. O LABEL pode ser omitido, caso em que o
                próximo ciclo é iniciado.



        'ETIQUETA'
                (teste) Desviar para LABEL somente se não houver substituições de 's' bem-sucedidas desde que a
                última linha de entrada foi lida ou desvio condicional foi feito. O LABEL pode ser omitido, caso em que o próximo
                ciclo é iniciado.



        'v [VERSÃO]'
                (versão) Este comando não faz nada, mas faz com que 'sed' falhe se as extensões GNU 'sed' não forem
                suportadas ou se a versão solicitada não estiver disponível.



        'w nome do arquivo'
               Grave o espaço padrão em FILENAME.

        'W nome do arquivo'
               Escreva no nome de arquivo fornecido a parte do espaço padrão até a primeira nova linha



        'x'
                Troque o conteúdo dos espaços de retenção e padrão.

        's/origem/dst/'
                 Translitere quaisquer caracteres no espaço padrão que correspondam a qualquer


                  dos SOURCE-CHARS com o caractere correspondente em DEST-CHARS.

        'z'
                  (zap) Este comando esvazia o conteúdo do espaço padrão.

        '#'
                  Um comentário, até a próxima nova linha.

        '{CMD; CMD ... }' Agrupe
              vários comandos.

        '='
                  Imprima o número da linha de entrada atual (com uma nova linha à direita).

        ': LABEL'
               Especifique a localização de LABEL para comandos de ramificação ('b', 't', 'T').

       Arquivo: sed.info, Nó: O comando "s", Próximo: Comandos comuns, Anterior: lista de comandos sed, Acima:
       scripts sed

       3.3 O Comando 's'
       ===================

       O comando 's' (como substituto) é provavelmente o mais importante em 'sed' e tem muitas opções
       diferentes. A sintaxe do comando 's' é 's/REGEXP/REPLACEMENT/FLAGS'.


            Seu conceito básico é simples: o comando 's' tenta casar o espaço padrão com a expressão
       regular fornecida REGEXP; se a correspondência for bem-sucedida, a parte do espaço padrão que
       foi correspondida é substituída por REPLACEMENT.


          Para obter detalhes sobre a sintaxe REGEXP *note Endereços de Expressão Regular: Endereços
       Regexp.

              O REPLACEMENT pode conter referências '\N' (N sendo um número de 1 a 9, inclusive),
       que se referem à parte da correspondência que está contida entre o N-ésimo '\(' e seu correspondente
       '\)'. Além disso, o REPLACEMENT pode conter caracteres '&' sem escape que fazem
       referência a toda a parte correspondente do espaço padrão.


           Os caracteres '/' podem ser uniformemente substituídos por qualquer outro caractere único
       dentro de qualquer comando 's'. O caractere '/' (ou qualquer outro caractere usado em seu lugar) pode
       aparecer em REGEXP ou REPLACEMENT somente se for precedido por um caractere '\'.


            Finalmente, como uma extensão GNU 'sed', você pode incluir uma sequência especial
       feito de uma barra invertida e uma das letras 'L', 'l', 'U', 'u' ou 'E'.
       O significado é o seguinte:

        '\EU'
                  Gire a substituição para minúsculas até que um '\U' ou '\E' seja encontrado,

        '\eu'
                  Transforme o próximo caractere em minúsculo,

        '\VOCÊ'

                  Gire a substituição para letras maiúsculas até que um '\L' ou '\E' seja encontrado,

        '\você'
                  Transforme o próximo caractere em maiúsculo,

        '\E'
                  Pare a conversão de maiúsculas e minúsculas iniciada por '\L' ou '\U'.


           Quando o sinalizador 'g' está sendo usado, a conversão de caso não se propaga de uma
       ocorrência da expressão regular para outra. Por exemplo, quando o seguinte comando é executado
       com 'ab-' no espaço padrão:
              s/\(b\?\)-/x\u\1/g

       a saída é 'axxB'. Ao substituir o primeiro '-', a sequência '\u' afeta apenas a substituição vazia de
       '\1'. Não afeta o caractere 'x' que é adicionado ao espaço do padrão ao substituir 'b-' por 'xB'.


           Por outro lado, '\l' e '\u' afetam o restante do texto de substituição se forem seguidos por
        uma substituição vazia. Com 'ab-' no espaço padrão, o seguinte comando: s/\(b\?\)-/\u\1x/g



       substituirá '-' por 'X' (maiúsculas) e 'b-' por 'Bx'. Se esse comportamento for indesejável, você
       pode evitá-lo adicionando uma sequência '\E' — depois de '\1' neste caso.


            Para incluir um literal '\', '&' ou nova linha na substituição final, certifique-se de preceder o '\',
       '&' ou nova linha desejado no REPLACEMENT com um '\'.


              O comando 's' pode ser seguido por zero ou mais dos seguintes
        BANDEIRAS:



        'g'
                Aplique a substituição a _all_ corresponde ao REGEXP, não apenas ao primeiro.


        'NÚMERO'
                Substitua apenas a NUMBERª correspondência do REGEXP.

                interação no comando 's' Nota: o padrão POSIX não especifica o que deve acontecer
                quando você mistura os modificadores 'g' e NUMBER, e atualmente não há um
                significado amplamente aceito nas implementações 'sed'. Para GNU 'sed', a interação é
                definida como: ignorar as correspondências antes do NUMBERº e, em seguida,
                corresponder e substituir todas as correspondências do NUMBERº em diante.


        'p'
                Se a substituição foi feita, imprima o novo espaço de padrão.

                Observação: quando as opções 'p' e 'e' são especificadas, a ordem relativa das duas produz
                resultados muito diferentes. Em geral, 'ep' (avaliar e imprimir) é o que você deseja, mas
                operar ao contrário pode ser útil para depuração. Por esta razão, a versão atual do
                GNU 'sed' interpreta especialmente a presença de opções 'p' antes e depois de 'e', imprimindo
                o espaço padrão antes e depois da avaliação, enquanto em geral os sinalizadores para o
                comando 's' mostram seus efeito apenas uma vez. Esse comportamento, embora
                documentado, pode mudar em versões futuras.



        'w NOME DO ARQUIVO'

                Se a substituição foi feita, escreva o resultado no arquivo nomeado. Como uma
                extensão GNU 'sed', dois valores especiais de FILENAME são suportados: '/dev/
                stderr', que grava o resultado no erro padrão, e '/dev/stdout', que grava na saída padrão.(1)



        'e'
                Este comando permite canalizar a entrada de um comando shell para o espaço padrão.
                Se uma substituição foi feita, o comando encontrado no espaço padrão é executado e o
                espaço padrão é substituído


                   com sua saída. Uma nova linha à direita é suprimida; os resultados são indefinidos se o
                   comando a ser executado contiver um caractere NUL.
                   Esta é uma extensão GNU 'sed'.

        'eu'
        'eu'
                   O modificador 'I' para correspondência de expressão regular é uma extensão GNU que faz
                   com que 'sed' corresponda a REGEXP sem distinção entre maiúsculas e minúsculas.


        'Milímetros'

                   O modificador 'M' para correspondência de expressão regular é uma extensão GNU 'sed'
                   que direciona o GNU 'sed' para corresponder à expressão regular no modo 'multilinha'. O
                   modificador faz com que '^' e '$' correspondam respectivamente (além do comportamento
                   normal) à string vazia após uma nova linha e à string vazia antes de uma nova linha. Existem
                   sequências de caracteres especiais ('\`' e '\'') que sempre correspondem ao início ou ao fim do
                   buffer. Além disso, o caractere de ponto não corresponde a um caractere de nova linha no
                   modo multilinha.


               ---------- Notas de rodapé ----------


               (1) Isso é equivalente a 'p', a menos que a opção '-i' esteja sendo usada.

       Arquivo: sed.info, Nó: Comandos Comuns, Próximo: Outros Comandos, Anterior: O "s"
       Comando, Up: scripts sed

       3.4 Comandos mais usados
       =========================

        Se você usar 'sed', provavelmente desejará conhecer esses comandos.


        '#'
                       [Não são permitidos endereços.]

                   O caractere '#' inicia um comentário; o comentário continua até a próxima nova linha.


                   Se você está preocupado com a portabilidade, esteja ciente de que algumas
                   implementações de 'sed' (que não estão em conformidade com POSIX) podem suportar apenas
                   um único comentário de uma linha e somente quando o primeiro caractere do script for
                   um '#'.

                   Aviso: se os dois primeiros caracteres do script 'sed' forem '#n', a opção '-n' (sem impressão
                   automática) será forçada. Se você quiser colocar um comentário na primeira linha do seu script
                   e esse comentário começar com a letra 'n' e você não quiser esse comportamento, certifique-
                   se de usar um 'N' maiúsculo ou coloque pelo menos um espaço antes de'.



        'q [CÓDIGO DE SAÍDA]'
                   Saia do 'sed' sem processar mais nenhum comando ou entrada.

                   Exemplo: pare após imprimir a segunda linha:
                        $ seq 3 | sed 2q 1

                             2

                   Este comando aceita apenas um endereço. Observe que o espaço do padrão atual é
                   impresso se a impressão automática não estiver desativada com as opções '-n'. A
                    capacidade de retornar um código de saída do script 'sed' é uma extensão GNU 'sed'.


              Veja também o comando GNU 'sed' extension 'Q' que fecha silenciosamente sem imprimir o
              espaço padrão atual.

        'd'
              Exclua o espaço padrão; iniciar imediatamente o próximo ciclo.

              Exemplo: exclua a segunda linha de entrada: $ seq 3
                   | sed 2d 1

                     3

        'p'
              Imprima o espaço do padrão (para a saída padrão). Esse comando geralmente é usado apenas
              em conjunto com a opção de linha de comando '-n'.


              Exemplo: imprimir apenas a segunda linha de entrada: $
                   seq 3 | sed -n 2p 2


        'n'
              Se a impressão automática não estiver desativada, imprima o espaço do padrão e,
              independentemente disso, substitua o espaço do padrão pela próxima linha de entrada.
              Se não houver mais entrada, 'sed' sairá sem processar mais nenhum comando.


              Este comando é útil para pular linhas (por exemplo, processar cada linha Nth).


              Exemplo: realizar substituição a cada 3ª linha (isto é, dois comandos 'n' pulam duas
              linhas): $ seq 6 | sed 'n;n;s/./x/' 1


                     2
                     x
                     4
                     5
                     x

              GNU 'sed' fornece uma sintaxe de endereço de extensão de FIRST~STEP para obter o
              mesmo resultado:

                     $ seq 6 | sed '0~3s/./x/' 1 2


                     x
                     4
                     5
                     x

        '{ COMANDOS }'
              Um grupo de comandos pode ser colocado entre os caracteres '{' e '}'.
              Isso é particularmente útil quando você deseja que um grupo de comandos seja acionado por
              uma única correspondência de endereço (ou intervalo de endereços).

              Exemplo: execute a substituição e imprima a segunda linha de entrada:
                   $ seq 3 | sed -n '2{s/2/X/ ; p}'
                   x

       Arquivo: sed.info, Nó: Outros Comandos, Avançar: Comandos de Programação, Anterior: Comandos
       Comuns, Acima: scripts sed

       3.5 Comandos usados com menos frequência
       =================================



       Embora talvez menos frequentemente usados do que os da seção anterior, alguns scripts 'sed' muito
       pequenos, mas úteis, podem ser criados com esses comandos.


        'y/SOURCE-CHARS/DEST-CHARS/'
              Translitera qualquer caractere no espaço padrão que corresponda a qualquer um dos
              SOURCE-CHARS com o caractere correspondente em DEST-CHARS.

              Exemplo: transliterar 'a-j' para '0-9': $ echo hello world |
                   sed 'y/abcdefghij/0123456789/' 74llo worl3


              (Os caracteres '/' podem ser uniformemente substituídos por qualquer outro caractere único
              dentro de qualquer comando 'y' dado.)

              Instâncias de '/' (ou qualquer outro caractere usado em seu lugar), '\' ou novas linhas podem
              aparecer nas listas SOURCE-CHARS ou DEST-CHARS, desde que cada instância
              tenha um '\' como escape.
              As listas SOURCE-CHARS e DEST-CHARS _devem_ conter o mesmo número de
              caracteres (após o de-escape).

              Consulte o comando 'tr' do GNU coreutils para obter funcionalidade semelhante.

        'um texto'
               Acrescentar TEXTO após uma linha. Esta é uma extensão GNU para o comando
               padrão 'a' - veja abaixo para detalhes.

              Exemplo: Adicione 'olá' após a segunda linha: $ seq 3 | sed
                   '2a olá' 1


                     2 olá
                     3

              O espaço em branco inicial após o comando 'a' é ignorado. O texto a adicionar é lido até ao
              fim da linha.

        'a\'
        'TEXTO'
              Acrescentando TEXTO após uma linha.

              Exemplo: Adicione 'hello' após a segunda linha ( indica linhas deÿ saída impressas): $ seq
              3 | sed '2a\ olá' 1ÿ
                      2ÿ olá ÿ 3ÿ




              O comando 'a' enfileira as linhas de texto que seguem este comando (cada uma exceto a
              última terminando com um '\', que são removidas da saída) para serem exibidas no final do
              ciclo atual ou quando a próxima linha de entrada está lido.


              Como uma extensão GNU, este comando aceita dois endereços.

              As sequências de escape em TEXT são processadas, então você deve usar '\\' em TEXT
              para imprimir uma única barra invertida.

              Os comandos continuam após a última linha sem barra invertida ('\') - 'world' no exemplo a seguir:

                     $ seq 3 | sed '2a\


                           olá\
                           mundo
                           3s/./X/' 1ÿ 2ÿ
                           olá
                           ÿ
                           mundo ÿ

                           Xÿ


                 Como uma extensão GNU, o comando 'a' e o TEXT podem ser separados em dois parâmetros '-e', facilitando a
                 criação de scripts: $ seq 3 | sed -e '2a\' -e alô 1




                           2 olá 3



                           $ sed -e '2a\' -e "$VAR"

        'eu TEXTO'
                  inserir TEXTO antes de uma linha. Esta é uma extensão GNU para o comando 'i' padrão - veja abaixo para detalhes.



                  Exemplo: Insira 'olá' antes da segunda linha: $ seq 3 | sed '2i olá' 1



                           olá 2 3




                  O espaço em branco inicial após o comando 'i' é ignorado. O texto a adicionar é lido até ao fim da linha.



        'i\'
        'TEXT'
                 Imprima imediatamente as linhas de texto que seguem este comando.

                  Exemplo: Insira 'hello' antes da segunda linha ( indica linhas de saída impressas): $ ÿseq 3 | sed '2i\ olá' 1ÿ olá ÿ 2ÿ
                  3ÿ




                 Como uma extensão GNU, este comando aceita dois endereços.

                 As sequências de escape em TEXT são processadas, então você deve usar '\\' em TEXT para imprimir uma
                 única barra invertida.

                 Os comandos continuam após a última linha sem barra invertida ('\') - 'world' no exemplo a seguir:

                           $ seq 3 | sed '2i\ olá\ mundo s/./
                           X/'



                           Xÿ
                           olá ÿ
                           mundo ÿ
                           Xÿ
                           Xÿ


                 Como uma extensão GNU, o comando 'i' e TEXT podem ser separados em


                  dois parâmetros '-e', facilitando a criação de scripts: $ seq 3 | sed -e '2i\' -e alô 1
                          alô 2 3




                           $ sed -e '2i\' -e "$VAR"

        'c TEXTO'
                  Substitui a(s) linha(s) por TEXTO. Esta é uma extensão GNU para o comando 'c' padrão - veja abaixo para
                  detalhes.


                  Exemplo: Substitua da 2ª à 9ª linhas pela palavra 'olá':
                         $ seq 10 | sed '2,9c olá' 1 olá 10




                  O espaço em branco inicial após o comando 'c' é ignorado. O texto a adicionar é lido até ao fim da linha.



        'c\'
        'TEXT'
                 Exclua as linhas correspondentes ao endereço ou intervalo de endereços e imprima as linhas de texto que seguem
                  este comando.


                  Exemplo: Substitua da 2ª à 4ª linhas pelas palavras 'hello' e 'world' (indica linhas de saída impressas):
                                   ÿ
                           $ seq 5 | sed '2,4c\ alô\ mundo' 1ÿ
                           alô ÿ
                           mundo ÿ
                           5ÿ




                  Se nenhum endereço for fornecido, cada linha será substituída.

                 Um novo ciclo é iniciado após a execução deste comando, pois o espaço do padrão terá sido excluído.
                 No exemplo a seguir, o 'c' inicia um novo ciclo e o comando de substituição não é executado no texto
                 substituído:



                           $ seq 3 | sed '2c\ alô s/./X/'



                           Xÿ
                           olá ÿ
                           Xÿ


                 Como uma extensão GNU, o comando 'c' e o TEXT podem ser separados em dois parâmetros '-e', facilitando a
                 criação de scripts: $ seq 3 | sed -e '2c\' -e alô 1 alô




                           3

                           $ sed -e '2c\' -e "$VAR"

        '='
                  Imprima o número da linha de entrada atual (com uma nova linha à direita).

                           $ printf '%s\n' aaa bbb ccc | sed =




                         1
                         aaa

                         2
                         bbb 3
                         ccc

                  Como uma extensão GNU, este comando aceita dois endereços.

        'l N'
                Imprime o espaço padrão em uma forma inequívoca: caracteres não imprimíveis (e o
                  caractere '\') são impressos em forma de escape no estilo C; linhas longas são divididas, com
                  um caractere '\' à direita para indicar a divisão; o final de cada linha é marcado com
                  um '$'.

                  N especifica o comprimento de quebra de linha desejado; um comprimento de 0 (zero)
                  significa nunca quebrar linhas longas. Se omitido, o padrão especificado na linha de
                  comando será usado. O parâmetro N é uma extensão GNU 'sed'.


        'r NOME DO ARQUIVO'


                  Lê o arquivo FILENAME. Exemplo:

                         $ seq 3 | sed '2r/etc/hostname' 1


                         2 fencepost.gnu.org 3


                  Enfileire o conteúdo de FILENAME para ser lido e inserido no fluxo de saída no final do
                  ciclo atual ou quando a próxima linha de entrada for lida. Observe que se FILENAME não
                  puder ser lido, ele será tratado como se fosse um arquivo vazio, sem nenhuma indicação de
                  erro.

                  Como uma extensão GNU 'sed', o valor especial '/dev/stdin' é suportado para o nome
                  do arquivo, que lê o conteúdo da entrada padrão.


                  Como uma extensão GNU, este comando aceita dois endereços. O arquivo será então relido
                  e inserido em cada uma das linhas endereçadas.

                  Como uma extensão GNU 'sed', o comando 'r' aceita um endereço zero, inserindo um arquivo
                  _antes_ da primeira linha da entrada *nota Adicionando um cabeçalho a vários arquivos::.


        'w NOME DO ARQUIVO'

                  Grave o espaço padrão em FILENAME. Como uma extensão GNU 'sed', dois valores especiais
                  de FILENAME são suportados: '/dev/stderr', que grava o resultado no erro padrão, e '/dev/
                  stdout', que grava na saída padrão.(1)


                  O arquivo será criado (ou truncado) antes que a primeira linha de entrada seja lida; todos os
                  comandos 'w' (incluindo instâncias do sinalizador 'w' em comandos 's' bem-sucedidos) que se
                  referem ao mesmo FILENAME são gerados sem fechar e reabrir o arquivo.


        'D'
                  Se o espaço padrão não contiver nova linha, inicie um novo ciclo normal como se o comando
                  'd' tivesse sido emitido. Caso contrário, exclua o texto no espaço padrão até a primeira
                  nova linha e reinicie o ciclo com o espaço padrão resultante, sem ler uma nova linha de
                  entrada.

        'N'


                 Adicione uma nova linha ao espaço do padrão e, em seguida, anexe a próxima linha de
                 entrada ao espaço do padrão. Se não houver mais entrada, 'sed' sairá sem processar
                 mais nenhum comando.

                 Quando '-z' é usado, um byte zero (o caractere ascii 'NUL') é adicionado entre as linhas (em
                 vez de uma nova linha).

                 Por padrão, 'sed' não termina se não houver nenhuma linha de entrada 'próxima'. Esta
                 é uma extensão GNU que pode ser desativada com '--posix'. *Observe o
                 comando N na última linha: N_command_last_line.

        'P'
                 Imprima a parte do espaço do padrão até a primeira nova linha.

        'h'
                 Substitua o conteúdo do espaço de espera pelo conteúdo do espaço padrão.


        'H'
                 Anexe uma nova linha ao conteúdo do espaço de retenção e, em seguida, anexe o conteúdo
                 do espaço padrão ao do espaço de retenção.

        'g'
                 Substitua o conteúdo do espaço padrão pelo conteúdo do espaço de espera.


        'G'
                 Acrescente uma nova linha ao conteúdo do espaço do padrão e, em seguida, acrescente
                 o conteúdo do espaço de retenção ao do espaço do padrão.

        'x'
                 Troque o conteúdo dos espaços de retenção e padrão.

              ---------- Notas de rodapé ----------


              (1) Isso é equivalente a 'p', a menos que a opção '-i' esteja sendo usada.

       Arquivo: sed.info, Nó: Comandos de Programação, Próximo: Comandos Estendidos, Anterior: Outros
       Comandos, Acima: scripts sed

       3.6 Comandos para gurus 'sed'
       ============================

       Na maioria dos casos, o uso desses comandos indica que provavelmente é melhor programar
       em algo como 'awk' ou Perl. Mas, ocasionalmente, alguém se compromete a usar
       'sed', e esses comandos podem permitir que alguém escreva scripts bastante complicados.


        ': RÓTULO'
                  [Não são permitidos endereços.]

                 Especifique a localização de LABEL para comandos de ramificação. Em todos os outros
                 aspectos, um no-op.

        'b LABEL'
              Desvia incondicionalmente para LABEL. O LABEL pode ser omitido, caso em que o
              próximo ciclo é iniciado.

        't LABEL'
               Desvie para LABEL somente se houver uma substituição de 's' bem-sucedida desde que a
               última linha de entrada foi lida ou desvio condicional foi feito.
              O LABEL pode ser omitido, caso em que o próximo ciclo é iniciado.

        Arquivo: sed.info, Nó: Comandos estendidos, Próximo: sintaxe de vários comandos,


       Anterior: Comandos de Programação, Acima: scripts sed

       3.7 Comandos específicos para GNU 'sed'
       ==================================

       Esses comandos são específicos do GNU 'sed', portanto, você deve usá-los com cuidado e somente
       quando tiver certeza de que impedir a portabilidade não é um mal. Eles permitem que você verifique as
       extensões GNU 'sed' ou execute tarefas que são necessárias com bastante frequência, mas não
       são suportadas pelos 'sed's padrão.

        'e [COMANDO]'
              Este comando permite canalizar a entrada de um comando shell para o espaço padrão. Sem
              parâmetros, o comando 'e' executa o comando encontrado no espaço padrão e substitui o
              espaço padrão pela saída; uma nova linha à direita é suprimida.


               Se um parâmetro for especificado, em vez disso, o comando 'e' o interpreta como um comando e
               envia sua saída para o fluxo de saída. O comando pode ser executado em várias linhas,
               todas exceto a última terminando com uma barra invertida.


               Em ambos os casos, os resultados são indefinidos se o comando a ser executado contiver
               um caractere NUL.

               Observe que, ao contrário do comando 'r', a saída do comando será impressa imediatamente;
               o comando 'r', em vez disso, atrasa a saída para o final do ciclo atual.


        'F'
               Imprima o nome do arquivo de entrada atual (com uma nova linha à direita).


        'Q [EXIT-CODE]'
               Este comando aceita apenas um endereço.

               Este comando é o mesmo que 'q', mas não imprimirá o conteúdo do espaço padrão. Como 'q', ele
               fornece a capacidade de retornar um código de saída para o chamador.


               Este comando pode ser útil porque as únicas alternativas para realizar esta função
               aparentemente trivial são usar a opção '-n' (que pode complicar desnecessariamente seu
               script) ou recorrer ao seguinte snippet, que desperdiça tempo lendo o arquivo inteiro
               sem nenhum efeito visível:


                        :comer
                        $d         Sair silenciosamente na última linha
                        N          Leia outra linha, silenciosamente
                                   Substitua o espaço do padrão a cada vez para economizar memória
                        gb comer

        'R NOME DO ARQUIVO'

               Coloque uma linha de FILENAME na fila para ser lida e inserida no fluxo de saída no final do
               ciclo atual ou quando a próxima linha de entrada for lida. Observe que se FILENAME não puder
               ser lido, ou se seu fim for atingido, nenhuma linha será acrescentada, sem qualquer indicação
               de erro.

               Assim como com o comando 'r', o valor especial '/dev/stdin' é suportado para o nome
               do arquivo, que lê uma linha da entrada padrão.


        'ETIQUETA'
              Ramifique para LABEL somente se não houver substituições de 's' bem-
              sucedidas desde que a última linha de entrada foi lida ou condicional


                ramo foi tomado. O LABEL pode ser omitido, caso em que o próximo ciclo é iniciado.


        'v VERSION'
              Este comando não faz nada, mas faz com que 'sed' falhe se as extensões GNU 'sed'
              não forem suportadas, simplesmente porque outras versões de 'sed' não o implementam.
               Além disso, você pode especificar a versão de 'sed' que seu script requer, como
              '4.0.5'. O padrão é '4.0' porque esta é a primeira versão que implementou este comando.



                Este comando ativa todas as extensões GNU mesmo se 'POSIXLY_CORRECT' estiver
                definido no ambiente.

        'W NOME DO ARQUIVO'

                Escreva no nome de arquivo fornecido a parte do espaço padrão até a primeira nova linha.
                Tudo dito sob o comando 'w' sobre o manuseio de arquivos vale aqui também.


        'z'
                Este comando esvazia o conteúdo do espaço padrão. Geralmente é o mesmo que 's/.*//', mas
                é mais eficiente e funciona na presença de sequências multibyte inválidas no fluxo de
                entrada. O POSIX exige que tais sequências _não_ sejam correspondidas por '.', de modo que
                não haja uma maneira portátil de limpar os buffers de 'sed' no meio do script na maioria
                das localidades multibyte (incluindo localidades UTF-8).


        Arquivo: sed.info, Nó: sintaxe de vários comandos, Anterior: Comandos estendidos, Acima: scripts sed


       3.8 Sintaxe de comandos múltiplos
       ============================

       Existem vários métodos para especificar vários comandos em um programa 'sed'.


            O uso de novas linhas é mais natural ao executar um script sed de um arquivo
        (usando a opção '-f').

          Na linha de comando, todos os comandos 'sed' podem ser separados por novas linhas.
       Como alternativa, você pode especificar cada comando como um argumento para uma opção '-e':


                $ seq 6 | sed '1d 3d 5d'
                2


                4
                6

                $ seq 6 | sed -e 1d -e 3d -e 5d 2 4


                6

              Um ponto e vírgula (';') pode ser usado para separar os comandos mais simples:

                $ seq 6 | sed '1d;3d;5d' 2

                4
                6

           Os comandos '{','}','b','t','T',':' podem ser separados com um
       ponto-e-vírgula (esta é uma extensão GNU 'sed' não portátil).


                 $ seq 4 | sed '{1d;3d}' 2

                  4

                 $ seq 6 | sed '{1d;3d};5d' 2

                  4
                  6

            Os rótulos usados nos comandos 'b','t','T',':' são lidos até um ponto e vírgula.
       Os espaços em branco iniciais e finais são ignorados. Nos exemplos abaixo, o rótulo é 'x'. O primeiro
       exemplo funciona com GNU 'sed'. O segundo é um equivalente portátil. Para obter mais informações sobre
       ramificação e rótulos *observe Ramificação e controle de fluxo::.


                 $ seq 3 | sed '/1/bx ; s/^/=/ ; : x ; 3d' 1 =2




                 $ seq 3 | sed -e '/1/bx' -e 's/^/=/' -e ':x' -e '3d' 1

                  =2

       3.8.1 Comandos que requerem uma nova linha
        ----------------------------------


       Os seguintes comandos não podem ser separados por ponto e vírgula e requerem uma nova linha:


        'a','c','i' (acrescentar/alterar/inserir)

                 Todos os caracteres após os comandos 'a','c','i' são considerados como o texto para anexar/alterar/
                 inserir. Usar um ponto e vírgula leva a resultados indesejáveis:


                            $ seq 2 | sed '1aOlá ; 2d' 1

                            Olá ; 2d 2


                 Separe os comandos usando '-e' ou uma nova linha:

                            $ seq 2 | sed -e 1aOlá -e 2d 1

                            Olá

                            $ seq 2 | sed '1aOlá 2d' 1


                            Olá

                  Observe que especificar o texto a ser adicionado ('Hello') imediatamente após 'a','c','i' é em si uma
                  extensão GNU 'sed'. Uma alternativa portátil compatível com POSIX é:


                            $ seq 2 | sed '1a\
                            Olá 2d'

                            1
                            Olá

        '#' (Comente)


                Todos os caracteres após '#' até a próxima nova linha são ignorados.

                         $ seq 3 | sed '# isso é um comentário; 2d' 1 2 3




                         $ seq 3 | sed '# isto é um comentário 2d'

                         1
                         3

        'r','R','w','W' (leitura e gravação de arquivos)

                Os comandos 'r','R','w','W' analisam o nome do arquivo até o final da linha. Se forem encontrados
                espaços em branco, comentários ou ponto e vírgula, eles serão incluídos no nome do arquivo,
                levando a resultados inesperados:

                         $ seq 2 | sed '1w olá.txt ; 2d' 1 2




                         $ ls -log total
                         4 -rw-rw-
                         r-- 1 2 Jan 23 23:03 hello.txt ; 2d

                         $ cat 'olá.txt ; 2d' 1


                Observe que 'sed' ignora silenciosamente erros de leitura/gravação em
                comandos 'r','R','w','W' (como arquivos ausentes). No exemplo a seguir, 'sed' tenta ler um arquivo
                chamado ''hello.txt ; N''. O arquivo está ausente e o erro é silenciosamente ignorado:


                         $ eco x | sed '1rhello.txt ; N'
                         x

        'e' (execução do comando)

                Quaisquer caracteres após o comando 'e' até o final da linha serão enviados para o shell. Se forem
                encontrados espaços em branco, comentários ou ponto e vírgula, eles serão incluídos no comando
                shell, levando a resultados inesperados:


                         $ eco a | sed '1e toque foo#bar' a


                         $ ls -1
                         foo#bar

                         $ eco a | sed '1e toque foo ; s/a/b/' sh: 1: s/a/b/: não
                         encontrado
                         a

        's///[nós]' (substitua por flags 'e' ou 'w')

                Em um comando de substituição, o sinalizador 'w' grava o resultado da substituição em um
                arquivo e o sinalizador 'e' executa o resultado da substituição como um comando shell. Assim como
                os comandos 'r/R/w/W/e', eles devem terminar com uma nova linha. Se forem encontrados
                espaços em branco, comentários ou ponto e vírgula, eles serão incluídos no comando
                shell ou no nome do arquivo, levando a resultados inesperados:


                         $ eco a | sed 's/a/b/w1.txt#foo' b


                         $ ls -1
                         1.txt#foo

        Arquivo: sed.info, Nó: endereços sed, Próximo: expressões regulares sed, Anterior: scripts sed, Acima: Início


       4 Endereços: selecionando linhas
       ****************************

        *   Cardápio:


        * Visão geral dos endereços::                                  Visão geral de endereços
        * Endereços Numéricos::                                        selecionando linhas por números
        *
          Endereços Regexp::                                           selecionando linhas por correspondência de
        *
          Endereços de intervalo::                                     texto selecionando um intervalo de linhas
        * Endereço Zero::
                                                                       Usando o endereço '0'

        Arquivo: sed.info, Nó: Visão geral de endereços, Avançar: Endereços numéricos, Acima: endereços sed


       4.1 Visão geral dos endereços
       ======================

       Os endereços determinam em qual(is) linha(s) o comando 'sed' será executado.
       O seguinte comando substitui qualquer primeira ocorrência de 'hello' por 'world' apenas na linha 144:


                 sed '144s/hello/world/' input.txt > output.txt

            Se nenhum endereço for especificado, o comando será executado em todas as linhas.
       O comando a seguir substitui 'hello' por 'world', visando cada linha do arquivo de entrada. No entanto,
       observe que ele modifica apenas a primeira instância de 'hello' em cada linha. Use o modificador 'g' para
       afetar cada instância em cada linha afetada.


                 sed 's/hello/world/' input.txt > output.txt

            Os endereços podem conter expressões regulares para corresponder linhas com base no conteúdo
       em vez de números de linha. O comando a seguir substitui 'hello' por 'world' apenas nas linhas que contêm
       a string 'apple':

                 sed '/apple/s/hello/world/' input.txt > output.txt

           Um intervalo de endereços é especificado com dois endereços separados por vírgula (','). Os endereços
       podem ser numéricos, expressões regulares ou uma mistura de ambos.
       O seguinte comando substitui 'hello' por 'world' apenas nas linhas 4 a 17 (inclusive):


                 sed '4,17s/hello/world/' input.txt > output.txt

           Acrescentando o '!' caractere ao final de uma especificação de endereço (antes da letra de comando)
        nega o sentido da correspondência. Ou seja, se o '!' caractere segue um endereço ou um intervalo de
        endereços, somente as linhas que _não_ correspondem aos endereços serão selecionadas. O
        comando a seguir substitui 'hello' por 'world' apenas nas linhas _não_ contendo a string 'apple':




                 sed '/apple/!s/hello/world/' input.txt > output.txt

            O seguinte comando substitui 'hello' por 'world' apenas nas linhas 1
        para 3 e da linha 18 até a última linha do arquivo de entrada (ou seja


       excluindo linhas 4 a 17):

               sed '4,17!s/hello/world/' input.txt > output.txt

       Arquivo: sed.info, Nó: Endereços Numéricos, Avançar: Endereços Regexp, Anterior: Visão geral de endereços,
       Acima: endereços sed

       4.2 Selecionando linhas por números
       ==============================

       Os endereços em um script 'sed' podem estar em qualquer um dos seguintes formatos: 'NUMBER'
       A
         especificação de um número de linha corresponderá apenas a essa linha na entrada.
              (Observe que 'sed' conta as linhas continuamente em todos os arquivos de entrada, a menos que
             as opções '-i' ou '-s' sejam especificadas.)

        '$'
               Este endereço corresponde à última linha do último arquivo de entrada ou à última linha de cada
               arquivo quando as opções '-i' ou '-s' são especificadas.


        'PRIMEIRO ~ PASSO'
               Esta extensão GNU corresponde a cada linha STEPth começando com a linha FIRST. Em
               particular, as linhas serão selecionadas quando existir um N não negativo tal que o número da
               linha atual seja igual a FIRST + (N * STEP). Assim, pode-se usar '1~2' para selecionar as linhas
               ímpares e '0~2' para linhas pares; para escolher cada terceira linha começando com a
               segunda, '2~3' seria usado; para selecionar cada quinta linha começando com a décima, use
               '10~5'; e '50~0' é apenas uma forma obscura de dizer '50'.




               Os comandos a seguir demonstram o uso do endereço da etapa:

                       $ seq 10 | sed -n '0~4p' 4 8




                       $ seq 10 | sed -n '1~3p' 1

                       4

                       7 10


       Arquivo: sed.info, Nó: Endereços Regexp, Próximo: Endereços de Intervalo, Anterior: Endereços Numéricos, Acima:
       endereços sed

       4.3 selecionando linhas por correspondência de texto
       ====================================

       GNU 'sed' suporta os seguintes endereços de expressão regular. A expressão regular padrão é *note
       Expressão regular básica (BRE): sintaxe BRE. Se as opções '-E' ou '-r' forem usadas, a expressão regular
       deve estar em *note Expressão regular estendida (ERE): sintaxe ERE. sintaxe.

        *Nota BRE vs ERE::.

        '/REGEXP/'
              Isso selecionará qualquer linha que corresponda à expressão regular REGEXP. Se o próprio
              REGEXP incluir qualquer caractere '/', cada um deverá ser precedido por uma barra invertida ('\').


               O seguinte comando imprime linhas em '/etc/passwd' que terminam com 'bash'(1):


                       sed -n '/bash$/p' /etc/passwd


                  A expressão regular vazia '//' repete a última correspondência de expressão regular
                  (o mesmo ocorre se a expressão regular vazia for passada para o comando 's'). Observe que os
                  modificadores para expressões regulares são avaliados quando a expressão regular
                  é compilada, portanto, é inválido especificá-los junto com a expressão regular vazia.



        '\
             %REGEXP%' (O '%' pode ser substituído por qualquer outro caractere único.)

                  Isso também corresponde à expressão regular REGEXP, mas permite usar um delimitador
                  diferente de '/'. Isso é particularmente útil se o próprio REGEXP contiver muitas barras, pois evita
                  o tedioso escape de cada '/'. Se o próprio REGEXP incluir qualquer caractere delimitador,
                  cada um deverá ser precedido por uma barra invertida ('\').


                  Os seguintes comandos são equivalentes. Eles imprimem linhas que começam com '/
                  home/fulano/documents/':

                         sed -n '/^\/home\/fulano\/documentos\//p' sed -n '\%^/
                         home/fulano/documentos/%p' sed -n '\;^/home/fulano/
                         documentos /;p'

        '/REGEXP/I'
        '\%REGEXP%I'
              O modificador 'I' para a correspondência de expressão regular é uma extensão GNU que faz
              com que o REGEXP seja correspondido sem distinção entre maiúsculas e minúsculas.

                  Em muitas outras linguagens de programação, um 'i' minúsculo é usado para correspondência
                  de expressão regular sem distinção entre maiúsculas e minúsculas. No entanto, em 'sed' o
                  'i' é usado para o comando de inserção (*observe o comando de inserção::).

                  Observe a diferença entre os exemplos a seguir.

                  Neste exemplo, '/b/I' é o endereço: expressão regular com o modificador 'I'. 'd' é o comando de
                  exclusão:

                         $ printf "%s\n" abc | sed '/b/Id'
                         a
                         c

                  Aqui, '/b/' é o endereço: uma expressão regular. 'i' é o comando de inserção. 'd' é o valor
                  a inserir. Uma linha com 'd' é então inserida acima da linha correspondente:


                         $ printf "%s\n" abc | sed '/b/id'
                         a
                         banco




                         de dados




                         c

        '/REGEXP/M'
        '\%REGEXP%M'
              O modificador 'M' para correspondência de expressão regular é uma extensão GNU 'sed'
              que direciona o GNU 'sed' para corresponder à expressão regular no modo 'multilinha'. O
              modificador faz com que '^' e '$' correspondam respectivamente (além do comportamento
              normal) à string vazia após uma nova linha e à string vazia antes de uma nova linha. Existem
              sequências de caracteres especiais ('\`' e '\'') que sempre correspondem ao início ou ao fim do
              buffer. Além disso, o caractere de ponto não corresponde a um caractere de nova linha no
              modo multilinha.


               Os endereços Regex operam no conteúdo do espaço padrão atual.


        Se o espaço padrão for alterado (por exemplo, com o comando 's///'), a correspondência de expressão regular
        operará no texto alterado.

            No exemplo a seguir, a impressão automática é desativada com '-n'.
       O comando 's/2/X/' muda as linhas contendo '2' para 'X'. O comando '/[0-9]/p' combina linhas com dígitos e os
       imprime. Como a segunda linha é alterada antes do regex '/[0-9]/', ela não corresponderá e não será impressa:




                $ seq 3 | sed -n 's/2/X/ ; /[0-9]/p'1

                3

             ---------- Notas de rodapé ----------


             (1) É claro que existem muitas outras maneiras de fazer o mesmo, por exemplo
                 grep 'bash$' /etc/passwd awk -F: '$7 ==
                "/bin/bash"' /etc/passwd

        Arquivo: sed.info, Nó: Endereços de Intervalo, Avançar: Endereço Zero, Anterior: Endereços Regexp, Acima: endereços sed



       4.4 Endereços de Intervalo
       ===================


       Um intervalo de endereços pode ser especificado especificando dois endereços separados por uma vírgula (','). Um
       intervalo de endereços corresponde a linhas começando de onde o primeiro endereço corresponde e continua até
       que o segundo endereço corresponda (inclusive):



                $ seq 10 | sed -n '4,6p' 4 5


                6

            Se o segundo endereço for um REGEXP, verifique a correspondência final
       começará com a linha _seguindo_ a linha que corresponde ao primeiro endereço: um intervalo sempre abrangerá
       pelo menos duas linhas (exceto, é claro, se o fluxo de entrada terminar).



                $ seq 10 | sed -n '4,/[0-9]/p' 4

                5


            Se o segundo endereço for um NÚMERO menor que (ou igual a) a linha
       correspondendo ao primeiro endereço, apenas uma linha é correspondida:

                $ seq 10 | sed -n '4,1p' 4



          GNU 'sed' também suporta alguns formulários especiais de dois endereços; todas essas são extensões GNU: '0,/
       REGEXP/' Um número
        de linha de '0' pode
                ser usado em uma especificação de endereço como '0,/REGEXP/' para que 'sed' tente corresponder a
                 REGEXP na primeira linha de entrada também. Em outras palavras, '0,/REGEXP/' é semelhante a '1,/
                REGEXP/', exceto que se ADDR2 corresponder à primeira linha de entrada, o formulário '0,/
                 REGEXP/' irá considerá-lo como finalizando o intervalo, enquanto a forma '1,/REGEXP/' corresponderá ao
                início de seu intervalo e, portanto, fará com que o intervalo se estenda até a _segunda_ ocorrência da
                expressão regular.




                Os exemplos a seguir demonstram a diferença entre iniciar com endereço 1 e 0:





                        $ seq 10 | sed -n '1,/[0-9]/p' 1

                        2

                        $ seq 10 | sed -n '0,/[0-9]/p' 1


        'ADDR1,+N'
             Corresponde a ADDR1 e as N linhas após ADDR1.

                        $ seq 10 | sed -n '6,+2p' 6

                        7
                        8

                 ADDR1 pode ser um número de linha ou uma expressão regular.

        'ADDR1,~N'
             Corresponde a ADDR1 e as linhas seguintes a ADDR1 até a próxima linha cujo número de
             linha de entrada é um múltiplo de N. O comando a seguir imprime começando na linha 6, até a
             próxima linha que é um múltiplo de 4 (ou seja, linha 8 ):


                        $ seq 10 | sed -n '6,~4p' 6 7 8




                 ADDR1 pode ser um número de linha ou uma expressão regular.

        Arquivo: sed.info, Node: Zero Address, Prev: Range Addresses, Up: sed address

       4.5 Endereço Zero
       ================

       Como uma extensão GNU 'sed', o endereço '0' pode ser usado em dois casos:
         1. Em um intervalo de regex, endereços como '0,/REGEXP/' (*note Endereço Zero
             Faixa Regex::).
         2. Com o comando 'r', inserindo um arquivo antes da primeira linha (*nota
             Adicionando um cabeçalho a vários arquivos::).

           Observe que esses são os únicos lugares onde o endereço '0' faz sentido; Os comandos
       que recebem o endereço '0' de qualquer outra forma darão um erro.


        Arquivo: sed.info, Nó: expressões regulares sed, Próximo: sed avançado, Anterior: endereços sed, Acima: Topo


       5 Expressões Regulares: selecionando texto
       **************************

        *   Cardápio:


        * Visão geral das expressões regulares:: Visão geral da expressão regular em 'sed'
        * BRE x ERE::
                                                  Sintaxe de expressão regular básica (BRE) e estendida (ERE)
        *
           Sintaxe BRE::                         Visão geral da sintaxe básica de expressões regulares
        *
           Sintaxe ERE::                         Visão geral da sintaxe de expressão regular estendida
        * Classes de caracteres e expressões de colchetes:: extensões
        *
           regexp::                              Comandos de expressão regular adicionais
        * Referências inversas e subexpressões:: Referências inversas e subexpressões
        *
           Fugas::                               Especificando caracteres especiais
        * Considerações de localidade::          Caracteres multibyte e considerações de localidade





        Arquivo: sed.info, Nó: Visão geral de expressões regulares, Próximo: BRE vs ERE, Acima: expressões regulares
        sed

       5.1 Visão geral da expressão regular em 'sed'
       ===========================================

       Para saber como usar 'sed', as pessoas devem entender expressões regulares (“regexp” para
       abreviar). Uma expressão regular é um padrão que corresponde a uma string de assunto da esquerda
       para a direita. A maioria dos caracteres é “comum”: eles representam a si mesmos em um
       padrão e correspondem aos caracteres correspondentes. Expressões regulares em 'sed' são
       especificadas entre duas barras.


           O seguinte comando imprime linhas contendo a string 'hello':

              sed -n '/olá/p'

           O exemplo acima é equivalente a este comando 'grep':

              grep 'olá'

            O poder das expressões regulares vem da capacidade de incluir alternativas e repetições no
       padrão. Estes são codificados no padrão pelo uso de “caracteres especiais”, que não representam
       a si mesmos, mas são interpretados de alguma maneira especial.


           O caractere '^' (caret) em uma expressão regular corresponde ao início da linha. O
       personagem '.' (ponto) corresponde a qualquer caractere único. O comando 'sed' a seguir
       corresponde e imprime linhas que começam com a letra 'b', seguida por qualquer caractere único,
       seguido pela letra 'd':


              $ printf "%s\n" morada cama ruim bit lance byte corpo | sed -n '/^bd/p' corpo do lance de cama
              ruim




           As seções a seguir explicam o significado e o uso de caracteres especiais em expressões
       regulares.

       Arquivo: sed.info, Nó: BRE vs ERE, Avançar: Sintaxe BRE, Anterior: Visão geral de expressões regulares, Acima:
       expressões regulares sed

       5.2 Expressão regular básica (BRE) e estendida (ERE)
       ==================================================== ===


       Expressões regulares básicas e estendidas são duas variações na sintaxe do padrão especificado. A
       sintaxe de expressão regular básica (BRE) é o padrão em 'sed' (e similarmente em 'grep'). Use a
       opção '-E' especificada pelo POSIX ('-r', '--regexp-extended') para habilitar a sintaxe Extended
       Regular Expression (ERE).


              No GNU 'sed', a única diferença entre regular básico e estendido
       expressões está no comportamento de alguns caracteres especiais: '?', '+', parênteses, colchetes
       ('{}') e '|'.

           Com a sintaxe básica (BRE), esses caracteres não têm significado especial, a menos que sejam
       prefixados com uma barra invertida ('\'); Enquanto na sintaxe estendida (ERE), isso é inverso: esses
       caracteres são especiais, a menos que sejam prefixados com barra invertida ('\').


       padrão desejado               Sintaxe Básica (BRE)                  Sintaxe Estendida (ERE)





        -------------------------------------------------- ------------------------




        literal '+' (sinal de mais)                                                   $ echo 'a+b=c' > foo $ sed -n '/        $ echo 'a+b=c' > foo $ sed -E -n
                                                                                      a+b/p' foo a+b=c                        '/a\+b/p' foo a+b=c


       Um ou mais caracteres                                                          $ echo aab > foo $ sed -n               $ echo aab > foo $ sed -E
       'a' seguidos por                                                               '/a\+b/p' foo aab                       -n '/a+b/p' foo aab
       'b' (sinal de mais como
        metacaractere
       especial)



        Arquivo: sed.info, Nó: sintaxe BRE, Próximo: sintaxe ERE, Anterior: BRE vs ERE, Acima: expressões regulares sed



       5.3 Visão geral da sintaxe básica de expressões regulares
       =================================================

       Aqui está uma breve descrição da sintaxe de expressão regular usada em 'sed'.


        'CARACTERES'

                                           Um único caractere comum corresponde a si mesmo.

        '*'

                                            Corresponde a uma sequência de zero ou mais instâncias de correspondências para a expressão regular
                                            anterior, que deve ser um caractere comum, um caractere especial precedido por '\', um '.', um regexp
                                            agrupado (veja abaixo) ou uma expressão de colchetes. Como uma extensão GNU, uma expressão regular
                                            pós-fixada também pode ser seguida por '*'; por exemplo, 'a**' é equivalente a 'a*'. O POSIX 1003.1-2001
                                            diz que '*' representa a si mesmo quando aparece no início de uma expressão regular ou subexpressão, mas
                                            muitas implementações não-GNU não suportam isso e os scripts portáteis devem usar '\*' nesses contextos.




        '.'
                                            Corresponde a qualquer caractere, incluindo nova linha.
        '^'
                                           Corresponde à string nula no início do espaço do padrão, ou seja, o que aparece após o acento
                                           circunflexo deve aparecer no início do espaço do padrão.



                                            Na maioria dos scripts, o espaço padrão é inicializado com o conteúdo de cada linha (*observe como
                                            'sed' funciona: Ciclo de execução.). Portanto, é uma simplificação útil pensar em '^#include' como
                                            correspondência apenas de linhas em que '#include' é a primeira coisa na linha — se houver algum
                                            espaço anterior, por exemplo, a correspondência falhará. Esta simplificação é válida desde que o conteúdo
                                            original do espaço padrão não seja modificado, por exemplo, com um comando 's'.




                                             '^' atua como um caractere especial apenas no início da expressão regular ou subexpressão (ou
                                            seja, após '\(' ou '\|').
                                            Os scripts portáteis devem evitar '^' no início de uma subexpressão, pois o POSIX permite
                                            implementações que tratam '^' como um caractere comum nesse contexto.



        '$'
                                            É o mesmo que '^', mas refere-se ao fim do espaço padrão. '$' também atua como um caractere especial
                                            apenas no final da expressão regular ou subexpressão (ou seja, antes de '\)' ou '\|'), e seu uso no final de
                                            uma subexpressão não é portátil.



        '[LISTA]'




        '[^LIST]'
                     Corresponde a qualquer caractere único em LIST: por exemplo, '[aeiou]' corresponde a todas as vogais.
                     Uma lista pode incluir sequências como 'CHAR1-CHAR2', que corresponde a qualquer
                     caractere entre (inclusive)
                     CAR1 e CAR2. *Observação Classes de caracteres e expressões de colchetes::.



        '\+'
                     Como '*', mas corresponde a um ou mais. É uma extensão GNU.

        '\?'
                     Como '*', mas corresponde apenas a zero ou um. É uma extensão GNU.

        '\{I\}' Como
                  '*', mas corresponde exatamente a I sequências (I é um inteiro decimal; para portabilidade, mantenha-o entre 0
                  e 255 inclusive).

        '\{I,J\}'
                    Corresponde entre sequências I e J, inclusive.

        '\{I,\}'
                   Corresponde a sequências maiores ou iguais a I.

        '\(REGEXP\)'
               Agrupa o REGEXP interno como um todo, é usado para:

                           • Aplique operadores pós-fixados, como '\(abcd\)*': isso pesquisará por zero ou mais sequências inteiras
                              de 'abcd', enquanto 'abcd*' pesquisará por 'abc' seguido por zero ou mais ocorrências de 'd' .
                              Observe que o suporte para '\(abcd\)*' é exigido pelo POSIX 1003.1-2001, mas muitas implementações não-
                               GNU não o suportam e, portanto, não é portátil universalmente.




                           • Use referências anteriores (veja abaixo).

        'REGEXP1\|REGEXP2'
              Corresponde a REGEXP1 ou REGEXP2. Use parênteses para usar expressões regulares alternativas complexas.
              O processo de correspondência tenta cada alternativa por vez, da esquerda para a direita, e a primeira que tiver
              sucesso é usada. É uma extensão GNU.



        'REGEXP1REGEXP2'
                     Corresponde à concatenação de REGEXP1 e REGEXP2. A concatenação é vinculada com mais firmeza do que
                      '\|', '^' e '$', mas com menos força do que os outros operadores de expressão regular.



        '\Digito'
                     Corresponde à subexpressão DIGIT-th '\(...\)' entre parênteses na expressão regular. Isso é chamado de “referência
                     anterior”.
                     As subexpressões são numeradas implicitamente contando as ocorrências de '\(' da esquerda para a direita.



        '\n'
                     Corresponde ao caractere de nova linha.

        '\CHAR'
                     Corresponde a CHAR, onde CHAR é um de '$', '*', '.', '[', '\' ou '^'.
                     Observe que as únicas sequências de barra invertida semelhantes a C que você pode assumir de forma portátil para
                     serem interpretadas são '\n' e '\\'; em particular, '\t' não é portátil e corresponde a um 't' na maioria das
                     implementações de 'sed', em vez de um caractere de tabulação.



                   Observe que o correspondente de expressão regular é ganancioso, ou seja, as correspondências são
       tentou da esquerda para a direita e, se duas ou mais correspondências forem possíveis




       começando no mesmo caractere, ele seleciona o mais longo.

       Exemplos:
       'abcdef'
                Corresponde a 'abcdef'.

        'a*b'
                   Corresponde a zero ou mais 'a's seguidos por um único 'b'. Por exemplo, 'b' ou 'aaaaab'.



        'a\?b'
                   Corresponde a 'b' ou 'ab'.

        'a\+b\+'
                      Corresponde a um ou mais 'a's seguidos por um ou mais 'b's: 'ab' é a correspondência mais curta possível, mas
                      outros exemplos são 'aaaab' ou 'abbbbb' ou 'aaaaaabbbbbbb'.



        '.*' '.\
        +'
            Ambos correspondem a todos os caracteres em uma string; no entanto, o primeiro corresponde a cada string (incluindo
                a string vazia), enquanto o segundo corresponde apenas a strings contendo pelo menos um caractere.



        '^principal.*(.*)'
                 Isso corresponde a uma string começando com 'main', seguida por um parêntese de abertura e fechamento. O 'n',
                 '(' e ')' não precisam ser adjacentes.



        '^#'
                      Isso corresponde a uma string começando com '#'.

        '\\$'
                Isso corresponde a uma string que termina com uma única barra invertida. O regexp contém duas barras invertidas
                    para escape.

        '\$'
                      Em vez disso, corresponde a uma string que consiste em um único cifrão, porque é escapado.



        '[a-zA-Z0-9]'
                 Na localidade C, corresponde a quaisquer letras ou dígitos ASCII.

        '[^ '<TAB>']\+'
                 (Aqui '<TAB>' representa um único caractere de tabulação.) Isso corresponde a uma string de um ou mais
                 caracteres, nenhum dos quais é um espaço ou uma tabulação. Normalmente, isso significa uma palavra.



        '^\(.*\)\n\1$'
                   Isso corresponde a uma string que consiste em duas substrings iguais separadas por uma nova linha.



        '.\{9\}A$' Isso
                  corresponde a nove caracteres seguidos por um 'A' no final de uma linha.



        '^.\{15\}A' Isso
                  corresponde ao início de uma string que contém 16 caracteres, o último dos quais é um 'A'.



       Arquivo: sed.info, Nó: sintaxe ERE, Avançar: Classes de caracteres e expressões de colchetes, Anterior: sintaxe BRE,
       Acima: expressões regulares sed

       5.4 Visão geral da sintaxe de expressão regular estendida




       ====================================================

       A única diferença entre expressões regulares básicas e estendidas está no comportamento de
       alguns caracteres: '?', '+', parênteses, colchetes ('{}') e '|'. Embora as expressões regulares básicas
       exijam que elas sejam escapadas se você quiser que elas se comportem como caracteres especiais,
       ao usar expressões regulares estendidas, você deve escapá-las se quiser que
       _correspondam a um caractere literal_. '|' é especial aqui porque '\|' é uma extensão GNU –
       expressões regulares básicas padrão não fornecem sua funcionalidade.


       Exemplos:
       'abc?'
              torna-se 'abc\?' ao usar expressões regulares estendidas. Corresponde à string
              literal 'abc?'.

        'c\+'
                 torna-se 'c+' ao usar expressões regulares estendidas. Corresponde a um ou mais 'c's.


        'a\{3,\}'
                 torna-se 'a{3,}' ao usar expressões regulares estendidas. Corresponde a três ou
                 mais 'a's.

        '\(abc\)\{2,3\}' torna-
                se '(abc){2,3}' ao usar expressões regulares estendidas. Corresponde a 'abcabc' ou
                'abcabcabc'.

        '\(abc*\)\1' torna-
                se '(abc*)\1' ao usar expressões regulares estendidas.
                Referências inversas ainda devem ter escape ao usar expressões regulares estendidas.


        'a\|b'
                 torna-se 'a|b' ao usar expressões regulares estendidas. Corresponde a 'a' ou 'b'.


       Arquivo: sed.info, Nó: Classes de caracteres e expressões de colchetes, Próximo: extensões regexp, Anterior:
       sintaxe ERE, Acima: expressões regulares sed

       5.5 Classes de caracteres e expressões de colchetes
       =============================================

       Uma “expressão entre colchetes” é uma lista de caracteres entre '[' e ']'.
       Ele corresponde a qualquer caractere único nessa lista; se o primeiro caractere da lista for o
       circunflexo '^', ele corresponde a qualquer caractere *não* na lista. Por exemplo, o seguinte
       comando substitui as strings 'gray' ou 'grey' por 'blue':


                   sed 's/gr[ae]y/azul/'

            As expressões entre colchetes podem ser usadas em ambas *nota básica: sintaxe BRE. e
       *nota estendida: sintaxe ERE. expressões regulares (isto é, com ou sem as opções '-E'/'-
       r').

           Dentro de uma expressão de colchetes, uma “expressão de intervalo” consiste em dois
       caracteres separados por um hífen. Ele corresponde a qualquer caractere único classificado entre
       os dois caracteres, inclusive. Na localidade C padrão, a sequência de classificação é a ordem
       dos caracteres nativos; por exemplo, '[ad]' é equivalente a '[abcd]'.


           Finalmente, certas classes nomeadas de caracteres são predefinidas dentro
       expressões de colchetes, como segue.

             Essas classes nomeadas devem ser usadas _dentro_ de colchetes.




       Uso correto: $ echo
              1 | sed 's/[[:digit:]]/X/'
              x

            O uso incorreto é rejeitado pelas versões 'sed' mais recentes. versões mais antigas
       aceitou, mas tratou como uma expressão de colchete único (que é equivalente a '[dgit:]', ou seja, apenas
       os caracteres D/G/I/T/:): # versões atuais do sed GNU - uso incorreto rejeitado $ echo 1 | sed 's/
               [:digit:]/X/' sed: a sintaxe da classe de caracteres é [[:espaço:]], não [:espaço:]




                # versões GNU sed mais antigas $
                echo 1 | sed 's/[:digit:]/X/' 1


        '[:alnum:]'
                Caracteres alfanuméricos: '[:alpha:]' e '[:digit:]'; na localidade 'C' e na codificação de caracteres
                ASCII, é o mesmo que '[0-9A-Za-z]'.


        '[:alpha:]'
                Caracteres alfabéticos: '[:inferior:]' e '[:superior:]'; na localidade 'C' e na codificação de caracteres
                 ASCII, é o mesmo que '[A-Za-z]'.


        '[:blank:]'
                 Caracteres em branco: espaço e tabulação.

        '[:cntrl:]'
                   Caracteres de controle. Em ASCII, esses caracteres possuem códigos octais de 000 a 037 e 177
                   (DEL). Em outros conjuntos de caracteres, esses são os caracteres equivalentes, se houver.


        '[:digit:]' Dígitos:
                   '0 1 2 3 4 5 6 7 8 9'.

        '[:graph:]'
                Caracteres gráficos: '[:alnum:]' e '[:punct:]'.

        '[:lower:]' Letras
                 minúsculas; na localidade 'C' e na codificação de caracteres ASCII, é 'abcdefghijklmnopqrstu vwxy z'.


        '[:print:]'
                  Caracteres imprimíveis: '[:alnum:]', '[:punct:]' e espaço.

        '[:punct:]'
                Caracteres de pontuação; na localidade 'C' e na codificação de caracteres ASCII, é '! " # $ %
                & ' ( ) * . / : ] ^ ` { | } ~'.                             + , -             ;<=>?@[\
                        _

        '[:space:]'
                Caracteres de espaço: na localidade 'C', são tabulação, nova linha, tabulação vertical, alimentação de
                formulário, retorno de carro e espaço.

        '[:upper:]' Letras
                maiúsculas: na localidade 'C' e na codificação de caracteres ASCII, é 'ABCDEFGHIJKLMNOPQRSTU
                VWXY Z'.

        '[:xdigit:]' Dígitos
                  hexadecimais: '0 1 2 3 4 5 6 7 8 9 ABCDEF abcde f'.

            Observe que os colchetes nesses nomes de classe fazem parte dos nomes simbólicos e devem ser
       incluídos além dos colchetes que delimitam o




       expressão de colchetes.

           A maioria dos metacaracteres perde seu significado especial dentro das expressões
       de colchetes:

        ']'
                 termina a expressão de colchetes se não for o primeiro item da lista. Portanto, se você
                 deseja tornar o caractere ']' um item de lista, deve colocá-lo primeiro.


        '-'
                 representa o intervalo se não for o primeiro ou o último em uma lista ou o ponto final
                 de um intervalo.
        '^'
                 representa os caracteres que não estão na lista. Se você quiser tornar o caractere '^' um
                 item de lista, coloque-o em qualquer lugar, menos no primeiro.

               TODO: incorporar este parágrafo (copiado textualmente da seção BRE).

            Os caracteres '$', '*', '.', '[' e '\' normalmente não são especiais em LIST. Por exemplo, '[\*]'
       corresponde a '\' ou '*', porque o '\' não é especial aqui. No entanto, strings como '[.ch.]', '[=a=]' e
       '[:space:]' são especiais em LIST e representam símbolos de agrupamento, classes de equivalência
       e classes de caracteres, respectivamente, e '[' é, portanto, especial em LIST quando é seguido
       por '.', '=' ou ':'.

       Além disso, quando não está no modo 'POSIXLY_CORRECT', escapes especiais como '\n' e '\t'
       são reconhecidos em LIST. *Nota Escapes::.

        '[.'
                 representa o símbolo de agrupamento aberto.

        '.]'
                 representa o símbolo de agrupamento fechado.

        '[='
                 representa a classe de equivalência aberta.

        '=]'
                 representa a classe de equivalência próxima.

        '[:'
                 representa o símbolo de classe de caractere aberto e deve ser seguido por um nome de
                 classe de caractere válido.

        ':]'
                 representa o símbolo de classe de caractere próximo.

       Arquivo: sed.info, Nó: extensões regexp, Próximo: Referências anteriores e subexpressões,
       Anterior: Classes de caracteres e expressões de colchetes, Acima: expressões regulares sed


       5.6 extensões de expressões regulares
       =================================

       As sequências a seguir têm um significado especial dentro das expressões regulares (usadas em
       *endereços de notas: Endereços Regexp. e o comando 's').

            Estes podem ser usados em ambas as sintaxes *note basic: BRE. e *nota estendida:
       sintaxe ERE. expressões regulares (ou seja, com ou sem as opções '-E'/'-r').


        '\c'
                 Corresponde a qualquer caractere de “palavra”. Um caractere de “palavra” é qualquer letra ou




               dígito ou o caractere de sublinhado.

                       $ echo "abc %-= def." | sed 's/\w/X/g'
                       XXX %-= XXX.

        '\C'
               Corresponde a qualquer caractere "não-palavra".

                       $ echo "abc %-= def." | sed 's/\W/X/g' abcXXXXXdefX


        '\b'
               Corresponde a um limite de palavra; ou seja, corresponde se o caractere à esquerda for um
               caractere “palavra” e o caractere à direita for um caractere “não-palavra”, ou vice-versa.


                       $ echo "abc %-= def." | sed 's/\b/X/g'
                       XabcX %-= XdefX.

        '\B'
               Corresponde em todos os lugares, exceto em um limite de palavra; isto é, corresponde se o
               caractere à esquerda e o caractere à direita forem ambos caracteres de “palavra” ou ambos
               caracteres de “não-palavra”.

                       $ echo "abc %-= def." | sed 's/\B/X/g' aXbXc X%XX=X
                       dXeXf.X

        '\s'
               Corresponde a caracteres de espaço em branco (espaços e tabulações). As novas linhas
               incorporadas nos espaços padrão/manter também corresponderão:

                       $ echo "abc %-= def." | sed 's/\s/X/g' abcX%-=Xdef.


        '\S'
               Corresponde a caracteres que não são espaços em branco.

                       $ echo "abc %-= def." | sed 's/\S/X/g'
                       XXX XXX XXXX

        '\<'
               Corresponde ao início de uma palavra.

                       $ echo "abc %-= def." | sed 's/\</X/g'
                       Xabc %-= Xdef.

        '\>'
               Corresponde ao final de uma palavra.


                       $ echo "abc %-= def." | sed 's/\>/X/g' abcX %-= defX.


        '\`'
               Corresponde apenas ao início do espaço do padrão. Isso é diferente de '^' no modo multilinha.


               Compare os dois exemplos a seguir:

                       $ printf "a\nb\nc\n" | sed 'N;N;s/^/X/gm'
                       Xa
                       Xb
                       Xc

                       $ printf "a\nb\nc\n" | sed 'N;N;s/\`/X/gm'




                         Xa
                         b
                         c

        '\''
                 Corresponde apenas ao final do espaço do padrão. Isso é diferente de '$' no modo multilinha.


       Arquivo: sed.info, Nó: referências anteriores e subexpressões, Próximo: Escapes, Anterior: extensões regexp, Acima:
       expressões regulares sed

       5.7 Referências inversas e subexpressões
       ========================================

       “back-references” são comandos de expressão regular que se referem a uma parte anterior da expressão
       regular correspondente. As referências anteriores são especificadas com barra invertida e um único dígito
       (por exemplo, '\1'). A parte da expressão regular à qual eles se referem é chamada de “subexpressão” e é
       designada entre parênteses.


            Referências inversas e subexpressões são usadas em dois casos: no padrão de pesquisa de
        expressão regular e na parte REPLACEMENT do comando 's' (*nota Endereços de expressão regular:
        Endereços Regexp. e *nota O comando "s"::) .


               Em um padrão de expressão regular, as referências inversas são usadas para corresponder
       o mesmo conteúdo de uma subexpressão correspondente anteriormente. No exemplo a seguir, a
       subexpressão é '.' - qualquer caractere único (estar entre parênteses o torna uma subexpressão). A
       referência anterior '\1' pede para corresponder ao mesmo conteúdo (mesmo caractere) da
       subexpressão.


            O comando abaixo corresponde a palavras que começam com qualquer caractere, seguido
       pela letra 'o', seguida do mesmo caractere do primeiro.

                 $ sed -E -n '/^(.)o\1$/p' /usr/share/dict/words bob

                 mãe
                 não
                 pop
                 sos
                 tot
                 uau

            Várias subexpressões são numeradas automaticamente da esquerda para a direita.
       Este comando procura palíndromos de 6 letras (as três primeiras letras são 3 subexpressões, seguidas
       por 3 referências inversas na ordem inversa):


                 $ sed -E -n '/^(.)(.)(.)\3\2\1$/p' /usr/share/dict/words redder


            No comando 's', as referências inversas podem ser usadas no REPLACEMENT
       parte para se referir a subexpressões na parte REGEXP.

           O exemplo a seguir usa duas subexpressões na expressão regular para corresponder a duas
       palavras separadas por espaços. As referências inversas na parte REPLACEMENT imprimem as palavras em
       uma ordem diferente:

                 $ echo "James Bond" | sed -E 's/(.*) (.*)/O nome é \2, \1 \2./'
                 O nome é Bond, James Bond.

           Quando usado com alternância, se o grupo não participar da partida, a referência inversa fará com que toda
       a partida falhe. Por exemplo,




       'a(.)|b\1' não corresponderá a 'ba'. Quando várias expressões regulares são fornecidas com '-e' ou de um arquivo ('-f
       FILE'), as referências inversas são locais para cada expressão.



        Arquivo: sed.info, Nó: Escapes, Próximo: Considerações de localidade, Anterior: Referências anteriores e subexpressões,
        Acima: expressões regulares sed

       5.8 Sequências de escape - especificando caracteres especiais
       ==================================================== ==


       Até este capítulo, encontramos apenas escapes da forma '\^', que dizem a 'sed' para não interpretar o acento circunflexo
       como um caractere especial, mas sim interpretá-lo literalmente. Por exemplo, '\*' corresponde a um único asterisco em vez
       de zero ou mais barras invertidas.



              Este capítulo apresenta outro tipo de escape(1) - ou seja, escapes
       que são aplicados a um caractere ou sequência de caracteres que normalmente são considerados
       literalmente e que 'sed' substitui por um caractere especial. Isso fornece uma maneira de codificar caracteres não
       imprimíveis em padrões de maneira visível. Não há restrição quanto à aparência de caracteres não imprimíveis em um
       script 'sed', mas quando um script está sendo preparado no shell ou por edição de texto, geralmente é mais fácil usar uma
       das seguintes sequências de escape do que o caractere binário representa:




                A lista dessas fugas é:

        '\a'
                   Produz ou corresponde a um caractere BEL, que é um “alerta” (ASCII 7).

        '\f'
                   Produz ou corresponde a um feed de formulário (ASCII 12).

        '\n'
                   Produz ou corresponde a uma nova linha (ASCII 10).

        '\r'
                   Produz ou corresponde a um retorno de linha (ASCII 13).

        '\t'
                   Produz ou corresponde a uma tabulação horizontal (ASCII 9).

        '\v'
                   Produz ou corresponde a uma chamada “guia vertical” (ASCII 11).

        '\cX'
                Produz ou corresponde a 'CONTROL-X', onde X é qualquer caractere. O efeito preciso de '\cX' é o seguinte: se
                   X for uma letra minúscula, ela será convertida para maiúscula. Em seguida, o bit 6 do caractere (hex 40) é invertido.
                   Assim '\cz' torna-se hex 1A, mas '\c{' torna-se hex 3B, enquanto '\c;' torna-se hexadecimal 7B.




        '\dXXX'
                   Produz ou corresponde a um caractere cujo valor ASCII decimal é XXX.

        '\oXXX'
                   Produz ou corresponde a um caractere cujo valor octal ASCII é XXX.

        '\xXX'
                 Produz ou corresponde a um caractere cujo valor ASCII hexadecimal é XX.



                '\b' (backspace) foi omitido por causa do conflito com o significado existente de “limite da palavra”.





       5.8.1 Precedência de escape
       -------------------------


       GNU 'sed' processa sequências de escape _antes_ de passar o texto para a correspondência de expressão
       regular do comando 's///' e correspondência de endereço.
       Assim, os dois comandos a seguir são equivalentes ('0x5e' é o valor ASCII hexadecimal do
       caractere '^'):

               $ eco 'a^c' | sed 's/^/b/' ba^c


               $ eco 'a^c' | sed 's/\x5e/b/' ba^c


            Assim como os seguintes ('0x5b','0x5d' são os valores ASCII hexadecimais de '[',']', respectivamente):


               $ eco abc | sed 's/[a]/x/'
               Xbc
               $ eco abc | sed 's/\x5ba\x5d/x/'
               Xbc

            No entanto, é recomendável evitar esses caracteres especiais devido a casos extremos inesperados.
        Por exemplo, os seguintes não são equivalentes:

               $ eco 'a^c' | sed 's/\^/b/' abc


               $ eco 'a^c' | sed 's/\\\x5e/b/' a^c


            ---------- Notas de rodapé ----------


           (1) Todos os escapes introduzidos aqui são extensões GNU, com o
       exceção de '\n'. No modo básico de expressão regular, definir 'POSIXLY_CORRECT' os
       desabilita dentro das expressões de colchetes.

        Arquivo: sed.info, Nó: Considerações de localidade, Anterior: Escapes, Acima: expressões regulares sed


       5.9 Caracteres multibyte e considerações de localidade
       ====================================================

       GNU 'sed' processa caracteres multibyte válidos em localidades multibyte (por exemplo, 'UTF-8'). (1)


       O exemplo a seguir usa a letra grega Maiúscula Sigma (ÿ, ponto de código Unicode '0x03A3'). Em uma
       localidade 'UTF-8', 'sed' processa corretamente o Sigma como um caractere, apesar de ter 2 octetos (bytes):


               $ localidade | grep LANG
               LANG=en_US.UTF-8

               $ printf 'a\u03A3b' aÿb


               $ printf 'a\u03A3b' | sed 's/./X/g'
               XXX

               $ printf 'a\u03A3b' | od -tx1 -An 61 ce a3 62


       Para forçar 'sed' a processar octetos separadamente, use a localidade 'C' (também




        conhecido como localidade 'POSIX'):

               $ printf 'a\u03A3b' | LC_ALL=C sed 's/./X/g'
               XXXX

       5.9.1 Caracteres multibyte inválidos
       ----------------------------------


       As expressões regulares de 'sed' _não_ correspondem a sequências multibyte inválidas em uma localidade
       multibyte.

       Nos exemplos a seguir, o valor ascii '0xCE' é um caractere multibyte incompleto (mostrado aqui como
       não correspondente:                                   ÿ ). A expressão regular '.' faz


               $ printf 'a\xCEb\n' ae ÿ


               $ printf 'a\xCEb\n' | sed 's/./X/g'
               XX ÿ

               $ printf 'a\xCEc\n' | sed 's/./X/g' | od -tx1c -An 58 ce 58 0a X \n

                    x

       Da mesma forma, a expressão regular 'pega-tudo' '.*' não corresponde à linha inteira:


               $ printf 'a\xCEc\n' | sed 's/.*//' | od -tx1c -An ce 63 0a c \n




       GNU 'sed' oferece o comando especial 'z' para limpar o espaço padrão atual, independentemente de
       caracteres multibyte inválidos (ou seja, funciona como 's/.*//', mas também remove caracteres multibyte
       inválidos):

               $ printf 'a\xCEc\n' | sed 'z' | od -tx1c -An
                    0a
                    \n

       Como alternativa, force a localidade 'C' a processar cada octeto separadamente (cada octeto é um
       caractere válido na localidade 'C'):

               $ printf 'a\xCEc\n' | LC_ALL=C sed 's/.*//' | od -tx1c -An
                   0a
                   \n

             a incapacidade de 'sed' de processar caracteres multibyte inválidos pode ser usada
        para detectar essas sequências inválidas em um arquivo. Nos exemplos a seguir, '\xCE\xCE' é uma sequência
        multibyte inválida, enquanto '\xCE\A3' é uma sequência multibyte válida (do caractere sigma grego).


       O seguinte programa 'sed' remove todos os caracteres válidos usando 's/.//g'.
       Qualquer conteúdo deixado no espaço padrão (os caracteres inválidos) é adicionado ao espaço de espera
       usando o comando 'H'. Na última linha ('$'), o espaço de retenção é recuperado ('x'), as novas linhas são
       removidas ('s/\n//g') e quaisquer octetos restantes são impressos sem ambiguidade ('l'). Assim, quaisquer
       sequências multibyte inválidas são impressas como valores octais:


               $ printf 'ab\nc\n\xCE\xCEde\n\xCE\xA3f\n' > invalid.txt

               $ cat invalid.txt ab

               c




                  de ÿÿ ÿf


                 $ sed -n 's/.//g ; H ; ${x;s/\n//g;l}' inválido.txt \316\316$


       Com mais alguns comandos, 'sed' pode imprimir o número exato da linha correspondente a cada
       caractere inválido (linha 3). Esses caracteres podem ser removidos forçando a localidade 'C' e usando
       sequências de escape octal:


                 $ sed -n 's/.//g;=;l' inválido.txt | colar - - 3 \316\316$              | awk '$2!="$"'


                 $ LC_ALL=C sed '3s/\o316\o316//' invalid.txt > fixed.txt

       5.9.2 Conversão de maiúsculas/minúsculas
        ----------------------------------


       O comando substituto GNU 'sed' ('s') suporta conversões de maiúsculas/minúsculas usando
       códigos '\U','\L'. Essas conversões suportam caracteres multibyte:


                 $ printf 'ABC\u03a3\n'
                 ABCÿ


                 $ printf 'ABC\u03a3\n' | sed 's/.*/\L&/' abcÿ


        *Observe o comando "s"::.

       5.9.3 Classes de caracteres regexp multibyte
       ----------------------------------------


       Em outras localidades, a sequência de classificação não é especificada e '[ad]' pode ser equivalente a
       '[abcd]' ou a '[aBbCcDd]', ou pode não corresponder a nenhum caractere ou ao conjunto de caracteres que
       ele correspondências podem até ser erráticas. Para obter a interpretação tradicional de expressões de colchetes,
       você pode usar a localidade 'C' definindo a variável de ambiente 'LC_ALL' com o valor 'C'.




                 # TODO: existe algum sistema/localidade do mundo real onde 'A' #
                                 é substituído por '-' ? $ eco A |
                 sed 's/[az]/-/'
                 A

            Sua interpretação depende da localidade 'LC_CTYPE'; por exemplo, '[[:alnum:]]' significa a classe de
        caracteres de números e letras na localidade atual.


             TODO: mostra exemplo de collation

                 # TODO: funciona em sistemas glibc, não em musl-libc/freebsd/macosx. $ printf 'clichê\n' | LC_ALL=fr_FR.utf8
                 sed 's/[[=e=]]/X/g' clichX


              ---------- Notas de rodapé ----------


            (1) Alguns casos extremos de regexp dependem do sistema operacional e da libc
       implementação. Os exemplos mostrados funcionam como esperado em sistemas GNU/Linux usando glibc.


        Arquivo: sed.info, Nó: sed avançado, Avançar: Exemplos, Anterior: expressões regulares sed, Acima: Início





       6 'sed' avançado: ciclos e buffers
       ************************

        *   Cardápio:


        * Ciclo de Execução::                            Como funciona o 'sed'
        * Buffers de espera e padrão::
        * Técnicas multilinha::                          Usando D,G,H,N,P para processar várias linhas
        * Ramificação e controle de fluxo::

        Arquivo: sed.info, Nó: Ciclo de Execução, Próximo: Espera e Buffers Padrão, Acima: sed avançado



       6.1 Como funciona o 'sed'
       ===================


       'sed' mantém dois buffers de dados: o espaço _pattern_ ativo e o espaço _hold_ auxiliar. Ambos estão inicialmente
       vazios.

            'sed' opera executando o seguinte ciclo em cada linha de entrada: primeiro, 'sed' lê uma linha do fluxo de
       entrada, remove qualquer nova linha à direita e a coloca no espaço padrão. Então os comandos são executados;
       cada comando pode ter um endereço associado a ele: os endereços são uma espécie de código de condição, e um
       comando só é executado se a condição for verificada antes de o comando ser executado.




           Quando o final do script é alcançado, a menos que a opção '-n' esteja em uso, o conteúdo do espaço padrão é
       impresso no fluxo de saída, adicionando de volta a nova linha à direita se ela foi removida.(1) Em seguida, o próximo ciclo
       começa para a próxima linha de entrada.



            A menos que comandos especiais (como 'D') sejam usados, o espaço do padrão é excluído entre dois ciclos.
       O espaço de retenção, por outro lado, mantém seus dados entre os ciclos (consulte os comandos 'h', 'H', 'x', 'g', 'G'
       para mover os dados entre os dois buffers).



              ---------- Notas de rodapé ----------


            (1) Na verdade, se 'sed' imprime uma linha sem a nova linha final,
       no entanto, ele imprimirá a nova linha ausente assim que mais texto for enviado para o mesmo fluxo de saída, o que dá
       a “menor surpresa esperada”, embora não torne comandos como 'sed -n p' exatamente idênticos a 'cat'.




        Arquivo: sed.info, Node: Hold e Pattern Buffers, Next: Técnicas multilinha, Anterior: Ciclo de Execução, Acima: sed avançado



       6.2 Buffers de espera e padrão
       ============================


       PENDÊNCIA




       Arquivo: sed.info, Nó: Técnicas multilinha, Avançar: Ramificação e controle de fluxo, Anterior: Espera e buffers padrão, Acima: sed
       avançado

       6.3 Técnicas multilinha - usando D,G,H,N,P para processar múltiplas linhas
       ==================================================== ==================


       Múltiplas linhas podem ser processadas como um buffer usando 'D','G','H','N','P'. Eles são
       semelhantes às suas contrapartes minúsculas ('d','g', 'h','n','p'), exceto que esses comandos acrescentam ou subtraem
       dados respeitando as novas linhas incorporadas - permitindo adicionar e remover linhas do padrão e mantenha os
       espaços.





               Eles funcionam da seguinte forma:
        'D'
                  _exclui_ linha do espaço do padrão até a primeira nova linha e reinicia o ciclo.


        'G'
                  _acrescenta_ linha do espaço de retenção ao espaço padrão, com uma nova linha antes dela.


        'H'
                  _acrescenta_ linha do espaço padrão para o espaço de retenção, com uma nova linha antes dela.


        'N'
                  linha _appends_ do arquivo de entrada para o espaço padrão.

        'P'
                  _prints_ linha do espaço padrão até a primeira nova linha.

           O exemplo a seguir ilustra a operação de 'N' e 'D'
       comandos:


                  $ seq 6 | sed -n 'N;l;D' 1\n2$ 2\n3$
                  3\n4$
                  4\n5$
                  5\n6$




              1. 'sed' começa lendo a primeira linha no espaço padrão (ou seja
                     '1').
              2. No início de cada ciclo, o comando 'N' anexa uma nova linha e a próxima linha ao espaço padrão (ou seja, '1',
                    '\n', '2' no primeiro ciclo).

              3. O comando 'l' imprime o conteúdo do espaço padrão
                   inequivocamente.
              4. O comando 'D' então remove o conteúdo do espaço padrão até a primeira nova linha (deixando '2' no final do
                   primeiro ciclo).
              5. No próximo ciclo, o comando 'N' acrescenta uma nova linha e a próxima linha de entrada ao espaço padrão
                   (por exemplo, '2', '\n', '3').

            Uma técnica comum para processar blocos de texto, como parágrafos
        (em vez de linha por linha) está usando a seguinte construção:

                   sed '/./{H;$!d} ; x ; s/REGEXP/SUBSTITUIÇÃO/'

              1. A primeira expressão, '/./{H;$!d}' opera em todas as linhas não vazias e adiciona a linha atual (no espaço do
                   padrão) ao espaço de retenção.
                   Em todas as linhas, exceto na última, o espaço do padrão é excluído e o ciclo é reiniciado.



              2. As outras expressões 'x' e 's' são executadas apenas em linhas vazias (ou seja, separadores de parágrafo). O
                   comando 'x' traz as linhas acumuladas do espaço de espera de volta para o espaço do padrão.

                  O comando 's///' então opera em todo o texto do parágrafo (incluindo as novas linhas incorporadas).



               O exemplo a seguir demonstra essa técnica: $ cat input.txt aaa aa aaa


                   aaaa aaaa aa
                   aaa aaa aaa




                 bbbb bbb bbb bb bb
                 bb bb bb bb bb bb



                 cc cc cc cc
                 cccc cccc c
                 cc cc cc cc


                 $ sed '/./{H;$!d} ; x ; s/^/\nSTART-->/ ; s/$/\n<--END/' input.txt

                 INÍCIO-->
                 aaa aaa aaa
                 aaaa aaaa aa
                 aaa aaa aaa
                 <--END

                 INÍCIO-->
                 bbbb bbb bbb bb bb
                 bbb bb bbbbbbbb
                 bbb
                 <--END

                 INÍCIO-->
                 cc cc cc cc
                 cccc cccc c
                 cc cc cc cc
                 <--END


             Para exemplos mais anotados, *observe Pesquisa de texto em vários
        linhas:: e *nota Ajuste do comprimento da linha::.

        Arquivo: sed.info, Nó: Ramificação e controle de fluxo, Anterior: Técnicas multilinha, Acima: sed avançado



       6.4 Ramificação e Controle de Fluxo
       ==============================


       Os comandos de ramificação 'b', 't' e 'T' permitem alterar o fluxo de programas 'sed'.



            Por padrão, 'sed' lê uma linha de entrada no buffer padrão, então
       continua a processar todos os comandos em ordem. Comandos sem endereços afetam todas as linhas.
       Comandos com endereços afetam apenas as linhas correspondentes. *Observação Ciclo de Execução:: e
       *observação Visão geral de Endereços::.

            'sed' não suporta uma construção típica 'if/then'. Em vez disso, alguns
       os comandos podem ser usados como condicionais ou para alterar o controle de fluxo padrão:



        'd'
                 exclua (limpe) o espaço do padrão atual e reinicie o ciclo do programa sem processar o restante dos comandos e
                 sem imprimir o espaço do padrão.



        'D'
                 exclua o conteúdo do espaço padrão _até a primeira nova linha_ e reinicie o ciclo do programa sem processar o
                 restante dos comandos e sem imprimir o espaço padrão.



        '[addr]X' '[addr]
        { X ; X ; X }' '/regexp/X' '/regexp/
        { X ; X ; X }'

                 Endereços e expressões regulares podem ser usados como um 'se/então'




               condicional: Se [ADDR] corresponder ao espaço padrão atual, execute o(s) comando(s). Por exemplo:
               O comando '/^#/d' significa: _se_ o padrão atual corresponder à expressão regular '^#' (uma linha
               começando com um hash), _então_ execute o comando 'd': exclua a linha sem imprimi-la,
               e reinicie o ciclo do programa imediatamente.




        'b'
               ramificar incondicionalmente (ou seja: sempre pular para um rótulo, pular ou repetir outros comandos,
               sem reiniciar um novo ciclo).
               Combinado com um endereço, o desvio pode ser executado condicionalmente em linhas combinadas.


        't'
               ramificar condicionalmente (isto é: pular para um rótulo) _somente se_ um comando 's///' tiver sido
               bem-sucedido desde que a última linha de entrada foi lida ou outro desvio condicional foi feito.


        'T'
               semelhante, mas oposto ao comando 't': ramificar apenas se houver _nenhuma_ substituição bem-
               sucedida desde que a última linha de entrada foi lida.


            Os dois programas 'sed' a seguir são equivalentes. O primeiro exemplo (artificial) usa o
        comando 'b' para pular o comando 's///' nas linhas que contêm '1'. O segundo exemplo usa um endereço
        com negação ('!') para realizar a substituição apenas nas linhas desejadas. O comando 'y///' ainda é executado
        em todas as linhas:


               $ printf '%s\n' a1 a2 a3 | sed -E '/1/bx ; s/a/z/ ; : x ; y/123/456/'a4

               z5
               z6

               $ printf '%s\n' a1 a2 a3 | sed -E '/1/!s/a/z/ ; y/123/456/'a4

               z5
               z6

       6.4.1 Ramificações e Ciclos
       --------------------------


       Os comandos 'b','t' e 'T' podem ser seguidos por um rótulo (normalmente uma única letra). Os rótulos são
       definidos com dois pontos seguidos por uma ou mais letras (por exemplo, ':x'). Se o rótulo for omitido, os
       comandos de ramificação reiniciam o ciclo. Observe a diferença entre ramificar para um rótulo e
       reiniciar o ciclo: quando um ciclo é reiniciado, 'sed' primeiro imprime o conteúdo atual do espaço do padrão e,
       em seguida, lê a próxima linha de entrada no espaço do padrão; Saltar para uma etiqueta (mesmo que seja
       no início do programa) não imprime o espaço do padrão e não lê a próxima linha de entrada.




           O programa a seguir é um no-op. O comando 'b' (o único comando
       no programa) não tem rótulo, e assim simplesmente reinicia o ciclo. Em cada ciclo, o espaço do padrão
       é impresso e a próxima linha de entrada é lida:


               $ seq 3 | sed b 1

               2
               3

            O exemplo a seguir é um loop infinito - ele não termina e não imprime nada. O comando 'b' salta para o
       rótulo 'x' e um




       novo ciclo nunca é iniciado:

              $ seq 3 | sed':x ; bx'

              # O comando acima requer gnu sed (que suporta # comandos adicionais seguindo um rótulo, sem
              uma nova linha). Um equivalente portátil: # sed -e ':x' -e bx


            A ramificação geralmente é complementada com os comandos 'n' ou 'N': ambos os comandos leem a
       próxima linha de entrada no espaço padrão sem esperar que o ciclo reinicie. Antes de ler a próxima linha de
       entrada, 'n' imprime o espaço do padrão atual e o esvazia, enquanto 'N' anexa uma nova linha e a
       próxima linha de entrada ao espaço do padrão.


           Considere os dois exemplos a seguir:

              $ seq 3 | sed':x ; n ; bx' 1 2


              3

              $ seq 3 | sed':x ; N ; bx'1

              2
              3


           • Ambos os exemplos não inf-loop, apesar de nunca iniciar um novo ciclo.

           • No primeiro exemplo, os comandos 'n' primeiro imprimem o conteúdo do espaço do padrão, esvaziam o
              espaço do padrão e então lêem a próxima linha de entrada.


           • No segundo exemplo, os comandos 'N' anexam a próxima linha de entrada ao espaço padrão (com uma
              nova linha). As linhas são acumuladas no espaço padrão até que não haja mais linhas de entrada
              para ler, então o comando 'N' termina o programa 'sed'. Quando o programa termina, as ações de fim
              de ciclo são executadas e todo o espaço do padrão é impresso.




           • O segundo exemplo requer GNU 'sed', porque usa o
              comportamento não padrão POSIX de 'N'. Veja o parágrafo “'N' command on the last line” em *note
               Reporting Bugs::.

           • Para examinar melhor a diferença entre os dois exemplos, tente o
              seguintes comandos: printf
                     '%s\n' aa bb cc dd | sed':x ; n ; = ; bx' printf '%s\n' aa bb cc dd | sed':x ; N ;
                     = ; bx' printf '%s\n' aa bb cc dd | sed':x ; n ; s/\n/***/ ; bx' printf '%s\n' aa bb
                     cc dd | sed':x ; N ; s/\n/***/ ; bx'


       6.4.2 Exemplo de ramificação: junção de linhas
       --------------------------------------


       Como um exemplo do mundo real de uso de ramificação, considere o caso de arquivos citados para
       impressão (https://en.wikipedia.org/wiki/Quoted-printable), normalmente usados para codificar mensagens de e-
       mail. Nesses arquivos, linhas longas são divididas e marcadas com uma “quebra de linha suave” que consiste
       em um único caractere '=' no final da linha:


              $ cat jaques.txt Todo o
              mundo é um
               veado, E todo o =




                   homens e
                 mulheres =
                 homens
                 meramente =
                 jogadores: Eles
                 têm t = suas
                 saídas = e
                 suas entradas
                   =; E um
                 homem= em
                 seu tempo desempenha muitos papéis.

             O programa a seguir usa uma correspondência de endereço '/=$/' como condicional:
       Se o espaço padrão atual terminar com um '=', ele lê a próxima linha de entrada usando 'N', substitui
       todos os caracteres '=' que são seguidos por uma nova linha e desvia incondicionalmente ('b')
       para o início do programa sem reiniciar um novo ciclo. Se o espaço do padrão não terminar com
       '=', a ação padrão é executada: o espaço do padrão é impresso e um novo ciclo é iniciado:



                 $ sed ':x ; /=$/ { N ; s/=\n//g ; bx }' jaques.txt O mundo inteiro é um palco,
                 E todos os homens e mulheres
                 apenas jogadores: Têm suas saídas e suas entradas; E
                 um homem em seu tempo desempenha muitos papéis.


            Aqui está um programa alternativo com uma abordagem ligeiramente diferente: Em todas as
       linhas, exceto na última, 'N' anexa a linha ao espaço padrão. Um comando de substituição remove as
       quebras de linha suaves ('=' no final de uma linha, ou seja, seguido por uma nova linha) substituindo-
       as por uma string vazia. _if_ a substituição foi bem-sucedida (significando que o espaço padrão
       continha uma linha que deveria ser unida), o comando de ramificação condicional 't' pula para o início
       do programa sem concluir ou reiniciar o ciclo. Se a substituição falhou (o que significa que não houve
        quebras de linha suaves), o comando 't' _não_ ramificará. Em seguida, 'P' imprimirá o
       conteúdo do espaço padrão até a primeira nova linha e 'D' excluirá o conteúdo do espaço padrão até a
       primeira nova linha. (Para aprender mais sobre os comandos 'N', 'P' e 'D' *observe as técnicas
       Multiline::).



                 $ sed ':x ; $!N ; s/=\n// ; tx ; P ; D'jaques.txt O mundo inteiro é um palco,
                 E todos os homens e mulheres
                 apenas jogadores: Têm suas saídas e suas entradas; E
                 um homem em seu tempo desempenha muitos papéis.


              Para mais exemplos de junção de linha *observe Unindo linhas::.

        Arquivo: sed.info, Nó: Exemplos, Próximo: Limitações, Anterior: sed avançado, Acima: Topo


       7 Alguns Scripts de Amostra
       *********


       Aqui estão alguns scripts 'sed' para guiá-lo na arte de dominar o 'sed'.
        *   Cardápio:




       One-liners úteis:
       * Linhas de junção::

       Alguns exemplos exóticos:
       * Linhas de centralização::
       * Incrementar um número::




        * Renomeie os arquivos para letras minúsculas::
        * Imprimir ambiente bash::
        * Caracteres inversos das linhas::
        *
           Pesquisa de texto em várias linhas::
        * Ajuste do comprimento da linha::
        * Adicionando um cabeçalho a vários arquivos::

       Emulando utilitários padrão: tac:: cat -n::
       * cat -b::                                                   Linhas inversas de arquivos
       *
                                                                    Linhas de numeração
       *
                                                                    Numeração de linhas não em branco
       * wc-c::
                                                                    Contando caracteres
       * wc -w::
                                                                    Contando palavras
       * wc -l:: *
                                                                    Contando linhas
        cabeça:: *                                                  Imprimindo as primeiras linhas
        cauda:: *                                                   Imprimindo as últimas linhas
        uniq:: *                                                    Tornar as linhas duplicadas únicas
        uniq -d:: * uniq                                            Imprimir linhas duplicadas de entrada
        -u:: gato -s::                                              Remova todas as linhas duplicadas
        *
                                                                    Espremendo linhas em branco

        Arquivo: sed.info, Nó: Unindo linhas, Próximo: Centrando linhas, Acima: Exemplos

       7.1 Unindo linhas
       ===================

       Esta seção usa os comandos 'N', 'D' e 'P' para processar várias linhas e os comandos 'b' e 't' para
       ramificação. *Observação Técnicas multilinha:: e *Observação Ramificação e controle de
       fluxo::.

            Junte linhas específicas (por exemplo, se as linhas 2 e 3 precisam ser unidas):

                $ cat lines.txt olá olá
                olá olá




                $ sed '2{N;s/\n//;}' linhas.txt olá olá olá




            Junte-se a linhas contínuas de barra invertida:

                $ cat 1.txt este \
                é \ uma
                \

                longa \
                linha
                e outra \ linha



                $ sed -e ':x /\\$/ { N; s/\\\n//g ; bx }' 1.txt esta é uma linha longa e outra
                linha




                #TODO: O acima requer gnu sed. #
                        seds não-gnu precisam de novas linhas após ':' e 'b'

            Junte linhas que começam com espaço em branco (por exemplo, cabeçalhos SMTP):




               $ cat 2.txt
               Subject: Hello World
                     Content-
               Type: multipart/alternative;
                      border=94eb2c190cc6370f06054535da6a Data: Ter, 3
               de janeiro de 2017 19:41:16 +0000 (GMT)
               Resultados da autenticação: mx.gnu.org; dkim=pass
                           header.i=@gnu.org; spf=pass Message-
                           ID:
               <abcdef@gnu.org> De: John Doe
               <jdoe@gnu.org> Para: Jane Smith
               <jsmith@gnu.org>

               $ sed -E ':a ; $!N ; s/\n\s+/ / ; tá ; P ; D' 2.txt Assunto: Hello World Content-
               Type: multipart/alternative;
               border=94eb2c190cc6370f06054535da6a Data: Ter, 3 de janeiro de 2017 19:41:16 +0000 (GMT)

               Resultados da autenticação: mx.gnu.org; dkim=pass header.i=@gnu.org; spf=pass Message-ID:
               <abcdef@gnu.org> De: John Doe
               <jdoe@gnu.org> Para: Jane Smith
               <jsmith@gnu.org>

               # Uma variação portátil (não-gnu): # sed -e :a -e
               '$!N;s/\n */ /;ta' -e 'P;D'

        Arquivo: sed.info, Nó: Centrar linhas, Próximo: Incrementar um número, Anterior: Unir linhas, Acima: Exemplos


       7.2 Linhas de Centralização
       ===================

       Este script centraliza todas as linhas de um arquivo em uma largura de 80 colunas. Para alterar
       essa largura, o número em '\{...\}' deve ser substituído e o número de espaços adicionados também
       deve ser alterado.

            Observe como os comandos de buffer são usados para separar partes no
        expressões regulares a serem correspondidas — essa é uma técnica comum.

               #!/usr/bin/sed -f

               # Coloque 80 espaços no buffer 1 {

                   x
                   s/^$/ / s/^.*$/&&&&&&&&/

                   x
               }

               # exclui espaços iniciais e finais y/<TAB>/ / s/^ *// s/
               *$//




               # adicione uma nova linha e 80 espaços ao final da linha
               G


               # mantenha os primeiros 81 caracteres (80 + uma nova
               linha) s/^\(.\{81\}\).*$/\1/

               # \2 corresponde à metade dos espaços, que são movidos para o início s/^\(.*\)\n\(.*\)\2/\2\1/


       Arquivo: sed.info, Nó: Incrementar um número, Próximo: Renomear arquivos para letras minúsculas, Anterior:
       Centrar linhas, Acima: Exemplos





       7.3 Incrementar um Número
       ======================


       Este script é um dos poucos que demonstram como fazer aritmética em 'sed'. Isso é possível,(1) mas deve ser
       feito manualmente.

             Para incrementar um número basta adicionar 1 ao último dígito, substituindo-o por
        o dígito seguinte. Há uma exceção: quando o dígito é um nove, os dígitos anteriores também devem ser
        incrementados até que você não tenha nove.



            Esta solução de Bruno Haible é muito inteligente e esperta porque usa um único buffer; se você não tiver
        essa limitação, o algoritmo usado em *note Numeração de linhas: cat -n, é mais rápido. Ele funciona substituindo os
        noves à direita por um sublinhado e, em seguida, usando vários comandos 's' para incrementar o último dígito e,
        novamente, substituindo os sublinhados por zeros.




                #!/usr/bin/sed -f


                /[^0-9]/ d

                # substitua todos os 9s à direita por _ (qualquer outro caractere, exceto dígitos, pode # ser usado): ds/9\(_*\)$/_\1/ td




                # incr apenas o último dígito. A primeira linha adiciona um # dígito mais significativo de 1 se tivermos que
                adicionar um dígito.

                s/^\(_*\)$/1\1/; tn s/8\(_*\)$/9\1/;
                tn s/7\(_*\)$/8\1/; tn s/6\(_*\)$/
                7\1/; tn s/5\(_*\)$/6\1/; tn s/4\
                (_*\)$/5\1/; tn s/3\(_*\)$/4\1/; tn
                s/2\(_*\)$/3\1/; tn s/1\(_*\)$/2\1/;
                tn s/0\(_*\)$/1\1/; tn




                 :n
                s/_/0/

             ---------- Notas de rodapé ----------


            (1) O guru 'sed' Greg Ubben escreveu uma implementação da calculadora RPN 'dc'! É distribuído junto com
       o sed.

       Arquivo: sed.info, Nó: Renomear arquivos para letras minúsculas, Próximo: Imprimir ambiente bash, Anterior:
       Incrementar um número, Acima: Exemplos

       7.4 Renomear arquivos para letras minúsculas
       ==============================


       Este é um uso bastante estranho de 'sed'. Nós transformamos o texto e o transformamos em comandos do shell, depois
       apenas os alimentamos no shell. Não se preocupe, hacks ainda piores são feitos ao usar 'sed'; Eu vi um script
       convertendo a saída de 'date' em um programa 'bc'!



           O corpo principal disso é o script 'sed', que remapeia o nome de baixo para cima (ou vice-versa) e até verifica se o
        nome remapeado




       é o mesmo que o nome original. Observe como o script é parametrizado usando variáveis de shell e aspas
       apropriadas.

              #! /bin/sh #
              renomear arquivos para minúsculas/maiúsculas... #

              # uso:
                    mover para baixo * #
              #                          *
              mover para cima
              # ou
              #      mover-para-abaixar -R .
              #         mover para cima -R .
              #


              ajuda() {

                               cat << eof Uso:
              $0 [-n] [-r] [-h] arquivos...

              -n         não faça nada, apenas veja o que seria feito recursivamente
              -R         (use find)
              -h esta mensagem arquiva
              arquivos para remapear para letras minúsculas

              Exemplos:
                           $0 -n      *
                                                    (ver se está tudo ok, então...)
                           $0 *

                           $0 -R .

              eof }



              apply_cmd='sh'
              finder='echo "$@" | tr files_only=        " " "\n"'


              enquanto:
              faça
                       case "$1" in -n)
                             apply_cmd='cat' ;;
                             -R) finder='encontrar "$@" -type f';; -h) ajuda;
                             saída 1 ;; *) quebrar ;;

                       esac
                       turno
              feito

              se [-z "$1"]; então
                            echo Uso: $0 [-h] [-n] [-r] arquivos... exit 1

              fi

              LOWER='abcdefghijklmnopqrstuvwxyz'
              UPPER='ABCDEFGHIJKLMNOPQRSTUVWXYZ'

              case `basename $0` em
                         *superior*) TO=$UPPER; DE=$INFERIOR ;; *)
                                       FROM=$UPPER; TO=$BAIXO ;;
              esac

                                                    '
              eval $finder | sed -n

              # remove todas as barras finais




               s/\/*$//

              # add ./ se não houver caminho, apenas um nome de arquivo /\//! s/
              ^/.\//

              # salvar caminho+nome do arquivo
              h


              # remove caminho
              s/.*\///

              # fazer a conversão apenas no nome do arquivo
              y/'$FROM'/'$TO'/

              # agora a linha contém o caminho+arquivo original, enquanto #
              mantém o espaço contém o novo nome do arquivo
              x

              # adiciona o nome do arquivo convertido à linha, que agora contém # path/file-
              name\nconverted-file-name
               G


              # verifique se o nome do arquivo convertido é igual ao nome do arquivo original, # se for, não
              imprima nada /^.*\/\(.*\)\n\1/b


              # escape de caracteres especiais para o shell s/["$`\\]/\\&/g


              # agora, transforme path/fromfile\n, em # mv path/fromfile
              path/tofile e imprima s/^\(.*\/\)\(.*\)\n\(.*\)$/mv "\1\2" "\1\3"/p


               '
                   | $apply_cmd

       Arquivo: sed.info, Nó: Imprimir ambiente bash, Próximo: Inverter caracteres de linhas, Anterior: Renomear arquivos
       para letras minúsculas, Acima: Exemplos

       7.5 Ambiente de impressão 'bash'
       ============================

       Este script remove a definição das funções do shell da saída do comando Bourne-shell 'set'.


              #!/bin/sh

                                     '
               definir | sed -n
               :x

              # se não houver ocorrência de "=()" imprima e carregue a próxima linha /=()/!
              {p; b; } / () $/! {p; b; }


              # possível início da seção de funções # salve a linha
              caso seja uma variável como FOO="()" h


              # se a próxima linha tiver um parêntese, encerramos porque # nada
              vem depois das funções
              n
               /^{/q

              # imprime a linha antiga x; p





               # trabalhe na nova linha agora x; bx
                '


       Arquivo: sed.info, Nó: caracteres inversos de linhas, Próximo: Pesquisa de texto em várias linhas,
       Anterior: Imprimir ambiente bash, Acima: Exemplos

       7.6 Caracteres Inversos de Linhas
       ==================================

       Este script pode ser usado para inverter a posição dos caracteres nas linhas.
       A técnica move dois caracteres por vez, portanto, é mais rápida do que implementações mais
       intuitivas.

            Observe o comando 'tx' antes da definição do rótulo. Isso é
       frequentemente necessário para redefinir o sinalizador que é testado pelo comando 't'.

            Leitores imaginativos encontrarão usos para este script. Um exemplo é inverter a saída de
        'banner'.(1)

               #!/usr/bin/sed -f

               /../! b

               # Inverte uma linha. Comece a incorporar a linha entre duas novas linhas s/^.*$/\ &\ /




               # Mova o primeiro caractere no final. A regexp corresponde até # houver zero ou um
               caractere entre os marcadores tx

               :x
               s/\(\n.\)\(.*\)\(.\n\)/\3\2\1/ tx


               # Remova os marcadores de nova
               linha s/\n//g

            ---------- Notas de rodapé ----------


            (1) Isso requer outro script para preencher a saída do banner; por exemplo


               #! /bin/sh

               banner -w $1 $2 $3 $4 |
                 sed -e :a -e '/^.\{0,'$1'\}$/ { s/$/ /; BA; }' | ~/sedscripts/reverseline.sed


       Arquivo: sed.info, Nó: pesquisa de texto em várias linhas, Avançar: Ajuste do comprimento da linha, Anterior:
       caracteres inversos das linhas, Acima: Exemplos

       7.7 Pesquisa de texto em várias linhas
       =====================================

       Esta seção usa os comandos 'N' e 'D' para pesquisar palavras consecutivas abrangendo várias
       linhas. *Observação Técnicas multilinha::.

          Esses exemplos tratam de encontrar ocorrências duplicadas de palavras em um
       documento.

            Encontrar palavras duplicadas em uma única linha é fácil usando GNU 'grep' e




       da mesma forma com GNU 'sed':

               $ cat two-cities-dup1.txt Foi o melhor dos
               tempos, foi o pior dos tempos, foi a
               idade da sabedoria, foi a idade da tolice,




               $ grep -E '\b(\w+)\s+\1\b' two-cities-dup1.txt era a era da sabedoria,



               $ grep -n -E '\b(\w+)\s+\1\b' two-cities-dup1.txt 3:era a era da sabedoria,



               $ sed -En '/\b(\w+)\s+\1\b/p' two-cities-dup1.txt era a era da sabedoria,



               $ sed -En '/\b(\w+)\s+\1\b/{=;p}' two-cities-dup1.txt 3 era a era da sabedoria,




            • A expressão regular '\b\w+\s+' procura por limite de palavra
                ('\b'), seguido por um ou mais caracteres de palavra ('\w+'), seguido por espaço em branco ('\s+'). *Observe
               as extensões regexp::.

            • Adicionar parênteses ao redor da expressão '(\w+)' cria uma
               subexpressão. O padrão de expressão regular '(PATTERN)\s+\1' define uma subexpressão (entre
               parênteses) seguida por uma referência inversa, separada por espaços em branco. Uma
               correspondência bem-sucedida significa que o PADRÃO foi repetido duas vezes seguidas. *Nota Referências
               anteriores e Subexpressões::.



            • A expressão de limite de palavra ('\b') em ambas as extremidades garante que palavras
               parciais não sejam correspondidas (por exemplo, 'the then' não é uma correspondência desejada).

            • A opção '-E' permite sintaxe de expressão regular estendida,
               aliviando a necessidade de adicionar barras invertidas antes dos parênteses.
               *Observe a sintaxe do ERE::.

            Quando a palavra duplicada ocupa duas linhas, a expressão regular acima
       não irá encontrá-los como 'grep' e 'sed' operam linha por linha.

            Ao usar os comandos 'N' e 'D', 'sed' pode aplicar expressões regulares em várias linhas (ou seja, várias linhas
       são armazenadas no espaço padrão e a expressão regular funciona nelas):



               $ cat two-cities-dup2.txt Foi o melhor dos
               tempos, foi o pior dos tempos, foi a idade da sabedoria, foi
               a idade da tolice,




               $ sed -En '{N; /\b(\w+)\s+\1\b/{=;p} ; D}' duas cidades-dup2.txt 3

               pior dos tempos, era a idade da sabedoria,



            • O comando 'N' acrescenta a próxima linha ao espaço do padrão (assim garantindo que contenha duas
               linhas consecutivas em cada ciclo).

            • A expressão regular usa '\s+' para separador de palavras que corresponde
               espaços e novas linhas.

            • A expressão regular corresponde, todo o espaço do padrão é impresso




              com 'p'. Nenhuma linha é impressa por padrão devido à opção '-n'.

            • O 'D' remove a primeira linha do espaço padrão (até o
               primeira nova linha), preparando-o para o próximo ciclo.

            Veja o manual GNU 'coreutils' para uma solução alternativa usando 'tr
       -s' e 'uniq' em <https://
       gnu.org/s/coreutils/manual/html_node/Squeezing-and-deleting.html>.

       Arquivo: sed.info, Nó: Ajuste do comprimento da linha, Próximo: Adicionar um cabeçalho a vários
       arquivos, Anterior: Pesquisa de texto em várias linhas, Acima: Exemplos

       7.8 Ajuste do comprimento da linha
       ============================

       Esta seção usa os comandos 'N' e 'P' para ler e escrever linhas, e o comando 'b' para ramificação.
       *Observação Técnicas multilinha:: e *Observação Ramificação e controle de fluxo::.


            Este exemplo (um tanto artificial) lida com formatação e empacotamento
        linhas de texto do seguinte arquivo de entrada:

              $ cat two-cities-mix.txt Foi o melhor
              dos tempos, foi o pior dos tempos, foi a idade
              da sabedoria, foi



              era
              a era da
              insensatez,

       O seguinte programa sed agrupa linhas em 40 caracteres: $ cat wrap40.sed #
             loop externo

               :x

              # Anexa uma nova linha seguida pela próxima linha de entrada ao buffer padrão
              N


              # Remova todas as novas linhas do buffer padrão s/\n/ /g



              # Loop interno:y


              # Adicione uma nova linha após os primeiros 40 caracteres s/(.
              {40,40})/\1\n/

              # Se houver uma nova linha no buffer padrão # (ou seja, a
              substituição anterior adicionou uma nova linha) /\n/ { # Há novas linhas
              no buffer
                    padrão - # imprime o conteúdo até a primeira nova linha.

                       P

                      # Remova os caracteres impressos e a primeira nova linha s/.*\n//


                      # ramifica para o rótulo 'y' - repita o loop interno por

                  }




                # Sem novas linhas no buffer padrão - Ramifique para o rótulo 'x' (loop externo) # e leia a próxima linha de entrada bx




       A saída agrupada: $ sed -E -f
               wrap40.sed two-cities-mix.txt Foi o melhor dos tempos, foi o pior dos
               tempos, foi a idade da sabedoria, foi a idade da tolice,




        Arquivo: sed.info, Nó: Adicionando um cabeçalho a vários arquivos, Próximo: tac, Anterior: Ajuste do comprimento da linha,
        Acima: Exemplos

       7.9 Adicionando um cabeçalho a vários arquivos
       =====================================


       GNU 'sed' pode ser usado para modificar com segurança vários arquivos de uma só vez.

       Adicione uma única linha ao início dos arquivos de código-fonte:

                sed -i '1i/* Copyright (C) FOO BAR */' *.c

       Adicionar algumas linhas é possível usando '\n' no texto:

                sed -i '1i/*\n * Copyright (C) FOO BAR\n * Criado por Jane Doe\n */' *.c

             Para adicionar várias linhas de outro arquivo, use '0rFILE'. Um uso típico
       caso está adicionando um cabeçalho de aviso de licença a todos os arquivos:

                ## Crie o arquivo de cabeçalho: $
                cat<<'EOF'>LIC.TXT /*


                       Copyright (C) 1989-2021 FOO BAR

                       Este programa é um software livre; você pode redistribuí-lo e/ou modificá-lo sob os termos da GNU General Public
                       License conforme publicado pela Free Software Foundation; versão 3 ou (a seu critério) qualquer versão posterior.




                       Este programa é distribuído na esperança de que seja útil, mas SEM QUALQUER GARANTIA; mesmo
                       sem a garantia implícita de COMERCIABILIDADE ou ADEQUAÇÃO PARA UM FIM ESPECÍFICO.
                       Consulte a Licença Pública Geral GNU para obter mais detalhes.



                       Você deve ter recebido uma cópia da Licença Pública Geral GNU junto com este programa; Caso contrário,
                       consulte <https://www.gnu.org/licenses/>.
                */
                EOF

                ## Adicione o arquivo no início de todos os arquivos de código-fonte: $ sed -i '0rLIC.TXT' *.cpp *.h



            Com arquivos de script (por exemplo, arquivos '.sh', '.py', '.pl'), o aviso de licença geralmente aparece _após_ a
        primeira linha (a linha 'shebang' '#!'). O comando '1rFILE' adicionará 'FILE' _após_ a primeira linha:



                ## Crie o arquivo de cabeçalho: $
                cat<<'EOF'>LIC.TXT ## ##


                Copyright (C) 1989-2021 FOO BAR ## ## Este programa
                é
                software livre; você pode redistribuí-lo e/ou modificá-lo ## sob os termos da GNU General Public License conforme
                publicado pela ## Free Software Foundation; versão 3 ou (a seu critério)




                ## qualquer versão posterior. ## ##

                Este programa é distribuído na esperança de que seja útil, ## mas SEM QUALQUER GARANTIA; sem sequer a
                garantia implícita de ## COMERCIABILIDADE ou ADEQUAÇÃO PARA UM FIM ESPECÍFICO. Veja ## GNU
                General Public License para mais detalhes. ## ## Você deve ter recebido uma cópia da Licença Pública Geral
                GNU ## junto com este programa; Caso contrário, consulte <https://www.gnu.org/


                licenses/>. ##



                ##
                EOF

                ## Adicione o arquivo no início de todos os arquivos de código-fonte: $ sed -i '1rLIC.TXT' *.py *.sh



             Os comandos 'sed' acima podem ser combinados com 'find' para localizar arquivos
       em todos os subdiretórios, 'xargs' para executar comandos adicionais em arquivos selecionados e 'grep' para filtrar
       arquivos que já contêm um aviso de direitos autorais:



                find \( -iname '*.cpp' -o -iname '*.c' -o -iname '*.h' \) \
                          | xargs grep -Li copyright \ | xargs -r sed -i
                          '0rLIC.TXT'

       Ou uma versão ligeiramente segura (manipulação de arquivos com espaços e novas linhas):

                find \( -iname '*.cpp' -o -iname '*.c' -o -iname '*.h' \) -print0 \
                          | xargs -0 grep -Z -Li copyright \ | xargs -0 -r sed -i
                          '0rLIC.TXT'

            Nota: usar o endereço '0' com o comando 'r' requer GNU 'sed'
       versão 4.9 ou posterior. *Observação Endereço Zero::.


        Arquivo: sed.info, Nó: tac, Próximo: cat -n, Anterior: Adicionando um cabeçalho a vários arquivos, Acima: Exemplos



       7.10 Linhas Inversas de Arquivos
       ===========================


       Este inicia uma série de scripts totalmente inúteis (mas interessantes) emulando vários comandos do Unix. Isso, em
       particular, é um tipo de trabalho 'tac'.



            Observe que em implementações diferentes do GNU 'sed' este script pode
       estourar facilmente os buffers internos.

                #!/usr/bin/sed -nf


                # inverte todas as linhas de entrada, ou seja, a primeira linha se tornou a última, ...

                # a partir da segunda linha, o buffer (que contém todas as linhas anteriores) # é *anexado* à linha atual, portanto, a
                ordem será invertida 1! G



                # na última linha terminamos -- imprima tudo $ p



                # armazene tudo no buffer novamente h



        Arquivo: sed.info, Nó: cat -n, Próximo: cat -b, Anterior: tac, Acima: Exemplos

       7.11 Linhas de numeração




       ======================

       Este script substitui 'cat -n'; na verdade, ele formata sua saída exatamente como GNU 'cat' faz.


           Claro que isso é completamente inútil e por duas razões: primeiro,
       porque outra pessoa fez isso em C, segundo, porque o seguinte
       O script Bourne-shell poderia ser usado para o mesmo propósito e seria muito mais rápido:


               #! /bin/sh sed
                                                   '
               -e "=" $@ | sed -es/^/
                                 /
                    N
                    s/^ *\(......\)\n/\1 /
               '


            Ele usa 'sed' para imprimir o número da linha e, em seguida, agrupa as linhas dois a dois
        usando 'N'. Claro, este script não ensina tanto quanto o apresentado abaixo.


           O algoritmo usado para incrementar usa ambos os buffers, então a linha é impressa o mais rápido
       possível e então descartada. O número é dividido de modo que os dígitos variáveis vão para um buffer
       e os inalterados vão para o outro; os dígitos alterados são modificados em uma única etapa (usando
       um comando 'y').
       O número de linha para a próxima linha é então composto e armazenado no espaço de espera,
       para ser usado na próxima iteração.

               #!/usr/bin/sed -nf

               # Prepare a bomba na primeira linha x /^$/ s/^.*$/

               1/

               # Adicione o número da linha correta antes do padrão

               Gh



               # Formate e imprima s/^/ s/^ *\(......
               \)\n/         /
               \1 /p

               # Obtém o número da linha do espaço de espera; adicione um zero #
               se vamos adicionar um dígito na próxima linha gs/\n.*$// /^9*$/ s/^/0/




               # dígitos mutáveis/inalterados separados com um xs/.9*$/x&/


               # continue mudando os dígitos no espaço de espera

               hs/^.*x// y/
               0123456789/1234567890/
               x

               # mantém os dígitos inalterados no espaço padrão s/x.*$//


               # compõe o novo número, remove a nova linha adicionada implicitamente por G

               G s/\n//
               h





        Arquivo: sed.info, Nó: cat -b, Próximo: wc -c, Anterior: cat -n, Acima: Exemplos

       7.12 Numeração de linhas não em branco
       ==============================

       Emular 'cat -b' é quase o mesmo que 'cat -n' - só temos que selecionar quais linhas serão numeradas
       e quais não serão.

          A parte que é comum a este script e ao anterior não é
       comentou para mostrar como é importante comentar os scripts 'sed' corretamente...


               #!/usr/bin/sed -nf

               /^$/ {pb


               }

               # O mesmo que cat -n a partir de agora
               x
               /^$/ s/^.*$/1/ G hs/


               ^/ s/               /
               ^ *\(......\)\n/\1 /p
               x
               s/\n.*$// /
               ^9*$/ s/^/0/ s/.9*$/
               x&/ hs/^.*x// y/


               0123456789/1234567890/ xs/

               x.*$ // G s/

               \n// h


        Arquivo: sed.info, Nó: wc -c, Próximo: wc -w, Anterior: cat -b, Acima: Exemplos

       7.13 Contando Caracteres
       ========================

       Este script mostra outra maneira de fazer aritmética com 'sed'. Neste caso, temos que adicionar
       números possivelmente grandes, portanto, implementá-lo por incrementos sucessivos
       não seria viável (e possivelmente ainda mais complicado de inventar do que este script).


          A abordagem é mapear números para letras, uma espécie de ábaco implementado
       com 'sed'. 'a's são unidades, 'b's são dezenas e assim por diante: simplesmente adicionamos o
       número de caracteres na linha atual como unidades e, em seguida, propagamos o carry para
       dezenas, centenas e assim por diante.

            Como de costume, os totais em execução são mantidos no espaço de espera.

              Na última linha, convertemos a forma do ábaco de volta para decimal. Por uma questão de
        variedade, isso é feito com um loop em vez de alguns comandos de 80 's'(1): primeiro convertemos
         unidades, removendo 'a's do número; depois giramos as letras de modo que as dezenas se tornem
        'a's, e assim por diante até que não restem mais letras.


               #!/usr/bin/sed -nf





                # Adicione n+1 a's para manter o espaço (+1 é para a nova linha) s/./a/g H


                x
                s/\n/a/


                # Faça o transporte. Os t's e b's não são necessários, # mas aceleram a coisa ta :
                a; s/aaaaaaaaa/b/g; tb; b feito : b; s/bbbbbbbbbb/c/
                g;
                 tc; b feito: c; s/cccccccccc/d/g; td; b feito : d; s/dddddddddd/
                 e/g; te; b feito: e; s/eeeeeeeeee/f/g; tf; b feito: f; s/ffffffffff/
                 g/g; tg; b feito : g; s/gggggggggg/h/g; º; b feito: h; s/
                 hhhhhhhhhh//g




                 : feito $!
                { hb



                }

                # Na última linha, converta de volta para decimal

                : volta /
                a/! s/[bh]*/&0/ s/aaaaaaaaa/
                9/ s/aaaaaaaaa/8/ s/
                aaaaaaaaa/7/ s/
                aaaaaa/6/ s/aaaaaa/
                5/ s/aaaaaa/4/ s/
                aaaa/3 /s/aa/2/
                s/a/1/




                 : próximo
                y/bcdefgh/abcdefg/ /[ah]/ b
                loop p


             ---------- Notas de rodapé ----------


             (1) Algumas implementações têm um limite de 199 comandos por script

        Arquivo: sed.info, Nó: wc -w, Próximo: wc -l, Anterior: wc -c, Acima: Exemplos

       7.14 Contando Palavras
       ===================


       Este script é quase igual ao anterior, uma vez que cada uma das palavras na linha é convertida em um único
       'a' (no script anterior, cada letra foi alterada para um 'a').



            É interessante que programas 'wc' reais tenham loops otimizados para
       'wc -c', então eles são muito mais lentos na contagem de palavras do que de caracteres. O gargalo
       desse script, em vez disso, é aritmético e, portanto, o de contagem de palavras é mais rápido (ele precisa gerenciar
       números menores).

          Novamente, as partes comuns não são comentadas para mostrar a importância de
       comentando scripts 'sed'.





               #!/usr/bin/sed -nf

               # Converter palavras para a's s/
               [ <TAB>][ <TAB>]*/ /gs/^/ / s/ [^ ]
               [^ ]*/a /
               gs/ //g


               # Anexe-os para manter o espaço
               H

               xs/\n//

               # A partir daqui é o mesmo que em wc -c. /aaaaaaaaa/! bx; s/
               aaaaaaaaa/b/g /bbbbbbbbbb/! bx; s/bbbbbbbbbb/c/g /
               cccccccccc/! bx; s/cccccccccc/d/g/dddddddddd/! bx; s/
               dddddddddd/e/g /eeeeeeeeee/! bx; s/eeeeeeeeee/f/g /
               ffffffffff/! bx; s/ffffffffff/g/g/gggggggggg/! bx; s/
               gggggggggg/h/gs/hhhhhhhhhh//g :x




               $! {h; b; } :y /a/! s/

               [bh]*/&0/ s/aaaaaaaaa/9/
               s/aaaaaaaaa/8/ s/
               aaaaaaaaa/7/ s/
               aaaaaa/6/ s/
               aaaaaa/5/ s/
               aaaaaa/4/ s/
               aaaa/3 / s/aa/
               2/ s/a/1/ y/
               bcdefgh/
               abcdefg/ /
               [ah]/ por p




        Arquivo: sed.info, Nó: wc -l, Próximo: head, Anterior: wc -w, Acima: Exemplos

       7.15 Linhas de Contagem
       ===================

       Nenhuma coisa estranha é feita agora, porque 'sed' nos dá a funcionalidade 'wc -l' de graça!!!
       Olhar:

               #!/usr/bin/sed -nf $=



        Arquivo: sed.info, Nó: cabeça, Próximo: cauda, Anterior: wc -l, Acima: Exemplos

       7.16 Imprimindo as Primeiras Linhas
       ===============================

       Este script é provavelmente o script 'sed' útil mais simples. Ele exibe as primeiras 10 linhas de entrada; o
       número de linhas exibidas está logo antes do comando 'q'.


               #!/usr/bin/sed -f 10q



        Arquivo: sed.info, Node: tail, Next: uniq, Prev: head, Up: Exemplos





       7.17 Imprimindo as últimas linhas
       ============================

       Imprimir as últimas N linhas em vez da primeira é mais complexo, mas de fato possível. N é
       codificado na segunda linha, antes do caractere bang.


           Este script é semelhante ao script 'tac', pois mantém a saída final no espaço de retenção e a
       imprime no final:

               #!/usr/bin/sed -nf

               1! {; H; g; } 1,10 !s/
               [^\n]*\n// $ph



            Principalmente, os scripts mantêm uma janela de 10 linhas e a deslizam adicionando uma
       linha e excluindo a mais antiga (o comando de substituição na segunda linha funciona como um
       comando 'D', mas não reinicia o loop).

            A técnica de “janela deslizante” é uma maneira muito poderosa de escrever scripts 'sed'
       eficientes e complexos, porque comandos como 'P' exigiriam muito trabalho se implementados
       manualmente.

           Para apresentar a técnica, que é totalmente demonstrada no restante deste capítulo e é baseada
       nos comandos 'N', 'P' e 'D', aqui está uma implementação de 'cauda' usando uma simples “janela
       deslizante”.

           Isso parece complicado, mas na verdade o funcionamento é o mesmo do último script: depois
       de inserir o número apropriado de linhas, no entanto, paramos de usar o espaço de retenção para
       manter o estado entre linhas e, em vez disso, usamos 'N' e ' D' para deslizar o espaço do padrão
       em uma linha:

               #!/usr/bin/sed -f

               1h
               2,10 {; H; g; } $q 1,9d


               N
               D


            Observe como a primeira, segunda e quarta linha ficam inativas após as primeiras dez linhas
       de entrada. Depois disso, tudo o que o script faz é: sair na última linha de entrada, anexar a próxima
       linha de entrada ao espaço do padrão e remover a primeira linha.


        Arquivo: sed.info, Nó: uniq, Próximo: uniq -d, Anterior: tail, Acima: Exemplos

       7.18 Tornar Linhas Duplicadas Exclusivas
       =====================================

       Este é um exemplo da arte de usar os comandos 'N', 'P' e 'D', provavelmente os mais difíceis de
       dominar.

               #!/usr/bin/sed -fh


               :b
               # Na última linha, imprima e saia $b

               N




               /^\(.*\)\n\1$/ { # As duas
                       linhas são idênticas. Desfaz o efeito de # o comando n.


                      g bb
               }

               # Se o comando N tiver adicionado a última linha, imprima e saia $b


               # As linhas são diferentes; imprima o primeiro e # volte a trabalhar no
               segundo.
               P
               D


            Como você pode ver, mantemos uma janela de 2 linhas usando 'P' e 'D'. Essa técnica é frequentemente
        usada em scripts 'sed' avançados.

        Arquivo: sed.info, Nó: uniq -d, Próximo: uniq -u, Anterior: uniq, Acima: Exemplos

       7.19 Imprimir linhas de entrada duplicadas
       ====================================

       Este script imprime apenas linhas duplicadas, como 'uniq -d'.

               #!/usr/bin/sed -nf

               $b
               N
               /^\(.*\)\n\1$/ { # Imprime
                       a primeira das linhas duplicadas s/.*\n// p




                      # Loop até obter uma linha diferente :b $b N /^\(.*\)




                      \n\1$/ { s/.*\n// bb


                      }
               }

               # A última linha não pode ser seguida por duplicatas $b


               # Encontrei um diferente. Deixe-o sozinho no espaço padrão # e volte ao topo, caçando
               suas duplicatas D


        Arquivo: sed.info, Nó: uniq -u, Próximo: cat -s, Anterior: uniq -d, Acima: Exemplos

       7.20 Remover todas as linhas duplicadas
       =====================================

       Este script imprime apenas linhas exclusivas, como 'uniq -u'.

               #!/usr/bin/sed -f

               # Procure por uma linha duplicada --- até lá, imprima o que encontrar. $ b N


               /^\(.*\)\n\1$/ ! {




                         P
                         D
               }

               :c
               # Tem duas linhas iguais no espaço do padrão. No # final do arquivo
               simplesmente saímos de $d


               # Caso contrário, continuamos lendo as linhas com N até #
               encontrarmos uma diferente
               s/.*\n// N /

               ^\(.*\)\n\1$/ { bc

               }

               # Remova a última instância da linha duplicada # e volte ao topo

               D


        Arquivo: sed.info, Nó: cat -s, Anterior: uniq -u, Acima: Exemplos

       7.21 Espremendo linhas em branco
       ============================

       Como exemplo final, aqui estão três scripts, de complexidade e velocidade crescentes, que implementam
       a mesma função de 'cat -s', que é espremer linhas em branco.


            A primeira deixa uma linha em branco no início e no final, caso já existam.


               #!/usr/bin/sed -f

               # em linhas vazias, junte-se a próximo
               # Observe que há uma estrela no regexp :x

               /^\n*$/ {


               Nbx }

               # agora, esprema todos os '\n', isso também pode ser feito por: # s/^\
               (\n\)*/\1/ s/\n*/\ /



           Este é um pouco mais complexo e remove todas as linhas vazias no início. Ele deixa uma
       única linha em branco no final, se houver.

               #!/usr/bin/sed -f

               # exclui todas as linhas vazias iniciais 1,/^./{ /./!
               d}



               # em uma linha vazia nós a removemos e todas as # linhas vazias seguintes,
               exceto uma :x

               /./!{ N

               s/^\n$//




                 tx }



             Isso remove as linhas em branco iniciais e finais. É também o mais rápido. Observe que os loops são
       feitos completamente com 'n' e 'b', sem depender de 'sed' para reiniciar o script automaticamente no final de uma
       linha.


                 #!/usr/bin/sed -nf


                 # exclui todos os espaços em branco (à
                 esquerda) /./!d

                 # chegar aqui: então há um não vazio :x

                 # imprimir p #

                 pegar proximo
                 n
                 # tem caracteres? imprima novamente, etc... /./bx



                 # não, não tem caracteres: tem uma linha vazia :z

                 # pega a próxima, se a última linha terminamos aqui então não há # linhas vazias são
                 escritas n

                 # também vazio? então ignore-o e vá para o próximo... isso irá # remover TODAS as linhas
                 vazias /./!bz



                 # todas as linhas vazias foram excluídas/ignoradas, mas temos uma não vazia. Como # o que queremos fazer
                 é espremer, inserir uma linha em branco artificialmente i\


                 bx


        Arquivo: sed.info, Nó: Limitações, Próximo: Outros Recursos, Anterior: Exemplos, Acima: Início


       8 Limitações e não-limitações do GNU 'sed'
        **********************************************


       Para aqueles que desejam escrever scripts 'sed' portáteis, esteja ciente de que algumas implementações são
       conhecidas por limitar os comprimentos de linha (para o padrão e espaços de espera) a não mais que 4000 bytes.
       O padrão POSIX especifica que as implementações 'sed' em conformidade devem suportar pelo menos 8192
       bytes de comprimento de linha. GNU 'sed' não tem limite embutido no comprimento da linha; contanto que possa
       'malloc ()' mais memória (virtual), você pode alimentar ou construir linhas o quanto quiser.




            No entanto, a recursão é usada para lidar com subpadrões e repetição indefinida. Isso significa que o
        espaço de pilha disponível pode limitar o tamanho do buffer que pode ser processado por determinados padrões.



        Arquivo: sed.info, Nó: Outros recursos, Avançar: Relatar bugs, Anterior: Limitações, Acima: Início



       9 Outros recursos para aprender sobre 'sed'
       ******************************************


       Para obter informações atualizadas sobre o GNU 'sed', visite <https://www.gnu.org/
       software/sed/>.




           Envie perguntas gerais e sugestões para <sed-devel@gnu.org>. Visite os arquivos da lista de
       discussão para discussões anteriores em <https://lists.gnu.org/archive/
       html/sed-devel/>.

            Os seguintes recursos fornecem informações sobre 'sed' (ambos GNU 'sed' e outras
        variações). Observe que eles não são mantidos pelos desenvolvedores GNU 'sed'.


            • sed '$HOME': <http://sed.sf.net>

            • FAQ do sed: <http://sed.sf.net/sedfaq.html>

            • sacola do seder: <http://sed.sf.net/grabbag>

            • A lista de discussão 'sed-users' mantida por Sven Guckes:
               <http://groups.yahoo.com/group/sed-users/> (observe que esta _não_ é a lista de discussão
               GNU 'sed').

       Arquivo: sed.info, Nó: Relatando Bugs, Próximo: Licença de Documentação Livre GNU, Anterior: Outros
       Recursos, Acima: Início

       10 Relatando Bugs
       *****************


       Envie relatórios de erros por e-mail para <bug-sed@gnu.org>. Além disso, inclua a saída de 'sed --
       version' no corpo do seu relatório, se possível.

           Por favor, não envie um relatório de bug como este:

              ao compilar frombme-1.3.4 $ configure
              errorÿ sed:
              arquivo sedscr linha 1: opção desconhecida para 's'

           Se o GNU 'sed' não configurar seu pacote favorito, gaste alguns minutos extras para
       identificar o problema específico e fazer um caso de teste independente. Ao contrário de outros
       programas, como compiladores C, fazer esses casos de teste para 'sed' é bastante simples.


            Um caso de teste independente inclui todos os dados necessários para executar o teste e a
       invocação específica de 'sed' que causa o problema.
       Quanto menor for um caso de teste independente, melhor. Um caso de teste não deve envolver algo
       tão distante de 'sed' como “tentar configurar a partir do me-1.3.4”. Sim, isso é, em princípio,
       informação suficiente para procurar o bug, mas não é uma perspectiva muito prática.


           Aqui estão alguns bugs comumente relatados que não são bugs.

        Comando 'N' na última linha

              A maioria das versões de 'sed' sai sem imprimir nada quando o comando 'N' é emitido na última
              linha de um arquivo. GNU 'sed' imprime o espaço padrão antes de sair, a menos que a
              opção de comando '-n' tenha sido especificada. Essa escolha é intencional.


              Comportamento padrão (extensão gnu, não compatível com POSIX):
                   $ seq 3 | sed N 1

                      2
                     3
              Para forçar o comportamento em conformidade
                     com POSIX: $ seq 3 | sed --posix
                     N1
                     2




               Por exemplo, o comportamento de sed
                       N foo bar
               dependeria se foo tem um número par ou ímpar de linhas(1). Ou, ao escrever um
               script para ler as próximas linhas após uma correspondência de padrão, as implementações
               tradicionais de 'sed' forçariam você a escrever algo como

                     /foo/{ $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N; $!N }
               em vez de apenas /
                     foo/{ N;N;N;N;N;N;N;N;N; }

               Em qualquer caso, a solução mais simples é usar '$d;N' em scripts que dependem do
               comportamento tradicional ou definir a variável 'POSIXLY_CORRECT' para
               um valor não vazio.

       Conflitos de sintaxe Regex (problemas com barras invertidas)
                'sed' usa a sintaxe de expressão regular básica POSIX. De acordo com o padrão, o significado
               de algumas sequências de escape é indefinido nessa sintaxe; notáveis no caso de 'sed' são '\|',
               '\+', '\?', '\`', '\'', '\<', '\>', '\b', ' \B', '\w' e '\W'.


               Como em todos os programas GNU que usam expressões regulares básicas POSIX, 'sed'
               interpreta essas sequências de escape como caracteres especiais. Portanto, 'x\+' corresponde
               a uma ou mais ocorrências de 'x'. 'abc\|def' corresponde a 'abc' ou 'def'.


               Esta sintaxe pode causar problemas ao executar scripts escritos para outros 'sed's. Alguns
               programas 'sed' foram escritos com a suposição de que '\|' e '\+' correspondem aos
               caracteres literais '|' e '+'. Esses scripts devem ser modificados removendo as barras invertidas
               espúrias se forem usados com implementações modernas de 'sed', como GNU 'sed'.



               Por outro lado, alguns scripts usam s|abc\|def||g para remover ocorrências de _ou_
               'abc' ou 'def'. Embora isso funcionasse até 'sed' 4.0.x, versões mais recentes interpretam
                isso como a remoção da string 'abc|def'. Este é novamente um comportamento indefinido de
                acordo com o POSIX, e esta interpretação é indiscutivelmente mais robusta: 'sed's mais
               antigos, por exemplo, exigiam que o correspondente regex analisasse '\/' como '/' no caso
               comum de escapar de uma barra, que é novamente comportamento indefinido; o novo
               comportamento evita isso, e isso é bom porque o correspondente regex está apenas parcialmente
               sob nosso controle.


               Além disso, esta versão do 'sed' suporta vários caracteres de escape (alguns dos
               quais são multi-caracteres) para inserir caracteres não imprimíveis em scripts
               ('\a', '\c', '\d', '\o' , '\r', '\t', '\v', '\x'). Isso pode causar problemas semelhantes com scripts escritos
               para outros 'sed's.


        '-i' destrói arquivos somente leitura

               Resumindo, 'sed -i' permitirá que você exclua o conteúdo de um arquivo somente leitura e, em
               geral, a opção '-i' (*nota Invocação: Invocando sed.) permite que você destrua arquivos
               protegidos. Isso não é um bug, mas sim uma consequência de como o sistema de arquivos
               Unix funciona.

               As permissões em um arquivo dizem o que pode acontecer com os dados desse arquivo,
               enquanto as permissões em um diretório dizem o que pode acontecer com a lista de arquivos
               nesse diretório. 'sed -i' nunca será aberto para gravar um arquivo que já está no disco. Em
               vez disso, ele funcionará em um arquivo temporário que é finalmente renomeado para o nome
               original: se você renomear ou excluir arquivos, na verdade estará modificando o conteúdo do
               diretório, portanto, a operação depende das permissões do diretório, não do arquivo.
               Por esta mesma razão, 'sed' não permite que você use '-i' em um arquivo gravável
               em um




                 diretório somente leitura e quebrará links físicos ou simbólicos quando '-i' for usado em tal arquivo.



        '0a' não funciona (dá erro)

                Não há linha 0. 0 é um endereço especial que é usado apenas para tratar endereços como '0,/RE/' como
                ativos quando o script inicia: se você escrever '1,/abc/d' e a primeira linha incluir o string 'abc', essa
                correspondência seria ignorada porque os intervalos de endereços devem abranger pelo menos duas linhas
                (exceto o final do arquivo); mas o que você provavelmente queria é excluir todas as linhas até a primeira,
                incluindo 'abc', e isso é obtido com '0,/abc/d'.




        '[az]' não diferencia maiúsculas de minúsculas

                Você está encontrando problemas com localidades. O POSIX exige que '[az]' use a ordem de agrupamento
                da localidade atual - na linguagem C, isso significa usar 'strcoll(3)' em vez de 'strcmp(3)'. Algumas localidades
                têm uma ordem de agrupamento que não diferencia maiúsculas de minúsculas, outras não.



                Outro problema é que '[az]' tenta usar símbolos de agrupamento.
                Isso só acontece se você estiver no sistema GNU, usando o correspondente de expressão regular do
                GNU libc em vez de compilar aquele fornecido com o GNU sed. Em uma localidade dinamarquesa, por
                exemplo, a expressão regular '^[az]$' corresponde à string 'aa', porque este é um único símbolo
                de agrupamento que vem depois de 'a' e antes de 'b'; 'll' se comporta de forma semelhante em localidades
                espanholas, ou 'ij' em localidades holandesas.



                Para contornar esses problemas, que podem causar bugs em scripts de shell, defina as variáveis
                de ambiente 'LC_COLLATE' e 'LC_CTYPE' como 'C'.



        's/.*//' não limpa o espaço do padrão

                Isso acontecerá se o fluxo de entrada incluir sequências multibyte inválidas. O POSIX exige que
                tais sequências _não_ sejam correspondidas por '.', de modo que 's/.*//' não libere o espaço padrão como seria
                 de esperar. Na verdade, não há como limpar os buffers do sed no meio do script na maioria das
                localidades multibyte (incluindo localidades UTF-8). Por esta razão, GNU 'sed' fornece um comando
                'z' (para 'zap') como uma extensão.




                Para contornar esses problemas, que podem causar bugs em scripts de shell, defina as variáveis
                de ambiente 'LC_COLLATE' e 'LC_CTYPE' como 'C'.


             ---------- Notas de rodapé ----------


             (1) qual é o “bug” real que provocou a mudança de comportamento

        Arquivo: sed.info, Nó: GNU Free Documentation License, Próximo: Índice de Conceito, Anterior: Relatando Bugs, Acima: Início



       Apêndice A Licença de Documentação Livre GNU
       ******************************


                                                     Versão 1.3, 3 de novembro de 2008

                Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. <https://fsf.org/>



                Todos têm permissão para copiar e distribuir cópias exatas deste documento de licença, mas não
                é permitido alterá-lo.




          0. PREÂMBULO


               O objetivo desta Licença é tornar um manual, livro-texto ou outro documento funcional e útil “livre”
               no sentido de liberdade: assegurar a todos a liberdade efetiva de copiá-lo e redistribuí-lo, com
               ou sem modificação, comercial ou não comercialmente . Secundariamente, esta Licença preserva
               para o autor e editor uma forma de obter crédito por seu trabalho, não sendo
               considerado responsável por modificações feitas por terceiros.



               Esta Licença é uma espécie de “copyleft”, o que significa que os trabalhos derivados do
               documento devem ser livres no mesmo sentido.
               Ela complementa a GNU General Public License, que é uma licença copyleft projetada para
               software livre.

               Nós projetamos esta Licença para usá-la em manuais de software livre, porque o software
               livre precisa de documentação livre: um programa livre deve vir com manuais que forneçam
               as mesmas liberdades que o software oferece. Mas esta Licença não se limita a manuais de
               software; pode ser usado para qualquer trabalho textual, independentemente do
               assunto ou se é publicado como um livro impresso. Recomendamos esta Licença principalmente
               para trabalhos cujo propósito seja instrução ou referência.



          1. APLICABILIDADE E DEFINIÇÕES



               Esta Licença se aplica a qualquer manual ou outro trabalho, em qualquer meio, que contenha
               um aviso colocado pelo detentor dos direitos autorais dizendo que pode ser distribuído sob os
               termos desta Licença. Tal aviso concede uma licença mundial isenta de royalties, de
               duração ilimitada, para usar esse trabalho nas condições aqui estabelecidas. O “Documento”,
               abaixo, refere-se a qualquer manual ou trabalho. Qualquer membro do público é
               um licenciado e é tratado como “você”. Você aceita a licença se copiar, modificar ou distribuir o
               trabalho de uma forma que exija permissão sob a lei de direitos autorais.



               Uma “Versão Modificada” do Documento significa qualquer trabalho que contenha o Documento
               ou uma parte dele, copiado literalmente ou com modificações e/ou traduzido para outro
               idioma.

               Uma “Seção Secundária” é um apêndice nomeado ou uma seção inicial do Documento que lida
               exclusivamente com a relação dos editores ou autores do Documento com o assunto geral do
               Documento (ou assuntos relacionados) e não contém nada que possa cair diretamente
               dentro desse assunto geral. (Assim, se o Documento for em parte um livro-texto de
               matemática, uma Seção Secundária não pode explicar nenhuma matemática.) A relação pode
               ser uma questão de conexão histórica com o assunto ou com assuntos relacionados, ou de
               interesse legal, comercial, filosófico, ético ou posição política em relação a eles.




               As “Seções Invariantes” são certas Seções Secundárias cujos títulos são designados,
               como sendo os das Seções Invariantes, no aviso que diz que o Documento é lançado sob esta
               Licença.
               Se uma seção não se encaixa na definição acima de Secundária, ela não pode ser designada
               como Invariante. O Documento pode conter zero Seções Invariantes. Se o Documento não
               identificar nenhuma Seção Invariante, então não há nenhuma.


               Os “Textos de Capa” são certas passagens curtas de texto listadas, como Textos de
               Capa Frontal ou Textos de Capa Traseira, no aviso que diz que o Documento é lançado sob
               esta Licença. Um Texto de Capa Frontal pode ter no máximo 5 palavras e um Texto de
               Capa Traseira pode ter no máximo 25 palavras.





              Uma cópia “Transparente” do Documento significa uma cópia legível por máquina, representada
              em um formato cuja especificação esteja disponível ao público em geral, que seja
              adequada para revisar o documento diretamente com editores de texto genéricos
              ou (para imagens compostas por pixels) pintura genérica programas ou (para desenhos) algum
              editor de desenho amplamente disponível e que seja adequado para entrada em
              formatadores de texto ou para tradução automática para uma variedade de formatos
              adequados para entrada em formatadores de texto. Uma cópia feita em um formato de
              arquivo Transparente cuja marcação, ou ausência de marcação, foi organizada para impedir
              ou desencorajar modificações subsequentes pelos leitores não é Transparente. Um
              formato de imagem não é Transparente se usado para qualquer quantidade substancial de
              texto. Uma cópia que não é “transparente” é chamada de “opaca”.



              Exemplos de formatos adequados para cópias transparentes incluem ASCII simples sem
              marcação, formato de entrada Texinfo, formato de entrada LaTeX, SGML ou XML usando
              um DTD publicamente disponível e HTML simples em conformidade com o padrão, PostScript
              ou PDF projetado para modificação humana.
              Exemplos de formatos de imagem transparentes incluem PNG, XCF e JPG.
              Os formatos opacos incluem formatos proprietários que podem ser lidos e editados
              apenas por processadores de texto proprietários, SGML ou XML para os quais o DTD e/ou
              ferramentas de processamento não estão geralmente disponíveis, e o HTML, PostScript
              ou PDF gerado por máquina produzido por alguns processadores de texto para apenas para
              fins de saída.

              A “Página de Título” significa, para um livro impresso, a própria página de título, mais as
              páginas seguintes necessárias para conter, de forma legível, o material que esta
              Licença exige que apareça na página de título. Para trabalhos em formatos que não
              possuem nenhuma página de título propriamente dita, “Página de Título” significa o texto
              próximo à aparência mais proeminente do título da obra, precedendo o início do corpo
              do texto.

              O “editor” significa qualquer pessoa ou entidade que distribua cópias do Documento ao público.


              Uma seção “Intitulada XYZ” significa uma subunidade nomeada do Documento cujo
              título é precisamente XYZ ou contém XYZ entre parênteses após o texto que traduz XYZ em
              outro idioma. (Aqui XYZ representa um nome de seção específico mencionado abaixo, como
              “Agradecimentos”, “Dedicatórias”, “Apoios” ou “Histórico”.)

              “Preservar o título” de tal seção ao modificar o documento significa que ele permanece
              uma seção “Intitulada XYZ” de acordo com esta definição.


              O documento pode incluir isenções de garantia ao lado do aviso que afirma que esta
              licença se aplica ao documento. Estas Isenções de Garantia são consideradas incluídas
              por referência nesta Licença, mas apenas no que diz respeito às garantias de isenção:
              qualquer outra implicação que estas Isenções de Garantia possam ter é nula e não tem efeito
              sobre o significado desta Licença.


          2. CÓPIA INTEGRAL


              Você pode copiar e distribuir o Documento em qualquer meio, comercial ou não, desde
              que esta Licença, os avisos de direitos autorais e o aviso de licença dizendo que esta
              Licença se aplica ao Documento sejam reproduzidos em todas as cópias e que você
              não acrescente nenhuma outra condição. aos desta Licença. Você não pode usar medidas
              técnicas para obstruir ou controlar a leitura ou posterior cópia das cópias que você faz ou
              distribui. No entanto, você pode aceitar compensação em troca de cópias. Se você distribuir
              um número grande de cópias, também deverá seguir as condições da seção 3.





               Você também pode emprestar cópias, nas mesmas condições acima, e pode exibir cópias publicamente.



          3. COPIANDO EM QUANTIDADE

               Se você publicar cópias impressas (ou cópias em mídia que geralmente têm capas impressas) do
               Documento, numerando mais de 100, e o aviso de licença do Documento exigir Textos de Capa, você deve
               incluir as cópias em capas que contenham, de forma clara e legível, todos esses Textos de capa:
               Textos de capa frontal na capa frontal e Textos de capa traseira na capa traseira. Ambas as capas também
               devem identificá-lo de forma clara e legível como o editor dessas cópias. A capa frontal deve
               apresentar o título completo com todas as palavras do título igualmente destacadas e visíveis. Além disso,
               você pode adicionar outro material nas capas. A cópia com alterações limitadas às capas, desde que
               preservem o título do Documento e satisfaçam estas condições, pode ser tratada como cópia literal nos demais
               aspectos.




               Se os textos necessários para qualquer uma das capas forem muito volumosos para caber de forma
               legível, você deve colocar os primeiros listados (quantos couberem razoavelmente) na capa real e
               continuar o restante nas páginas adjacentes.



               Se você publicar ou distribuir cópias opacas do documento numeradas acima de 100, você deve
               incluir uma cópia transparente legível por máquina junto com cada cópia opaca, ou indicar em ou com cada
               cópia opaca um local de rede de computadores a partir do qual a rede geral- usando público tem acesso
               para baixar usando protocolos de rede de padrão público uma cópia transparente completa do documento, livre
               de material adicionado. Se você usar a última opção, deverá tomar medidas razoavelmente prudentes, ao
               iniciar a distribuição de cópias opacas em quantidade, para garantir que esta cópia transparente permaneça
               acessível no local indicado até pelo menos um ano após a última vez que você distribuiu um Cópia
               opaca (diretamente ou por meio de seus agentes ou varejistas) dessa edição para o público.




               É solicitado, mas não obrigatório, que você entre em contato com os autores do Documento bem antes de
               redistribuir qualquer grande número de cópias, para dar a eles a chance de fornecer a você uma versão
               atualizada do Documento.


          4. MODIFICAÇÕES



               Você pode copiar e distribuir uma Versão Modificada do Documento sob as condições das seções 2 e
               3 acima, desde que você libere a Versão Modificada exatamente sob esta Licença, com a Versão Modificada
               preenchendo o papel do Documento, licenciando assim a distribuição e modificação de a Versão Modificada a
               quem possuir uma cópia dela. Além disso, você deve fazer o seguinte na versão modificada:




                  A. Use na página de título (e nas capas, se houver) um título
                       distinta daquela do Documento, e das versões anteriores (que deveriam, se houver, ser listadas na
                       seção Histórico do Documento). Você pode usar o mesmo título de uma versão anterior se o
                       editor original dessa versão permitir.




                  B. Listar na Página de Título, como autores, uma ou mais pessoas ou entidades responsáveis pela
                       autoria das modificações na Versão Modificada, juntamente com pelo menos cinco dos principais
                       autores do Documento (todos os seus principais autores, se tiver menos de cinco), a menos
                       que eles o libertem




                    a partir desta exigência.

               C. Indique na página de título o nome do editor da Versão Modificada, como o
                    editor.

                D. Preserve todos os avisos de copyright do Documento.

                E. Adicione um aviso de direitos autorais apropriado para suas modificações
                    adjacente aos outros avisos de direitos autorais.

                F. Incluir, imediatamente após os avisos de direitos autorais, um aviso de licença
                     dando ao público permissão para usar a Versão Modificada nos termos
                     desta Licença, na forma mostrada no Adendo abaixo.


               G. Preservar nesse aviso de licença as listas completas de Seções Invariantes e
                   Textos de Capa exigidos fornecidos no aviso de licença do Documento.


                H. Inclua uma cópia inalterada desta Licença.

                I. Preserve a seção intitulada “História”, preserve seu título e acrescente a ela um item
                     declarando pelo menos o título, ano, novos autores e editor da versão modificada,
                     conforme indicado na página de título. Se não houver uma seção intitulada “História”
                     no Documento, crie uma informando o título, ano, autores e editor do Documento
                     conforme indicado em sua Página de Título e, em seguida, adicione um item
                     descrevendo a Versão Modificada conforme indicado na frase anterior.



                J. Preserve o local de rede, se houver, fornecido no Documento para acesso público a
                    uma cópia Transparente do Documento e, da mesma forma, os locais de rede
                     fornecidos no Documento para versões anteriores nas quais ele foi baseado.
                    Estes podem ser colocados na seção "Histórico". Você pode omitir um local de rede
                    para um trabalho que foi publicado pelo menos quatro anos antes do próprio
                    Documento, ou se o editor original da versão a que ele se refere der permissão.



                K. Para qualquer seção intitulada "Agradecimentos" ou "Dedicatórias",
                    Preservar o título da seção e preservar na seção toda a substância e tom de cada um
                    dos agradecimentos e/ou dedicatórias de cada colaborador.


                L. Preservar todas as Seções Invariantes do Documento, inalteradas em seu texto e em
                    seus títulos. Os números das seções ou equivalentes não são considerados
                    parte dos títulos das seções.

               M. Exclua qualquer seção intitulada “Apoios”. Tal seção pode não ser incluída na
                   Versão Modificada.

                N. Não renomeie nenhuma seção existente para ser intitulada
                    “Endossos” ou em conflito de título com qualquer Seção Invariante.


               O. Preserve quaisquer isenções de garantia.

             Se a Versão Modificada incluir novas seções iniciais ou apêndices que se qualifiquem
             como Seções Secundárias e não contiverem material copiado do Documento, você
             poderá, a seu critério, designar algumas ou todas essas seções como invariantes. Para fazer
             isso, adicione seus títulos à lista de Seções Invariantes no aviso de licença da Versão
             Modificada. Esses títulos devem ser distintos de quaisquer outros títulos de seção.





              Você pode adicionar uma seção intitulada “Endossos”, desde que contenha apenas endossos de
              sua Versão Modificada por várias partes - por exemplo, declarações de revisão por pares
              ou que o texto foi aprovado por uma organização como a definição oficial de um padrão.




              Você pode adicionar uma passagem de até cinco palavras como Texto de Capa Frontal e uma
              passagem de até 25 palavras como Texto de Contracapa ao final da lista de Textos de Capa na
              Versão Modificada. Apenas uma passagem do Texto da Capa Frontal e uma do Texto da Capa
              Traseira podem ser adicionadas por (ou por meio de acordos feitos por) qualquer entidade. Se o
              Documento já incluir um texto de capa para a mesma capa, adicionado anteriormente por
              você ou por acordo feito pela mesma entidade que você está agindo em nome, você não poderá
              adicionar outro; mas você pode substituir o antigo, com permissão explícita do editor anterior que
              adicionou o antigo.




              O(s) autor(es) e editor(es) do Documento não dão, por meio desta Licença, permissão para
              usar seus nomes para publicidade ou para afirmar ou implicar o endosso de qualquer Versão
              Modificada.

          5. COMBINAÇÃO DE DOCUMENTOS



              Você pode combinar o Documento com outros documentos liberados sob esta Licença, sob os
              termos definidos na seção 4 acima para versões modificadas, desde que você inclua na
              combinação todas as Seções Invariantes de todos os documentos originais, não modificados, e liste
              todas elas como Seções Invariantes de seu trabalho combinado em seu aviso de licença
              e que você preserva todas as Isenções de Responsabilidade de Garantia.




              O trabalho combinado precisa conter apenas uma cópia desta Licença, e várias Seções Invariantes
              idênticas podem ser substituídas por uma única cópia. Se houver várias Seções Invariantes com o
              mesmo nome, mas conteúdos diferentes, torne o título de cada seção exclusivo adicionando no
              final dele, entre parênteses, o nome do autor original ou editor dessa seção, se conhecido, ou
              então um número único. Faça o mesmo ajuste nos títulos das seções na lista de Seções
              Invariantes no aviso de licença da obra combinada.




              Na combinação, você deve combinar quaisquer seções intituladas “História” nos vários
              documentos originais, formando uma seção intitulada “História”; da mesma forma, combine
              quaisquer seções intituladas “Agradecimentos” e quaisquer seções intituladas
              “Dedicatórias”. Você deve excluir todas as seções intituladas "Endossos".


          6. COLETAS DE DOCUMENTOS

              Você pode fazer uma coleção que consiste no Documento e outros documentos liberados
              sob esta Licença e substituir as cópias individuais desta Licença nos vários documentos por uma
              única cópia incluída na coleção, desde que você siga as regras desta Licença para cópia literal de
              cada um dos documentos em todos os outros aspectos.




              Você pode extrair um único documento de tal coleção e distribuí-lo individualmente sob esta
              Licença, desde que insira uma cópia desta Licença no documento extraído e siga esta Licença em
              todos os outros aspectos relacionados à cópia literal desse documento.



          7. AGREGAÇÃO COM OBRAS INDEPENDENTES





              Uma compilação do Documento ou seus derivados com outros documentos ou trabalhos
              separados e independentes, em ou em um volume de um meio de armazenamento ou distribuição,
              é chamada de “agregado” se os direitos autorais resultantes da compilação não forem usados
              para limitar os direitos legais dos usuários da compilação além do que os trabalhos individuais
              permitem. Quando o Documento é incluído em um agregado, esta Licença não se aplica a outros
              trabalhos no agregado que não sejam trabalhos derivados do Documento.



              Se o requisito do Texto de Capa da seção 3 for aplicável a essas cópias do Documento, então,
              se o Documento for menos da metade de todo o agregado, os Textos de Capa do Documento
              podem ser colocados em capas que incluem o Documento dentro do agregado, ou o equivalente
              eletrônico de capas se o documento estiver em formato eletrônico. Caso contrário, devem
              aparecer em capas impressas que englobem todo o agregado.



          8. TRADUÇÃO



              A tradução é considerada um tipo de modificação, então você pode distribuir traduções
              do Documento sob os termos da seção 4. A substituição de Seções Invariantes por traduções
              requer permissão especial dos detentores dos direitos autorais, mas você pode incluir traduções de
              algumas ou todas as Seções Invariantes além de as versões originais dessas Seções
              Invariantes. Você pode incluir uma tradução desta Licença e todos os avisos de licença no
              Documento e quaisquer Isenções de Garantia, desde que você também inclua a versão original
              em inglês desta Licença e as versões originais desses avisos e isenções de responsabilidade.
              Em caso de desacordo entre a tradução e a versão original desta Licença ou um aviso ou
              isenção de responsabilidade, a versão original prevalecerá.




              Se uma seção no documento for intitulada “Agradecimentos”, “Dedicatórias” ou “História”,
              a exigência (seção 4) para preservar seu título (seção 1) normalmente exigirá a
              alteração do título real.


          9. RESCISÃO


              Você não pode copiar, modificar, sublicenciar ou distribuir o Documento, exceto conforme
              expressamente previsto nesta Licença. Qualquer tentativa de copiar, modificar, sublicenciar
              ou distribuir é nula e encerrará automaticamente seus direitos sob esta licença.


              No entanto, se você interromper todas as violações desta Licença, sua licença de um
              detentor de direitos autorais específico será restabelecida (a) provisoriamente, a menos
              e até que o detentor dos direitos autorais explicitamente e finalmente rescinda sua licença e (b)
              permanentemente, se o detentor dos direitos autorais falhar para notificá-lo da violação
              por algum meio razoável antes de 60 dias após a cessação.


              Além disso, sua licença de um determinado detentor de direitos autorais é restabelecida
              permanentemente se o detentor dos direitos autorais o notificar sobre a violação por algum meio
              razoável, esta é a primeira vez que você recebe um aviso de violação desta licença (para qualquer
              trabalho) desse detentor dos direitos autorais, e você sanar a violação antes de 30 dias após o
              recebimento da notificação.


              A rescisão de seus direitos sob esta seção não rescinde as licenças das partes que receberam
              cópias ou direitos de você sob esta Licença. Se seus direitos foram rescindidos e não restabelecidos
              permanentemente, o recebimento de uma cópia de alguns ou de todos os




               mesmo material não lhe dá nenhum direito de uso.

          10. FUTURAS REVISÕES DESTA LICENÇA



               A Free Software Foundation pode publicar novas versões revisadas da Licença de Documentação Livre
               GNU de tempos em tempos. Essas novas versões serão semelhantes em espírito à versão atual, mas
               podem diferir em detalhes para abordar novos problemas ou preocupações. Consulte <https://www.gnu.org/
               licenses/>.



               Cada versão da Licença recebe um número de versão distinto. Se o Documento especificar que
               uma determinada versão numerada desta Licença “ou qualquer versão posterior” se aplica a ela,
               você tem a opção de seguir os termos e condições dessa versão especificada ou de qualquer versão
               posterior que tenha sido publicada (não como um rascunho) pela Free Software Foundation. Se o
               Documento não especificar um número de versão desta Licença, você pode escolher qualquer
               versão já publicada (não como rascunho) pela Free Software Foundation. Se o Documento especificar que
               um procurador pode decidir quais versões futuras desta Licença podem ser usadas, a declaração pública de
               aceitação de uma versão desse procurador o autoriza permanentemente a escolher essa versão para
               o Documento.




          11. RELICENCIAMENTO


              “Site Massive Multiauthor Collaboration” (ou “Site MMC”) significa qualquer servidor da World Wide Web que
              publica trabalhos protegidos por direitos autorais e também fornece recursos proeminentes para qualquer
              pessoa editar esses trabalhos. Um wiki público que qualquer um pode editar é um exemplo de tal servidor.

              Uma “Colaboração Multiautor Massiva” (ou “MMC”) contida no site significa qualquer conjunto de obras
              protegidas por direitos autorais publicadas no site MMC.


               “CC-BY-SA” significa a licença Creative Commons Attribution-Share Alike 3.0 publicada pela Creative
               Commons Corporation, uma corporação sem fins lucrativos com sede em San Francisco, Califórnia, bem
               como futuras versões copyleft dessa licença publicada por essa mesma organização.




               “Incorporar” significa publicar ou republicar um Documento, no todo ou em parte, como parte de outro
               Documento.

              Um MMC é “elegível para relicenciamento” se for licenciado sob esta Licença e se todos os trabalhos que
              foram publicados pela primeira vez sob esta Licença em algum lugar diferente deste MMC e
              posteriormente incorporados no todo ou em parte ao MMC, (1) não tinham textos de capa
              ou seções invariantes e (2) foram incorporados antes de 1º de novembro de 2008.




               O operador de um Site MMC pode republicar um MMC contido no site sob CC-BY-SA no mesmo site a
               qualquer momento antes de 1º de agosto de 2009, desde que o MMC seja elegível para novo licenciamento.



       ADENDO: Como usar esta Licença para seus documentos
       ==================================================== ==


       Para usar esta Licença em um documento que você escreveu, inclua uma cópia da Licença no documento e
       coloque os seguintes avisos de direitos autorais e licença logo após a página de título:



                  Copyright (C) ANO SEU NOME.
                  É concedida permissão para copiar, distribuir e/ou modificar este documento sob os termos da GNU Free
                  Documentation License, Versão 1.3 ou qualquer versão posterior publicada pela Free Software Foundation;





                        sem seções invariantes, sem textos de capa frontal e sem textos de contracapa. Uma cópia
                        da licença está incluída na seção intitulada ``GNU Free Documentation License''.


           Se você tiver Seções Invariantes, Textos de Capa Frontal e Contracapa
       Textos, substitua o “com... Textos”. linha com isso:

                          com as Seções Invariantes sendo LISTA DE SEUS TÍTULOS, com os Textos da Capa Frontal
                          sendo LISTA, e com os Textos da Contracapa sendo LISTA.



          Se você tiver Seções Invariantes sem Textos de Capa, ou algum outro
       combinação das três, mescle essas duas alternativas para se adequar à situação.


            Se o seu documento contiver exemplos não triviais de código de programa, recomendamos
       liberar esses exemplos em paralelo sob sua escolha de licença de software livre, como a GNU
       General Public License, para permitir seu uso em software livre.


       Arquivo: sed.info, Nó: Índice de conceitos, Próximo: Índice de comandos e opções, Anterior: Licença de documentação gratuita
       GNU, Acima: Início

       Índice de Conceitos
        *************

       Este é um índice geral de todos os problemas discutidos neste manual, com exceção dos comandos
       'sed' e opções de linha de comando.

        *   Cardápio:

        *                                                                Visão geral. (linha 46) visão geral do script
           -e, exemplo: -e,
        *
           exemplo <1>: * –                                              sed. (linha 37)
        expressão, exemplo: * -f,                                        Visão geral. (linha 46)
        exemplo: * -f,                                                   Visão geral. (linha 46) visão geral do script
        exemplo <1>: * –arquivo,                                         sed. (linha 37)
        exemplo: * -i, exemplo:                                          Visão geral. (linha 46)
        -n, exemplo : -s,                                                Visão geral. (linha 26)
        *                                                                Visão geral. (linha 33)
           exemplo: 0
        *                                                                Visão geral. (linha 40)
           endereço: ;,
        * separador de
                                                                         Relatando erros. (linha 114) visão geral do
        *
           comando: a, e ponto-e-                                        script sed. (linha 37) visão geral do script
        *
           vírgula: * Leitura                                            sed. (linha 56)
        adicional sobre sed: ADDR1,+N:                                   Outros recursos. (linha 13)
        *
           ADDR1,~N:                                                     Endereços de intervalo. (linha 31)
        *
           * intervalo                                                   Endereços de intervalo. (linha 31) visão
        de endereços, exemplo: *                                         geral do script sed. (linha 23)
        Endereço, como uma expressão regular: *                          Endereços Regexp. (linha 13)
        Endereço, última linha: *                                        Endereços Numéricos. (linha 13)
        Endereço, numérico: *                                            Endereços Numéricos. (linha 8)
        endereços, excluindo: *                                          Visão geral de endereços. (linha 33)
        Endereços, em scripts sed: *                                     Endereços Numéricos. (linha 6)
        endereços, negando: *                                            Visão geral de endereços. (linha 33)
        endereços, numérico: *                                           Visão geral de endereços. (linha 6)
        endereços, intervalo: *                                          Visão geral de endereços. (linha 26)
        endereços, expressão regular: * endereços,                       Visão geral de endereços. (linha 20) visão
        sintaxe: * alfabético                                            geral do script sed. (linha 13)
        personagens: Expressões.                                         Classes de caracteres e suporte


                                                                                                            (linha 49)
       * caracteres alfanuméricos:                                       Classes de caracteres e suporte
       Expressões.
                                                                                                            (linha 44)




        * Anexar espaço de retenção ao espaço do padrão:        Outros Comandos.                (linha 288)
        * Anexar a próxima linha de entrada ao espaço do padrão: Outros comandos.               (linha 261)
        * Acrescentar espaço padrão para conter espaço: *       Outros Comandos. (linha 280)
        Acrescentar texto após uma linha: * b,                  Outros Comandos. (linha 45)
        unir linhas com:                                        Ramificação e controle de fluxo.
                                                                                                (linha 150)
        * b, contra t:                                          Ramificação e controle de fluxo.
                                                                                                (linha 150)
        * referência anterior:                                  Referências anteriores e Subexpressões. (linha
                                                                                                6) (linha 18)
        * Referências anteriores, em expressões regulares: O comando "s". * caracteres
        em branco: Expressões.                                  Classes de caracteres e suporte


                                                                                                     (linha 54)
       * expressão de colchetes:                                   Classes de caracteres e suporte
       Expressões.
                                                                                                   (linha 6)
        * Ramificação para um rótulo, se s/// falhou: *          Comandos Estendidos. (linha 63)
        Ramificação para um rótulo, se s/// foi bem-sucedido: Comandos de Programação.
                                                                                             (linha 22)
        * Ramifique para um rótulo, incondicionalmente:          Comandos de Programação.
                                                                                                  (linha 18)
        * ramificação e n, N:                                    Ramificação e controle de fluxo.
                                                                                                   (linha 105)
        * ramificação, loop infinito:                            Ramificação e controle de fluxo.
                                                                                                   (linha 95)
        * ramificação, juntando linhas:                          Ramificação e controle de fluxo.
                                                                                                   (linha 150)
        * Espaços de buffer, padrão e retenção: Bugs,            Ciclo de Execução. (linha 6)
        *
           relatórios: ce ponto-e-                               Relatando erros. (linha 6) visão geral do
        *
           vírgula: não diferencia                               script sed. (linha 56) (linha 47)
        *
           maiúsculas de minúsculas, expressão regular: Regexp Addresses.
        * Correspondência sem distinção entre                    O comando "s". (linha 117)
        * maiúsculas e minúsculas: Advertência —                 Comandos Comuns. (linha 20)
        #n na primeira linha: * classe                             Classes de caracteres e suporte
       de caractere: Expressões.
                                                                                                     (linha 6)
       * classes de caracteres:                                    Classes de caracteres e suporte
       Expressões.
                                                                                                     (linha 43)
       * classes de personagens:                                   Classes de caracteres e suporte
       Expressões.
                                                                                               (linha 43)
        * Grupos de comando:                                       Comandos Comuns. (linha 91)
        *                                                          Comandos Comuns. (linha 12)
           Comentários, em scripts:
        * Ramificação condicional:                                 Comandos de Programação.
                                                                                              (linha 22)
       * Ramificação condicional <1>: *                            Comandos Estendidos. (linha 63)
       caracteres de controle:                                     Classes de caracteres e suporte
       Expressões.
                                                                                                 (linha 57)
        *                                                          Outros Comandos. (linha 284)
          Copie o espaço de retenção no espaço do padrão:
        *                                                          Outros Comandos. (linha 276)
          Copie o espaço do padrão para o espaço de
        espera: * ciclo, reiniciando:                              Ramificação e controle de fluxo.
                                                                                                 (linha 75) *
        d, exemplo: visão geral do script sed. (linha 23)
        * Exclua a primeira linha do espaço padrão: Outros Comandos. (linha 255) * caracteres de dígitos:
        classes de caracteres e expressões de colchetes.

                                                                                                     (linha 62)
        * Desativando a impressão automática, na linha de comando: Opções de linha de
                                                                                          comando. (linha 23)
        *
           expressão regular vazia:                                Endereços Regexp. (linha 22)
        * Esvaziar o espaço padrão:                                Comandos Estendidos. (linha 85)




        * Esvaziando espaço padrão <1>: *                          Relatando erros. (linha 143)
        Avaliar comandos Bourne-shell: * Avaliar                   Comandos Estendidos. (linha 12)
        comandos Bourne-shell, após substituição: O comando "s". (linha 108) * exemplo, intervalo de
                                                                                                   endereços:
        visão geral do script sed. (linha 23) * exemplo, expressão regular: visão geral do script sed. (linha 28)

        * Troca de espaço de retenção com espaço de padrão: Outros Comandos. (linha 292)
        * Excluindo linhas: visão geral de endereços. (linha 33) * status de saída: Status de saída. (linha 6) *
        status de saída, exemplo: status de saída. (linha 25)

        * Expressões regulares estendidas, escolhendo: Opções de linha de comando. (linha
                                                                                           135) (linha 6)
        * Expressões regulares estendidas, sintaxe: sintaxe ERE.
        * Nome do arquivo, impressão:                            Comandos Estendidos. (linha 30)
        * Arquivos a serem processados como entrada:             Opções de linha de comando.
                                                                                             (linha 181)
        * Fluxo de controle em scripts:                          Comandos de Programação.
                                                                                            (linha 11)
        * Substituição global:                                   O comando "s".              (linha 74)
        *                                                        O comando "s".
           Extensões GNU, arquivo /dev/stderr: (linha 101)
        *
           Extensões GNU, arquivo /dev/stderr <1>: Outros Comandos. (linha 244)
        *
           Extensões GNU, arquivo /dev/stdin: Outros Comandos. (linha 227)
        *
           Extensões GNU, arquivo /dev/stdin <1>: Comandos estendidos. (linha 53)
        *
           Extensões GNU, arquivo /dev/stdout:                   Opções de linha de comando.
                                                                                             (linha 189)
        *
           Extensões GNU, arquivo /dev/stdout <1>: O comando "s". (linha 101)
        *
           Extensões GNU, arquivo /dev/stdout <2>: Outros comandos. (linha 244)
        *
           Extensões GNU, endereço 0: Endereços de intervalo. (linha 31)
        *
           Extensões GNU, 0 endereço <1>: Reportando Bugs. (linha 114)
        *
           Extensões GNU, 0, endereçamento ADDR2: Endereços de intervalo. (linha 31)
        *
           Extensões GNU, endereçamento ADDR1,+N: Endereços de intervalo. (linha 31)
        *
           Extensões GNU, endereçamento ADDR1,~N: Endereços de intervalo. (linha 31)
        *
           Extensões GNU, ramificação se s/// falhou: Comandos Estendidos. (linha 63)
        *
           Extensões GNU, modificadores de maiúsculas e minúsculas em comandos s: O comando
                                                                                             "s". (linha 29)
        *
           Extensões GNU, verificando sua presença: Comandos estendidos. (linha 69)
        *
            Extensões GNU, depurar:                                 Opções de linha de comando.
                                                                                                   (linha 29)
        *
            Extensões GNU, desativando:                             Opções de linha de comando.
                                                                                                   (linha 102)
        *
          Extensões GNU, esvaziando o espaço padrão: Comandos Estendidos. (linha 85)
        *
          Extensões GNU, esvaziando o espaço padrão <1>: Reportando Bugs. (linha 143)
        *
          Extensões GNU, avaliando comandos Bourne-shell: O comando "s". (linha 108)
        *
            Extensões GNU, avaliando comandos Bourne-shell <1>: Comandos Estendidos.
                                                                                            (linha 12)
        *
            Extensões GNU, expressões regulares estendidas: opções de linha de comando. (linha 135)
        *
          Extensões GNU, g e modificador NUMBER: O comando "s". (linha 80)
        *
          Extensões GNU, modificador I: O comando "s". (linha 117)
        *
          Extensões GNU, modificador <1>: Endereços Regexp. (linha 47)
        *
          Extensões GNU, edição no local: opções de linha de comando. (linha 56) (linha 95)
                                                                                                 (linha 122)
        *
          Extensões GNU, edição local <1>: Reportando Bugs.                                        (linha 75)
        *
          Extensões GNU, modificador M: O comando "s".
        *
          Extensões GNU, modificador M <1>: Endereços Regexp.
        *
          Extensões GNU, modificadores e a expressão regular vazia: Regexp Addresses.
                                                                                          (linha 22)
        *
          Extensões GNU, endereços N~M:                       Endereços Numéricos. (linha 18)
        *
          extensões GNU, saindo silenciosamente:              Comandos Estendidos. (linha 36)
        *
          extensões GNU, comando R:                           Comandos Estendidos. (linha 53)
        *
          extensões GNU, lendo um arquivo uma linha por vez: Comandos estendidos. (linha 53)




        *
          Extensões GNU, retornando um código de saída: Common Commands. (linha 28)
        *
          Extensões GNU, retornando um código de saída <1>: Comandos estendidos. (linha
                                                                                             36)
        *
            Extensões GNU, definindo o comprimento da linha: Outros Comandos. (linha 207)
        *
            Extensões GNU, escapes especiais: Escapes. (linha 6)
        *
            Extensões GNU, escapes especiais <1>: Reportando Bugs. (linha 88)
        *
            Extensões GNU, formulários especiais de dois endereços: Endereços de intervalo. (linha 31)
        *
            Extensões GNU, subprocessos: O comando "s". (linha 108)
        *
            Extensões GNU, subprocessos <1>: Comandos Estendidos. (linha 12)
        *
            Extensões GNU, para expressões regulares básicas: sintaxe BRE. (linha 13)
        *
            Extensões GNU, para expressões regulares básicas <1>: sintaxe BRE. (linha 59)
        *
            Extensões GNU, para expressões regulares básicas <2>: sintaxe BRE. (linha 62)
        *
            Extensões GNU, para expressões regulares básicas <3>: sintaxe BRE. (linha 77)
        *
            Extensões GNU, para expressões regulares básicas <4>: sintaxe BRE. (linha 87)
        *
            Extensões GNU, para expressões regulares básicas <5>: Reportando Bugs. (linha 61)
        *
          Extensões GNU, dois endereços suportados pela maioria dos comandos: Outros Comandos.
                                                                                              (linha 61)
       *
          Extensões GNU, dois endereços suportados pela maioria dos comandos <1>: Outros Comandos.
                                                                                              (linha 115)
       *
          Extensões GNU, dois endereços suportados pela maioria dos comandos <2>: Outros Comandos.
                                                                                              (linha 204)
       *
          Extensões GNU, dois endereços suportados pela maioria dos comandos <3>: Outros Comandos.
                                                                                              (linha 236)
       *
          Extensões GNU, comprimento de linha ilimitado: Limitações. (linha 6)
       *
          Extensões GNU, escrevendo a primeira linha em um arquivo: Comandos Estendidos.
                                                                                              (linha 80)
       *
          Goto, em scripts:                                   Comandos de Programação.
                                                                                              (linha 18)
       * caracteres gráficos:                                 Classes de caracteres e suporte
       Expressões.
                                                                                              (linha 65)
       * Correspondência de expressão regular                 Sintaxe BRE.                    (linha 113)
       gananciosa: * Comandos                                 Comandos Comuns. (linha 91)
       de agrupamento: * Dígitos                              Classes de caracteres e suporte
       hexadecimais: Expressões.
                                                                                              (linha 88)
       * Manter espaço, acrescentando do espaço padrão: Outros Comandos. (linha 280)
       * Mantenha o espaço, acrescentando ao espaço do padrão: Outros Comandos. (linha 288)
       * Segure o espaço, copie no espaço do padrão: Outros Comandos. (linha 284)
       * Mantenha o espaço, copiando o espaço do padrão em: Outros Comandos. (linha 276)
       * Espaço Hold, definição: Ciclo de Execução. (linha 6)
       * Segure espaço, troque com espaço padrão: Outros Comandos. (linha 292) * i, e ponto e vírgula:
       visão geral do script sed. (linha 56)
       * Edição no local: Relatando erros. (linha 95)
       * Edição no local, ativando: Opções de linha de comando. (linha 56)

        * Edição no local, nomes de arquivos de backup no estilo Perl: Opções de linha de comando.
                                                                                             (linha 67)
        * loop infinito, ramificação:                           Ramificação e controle de fluxo.
                                                                                             (linha 95)
        * Inserir texto antes de uma linha: * Unir              Outros Comandos. (linha 104)
        linhas com ramificação:                                 Ramificação e controle de fluxo.
                                                                                             (linha 150)
        * juntando linhas citadas imprimíveis:                  Ramificação e controle de fluxo.
                                                                                             (linha 150)
        * etiquetas:                                            Ramificação e controle de fluxo.
                                                                                             (linha 75)
        * Rótulos, em scripts:                                  Comandos de Programação.
                                                                                             (linha 14)




        *
            Última linha, selecionando:                              Endereços Numéricos. (linha 13)
        * Comprimento da linha, configuração:                        Opções de linha de comando.
                                                                                                   (linha 97)
        * Comprimento da linha, configuração <1>: Outros comandos. (linha 207)
        * Número da linha, imprimindo: Outros Comandos. (linha 194)
        * Seleção de linha: Endereços Numéricos. (linha 6)
        * Linha, selecionando por número: Endereços Numéricos. (linha 8)
        * Linha, selecionando por correspondência de expressão regular: Regexp Addresses. (linha 13)

        * Linha, selecionando por último: *                           Endereços Numéricos. (linha 13)
        Espaço padrão de lista: * Letras                              Outros Comandos. (linha 207)
        minúsculas: Expressões.                                       Classes de caracteres e suporte


                                                                                                        (linha 68)
        * Misturando modificadores g e NUMBER no comando s: O comando "s". (linha 80)

        * vários arquivos: * vários                                   Visão geral. (linha 40) visão geral do script sed.
        comandos sed: n e ramificação:                                (linha 37)
        *
                                                                      Ramificação e controle de fluxo. (linha
                                                                                                       105)
        *
            N, e ramificação:                                         Ramificação e controle de fluxo. (linha
                                                                                                       105)
        * classes de caracteres nomeados:                             Classes de caracteres e suporte
       Expressões.
                                                                                                      (linha 43) visão
        * nova linha, separador de comando:                           geral do script sed. (linha 37)
        *
           Na próxima linha de entrada, acrescente ao espaço padrão: Outros Comandos. (linha 261)
        *
           Na próxima linha de entrada, substitua o espaço do padrão por: Comandos comuns. (linha 61)

        * Non-bugs, 0 address: Reporting Bugs. (linha 114)
        * Não-bugs, edição no local: Reportando Bugs. (linha 95)
        * Não-bugs, relacionados à localização: relatando bugs. (linha 124)
        * Não-bugs, relacionados à localização <1>: Reportando Bugs. (linha 143)
        * Não-bugs, comando N na última linha: Reportando Bugs. (linha 30)
        * Não-bugs, conflitos de sintaxe regex: Reportando Bugs. (linha 61) * endereços numéricos: Visão geral de
        endereços. (linha 6) * caracteres numéricos: classes de caracteres e expressões de colchetes.



                                                                                                       (linha 62)
        * omitindo rótulos:                                           Ramificação e controle de fluxo. (linha 75)
        *                                                             Visão geral. (linha 26)
           saída:
        *                                                             Visão geral. (linha 33)
           saída, supressão: p, exemplo:
        *                                                             Visão geral. (linha 33)
           * parágrafos,
        processamento:                                                Técnicas multilinha. (linha 53)
                                                                                                    (linha 46) (linha
        *                                                              Visão geral.
          Parâmetros, script:                                                                           18) (linha 6)
       * Substrings entre parênteses:                                  O comando "s".                   (linha 15)
       *
          Espaço padrão, definição:                                     Ciclo de Execução.              (linha 6) (linha
       * Portabilidade, comentários: Comandos Comuns.                                                   30)
       * Portabilidade, limitações de comprimento de linha: Limitações.
       * Portabilidade, comando N na última linha: Relatando Bugs.
       *
          Comportamento POSIXLY_CORRECT, expressões entre colchetes: classes de caracteres e expressões entre
       colchetes.
                                                                                                        (linha 112)
       *
          Comportamento POSIXLY_CORRECT, permitindo:                    Opções de linha de comando.
                                                                                                    (linha 105)
       *
          Comportamento POSIXLY_CORRECT, escapa: (linha 11) Fugas.
       *
          Comportamento POSIXLY_CORRECT, comando N: Relatando Bugs. (linha 56)
       * Imprimir a primeira linha do espaço padrão: Outros Comandos. (linha 273) * caracteres imprimíveis: classes
       de caracteres e expressões de colchetes.

                                                                                                     (linha 72)
        * Nome do arquivo de impressão:                               Comandos Estendidos. (linha 30)





        * Número da linha de impressão:                               Outros Comandos. (linha 194)
        * Imprimindo texto de forma inequívoca: *                     Outros Comandos. (linha 207)
        Processando parágrafos:                                       Técnicas multilinha. (linha 53)

       * caracteres de pontuação:                                     Classes de caracteres e suporte
       Expressões.
                                                                                                     (linha 75)
        *                                                             Estado de saída. (linha 25) visão geral do
           Q, exemplo: q,
        *
           exemplo:                                                   script sed. (linha 28)
        * Desistir:                                                   Comandos Comuns. (linha 28)
        * Saindo <1>: * linhas                                        Comandos Estendidos. (linha 36)
        imprimíveis entre aspas, juntando:                            Ramificação e controle de fluxo. (linha
                                                                                                     150)
       *
         endereços de intervalo:                                      Visão geral de endereços. (linha 26)
       *                                                              Classes de caracteres e suporte
         expressão de intervalo:
       Expressões.
                                                                                                   (linha 18)
        *
           Gama de linhas:                                          Endereços de intervalo. (linha 6)
        *
           Faixa com endereço inicial zero:                         Endereços de intervalo. (linha 31)
        * Leia a próxima linha de entrada:                          Comandos Comuns. (linha 61)
        * Leia o texto de um arquivo:                               Outros Comandos. (linha 219)
        * Leia o texto de um arquivo <1>:                           Comandos Estendidos. (linha 53)
        *
            endereços regex e linhas de entrada:                    Endereços Regexp. (linha 84)
        *
            endereços regex e espaço padrão:                        Endereços Regexp. (linha 84) * endereços
        de expressão regular: visão geral de endereços. (linha 20) * expressão regular, exemplo: visão geral do
        script sed. (linha 28)
        * Substitua o espaço de espera pela cópia do espaço padrão: Outros Comandos. (linha 276)

        * Substitua o espaço do padrão pela cópia do espaço de espera: Outros Comandos. (linha
                                                                                                 284)
        * Substituindo todo o texto correspondente ao regexp em uma linha: o comando "s". (linha
                                                                                                 74)
        * Substituindo apenas a enésima correspondência de regexp em uma linha: o comando "s".
                                                                                                 (linha 78)
        * Substituindo as linhas selecionadas por outro texto: Outros Comandos. (linha 157)
        * Requer GNU sed: Comandos Estendidos. (linha 69) * reiniciando um ciclo: Ramificação e controle de
        fluxo. (linha 75)

        * Modo caixa de areia:                                        Opções de linha de comando.
                                                                                                       (linha 157)
        * parâmetro do script:                                         Visão geral. (linha 46) visão geral do script
        * Estrutura do roteiro:                                        sed. (linha 6)
        * Script, de um arquivo:                                       Opções de linha de comando.
                                                                                                       (linha 51)
        * Script, da linha de comando:                                 Opções de linha de comando.
                                                                                                       (linha 46) *
        sintaxe dos comandos sed: visão geral do script sed. (linha 13) * comandos sed, múltiplos: visão geral
        do script sed. (linha 37) * estrutura do script sed: visão geral do script sed. (linha 6)

        * Seleção das linhas a serem processadas: Endereços Numéricos. (linha 6)
        * Seleção de linhas não correspondentes: visão geral de endereços. (linha 33) * ponto-e-vírgula,
        separador de comando: visão geral do script sed. (linha 37)
        * Várias linhas, selecionando: Range Addresses. (linha 6)
        * Caractere de barra, em expressões regulares: Regexp Addresses. (linha 32) caracteres de espaço:
        *                                                           Classes de caracteres e suporte
           Expressões.

                                                                                                         (linha 80)
        *
           Espaços, padrão e espera: (linha 6)                    Ciclo de Execução.
        * Formas de endereçamento especiais: (linha 31) * entrada Endereços
                                                                  padrão: (linha  18)
                                                                              de intervalo.
                                                                      Visão geral.
        * Entrada padrão, processando como entrada: Opções de linha de comando. (linha 183)
                                                                                                        (linha 26) (linha
        * saída padrão: * stdin:                                      Visão geral.                        18)
                                                                      Visão geral.




        * saída padrão:                                         Visão geral. (linha 26)
        * Editor de fluxo: *                                    Introdução. (linha 6)
        subexpressão:                                           Referências anteriores e Subexpressões. (linha
                                                                                               6)
        * Subprocessos:                                         O comando "s". (linha 108)
        * Subprocessos <1>:                                     Comandos Estendidos. (linha 12)
        * Substituição de texto, opções: * supressão            O comando "s". (linha 70)
        de saída: sintaxe, endereços:                           Visão geral. (linha 33) visão geral do script
        *
           sintaxe, comandos sed:                               sed. (linha 13) visão geral do script sed.
        *
           t, junção de linhas com:                             (linha 13)
        *
                                                                Ramificação e controle de fluxo.
                                                                                               (linha 150)
        *
           t, contra b:                                         Ramificação e controle de fluxo.
                                                                                               (linha 150)
        *                                                       Outros Comandos.
           Texto, anexando: (linha 45)
        *                                                       Comandos Comuns.
           Texto, deletando: (linha 44)
        *                                                       Outros Comandos.
           Texto, inserção: (linha 104)
        *                                                       Comandos Comuns.
           Texto, impressão: (linha 52)
        *                                                       O  comando "s".
           Texto, impressão após substituição: (linha 88)
        *
           Texto, gravando em um arquivo após a substituição: O comando "s". (linha 101)

        * Transliteração:                                                   Outros Comandos. (linha 11)
        * E/S sem buffer, escolhendo:                                       Opções de linha de comando.
                                                                                                              (linha 164)
        *                                                                   Classes de caracteres e suporte
         letras maiúsculas:
       Expressões.
                                                                                                              (linha 84)
        *
            Resumo de uso, impressão:                                       Opções de linha de comando.
                                                                                                              (linha 17)
        * Versão, impressão:                                                Opções de linha de comando.
                                                                                                              (linha 13)
        * Espaços em branco: Expressões.                                    Classes de caracteres e suporte


                                                                                                              (linha 80)
        * Trabalhando em arquivos separados:                                Opções de linha de comando.
                                                                                                        (linha 148)
       * Escreva a primeira linha em um                                     Comandos Estendidos. (linha 80)
       arquivo: * Escreva em                                                Outros Comandos. (linha 244)
       um arquivo: * xdigit                                                 Classes de caracteres e suporte
       class: Expressions.
                                                                                                              (linha 88)
        * Endereço zero:                                                    Endereço zero.                    (linha 6)
        *
          Zero, como endereço inicial do intervalo:                         Endereços de intervalo.           (linha 31)

        Arquivo: sed.info, Nó: Índice de comandos e opções, Anterior: Índice de conceitos, Acima: Início

       Índice de comandos e opções
        ************************

       Esta é uma lista alfabética de todos os comandos 'sed' e opções de linha de comando.



        *   Cardápio:

        *                                                                   Comandos Comuns. (linha 12)
            # (comentários):
        * --binary:                                                         Opções de linha de comando.
                                                                                                        (linha 114)
        * --depurar:                                                        Opções de linha de comando.
                                                                                                        (linha 29)
        * --expressão:                                                      Opções de linha de comando.
                                                                                                        (linha 46)
        * --arquivo:                                                        Opções de linha de comando.
                                                                                                        (linha 51)




        * --follow-symlinks:                            Opções de linha de comando.
                                                                                           (linha 125)
        * --ajuda:                                      Opções de linha de comando.
                                                                                           (linha 17)
        * --no lugar:                                   Opções de linha de comando.
                                                                                           (linha 56)
        * --comprimento da linha:                       Opções de linha de comando.
                                                                                           (linha 97)
        * --null-data:                                  Opções de linha de comando.
                                                                                           (linha 172)
        * --posix:                                      Opções de linha de comando.
                                                                                           (linha 102)
        * --quieto:                                     Opções de linha de comando.
                                                                                           (linha 23)
        * --regexp-extended:                            Opções de linha de comando.
                                                                                           (linha 135)
        * --caixa de areia:                             Opções de linha de comando.
                                                                                           (linha 157)
        *
            --separado:                                 Opções de linha de comando.
                                                                                           (linha 148)
        * --silencioso:                                 Opções de linha de comando.
                                                                                           (linha 23)
        * --sem buffer:                                 Opções de linha de comando.
                                                                                           (linha 164)
        * --versão:                                     Opções de linha de comando.
                                                                                           (linha 13)
        * --terminado em zero:                          Opções de linha de comando.
                                                                                           (linha 172)
        * -b:                                           Opções de linha de comando.
                                                                                           (linha 114)
        * -e:
                                                        Opções de linha de comando.
                                                                                           (linha 46)
        * -E:
                                                        Opções de linha de comando.
                                                                                           (linha 135)
        * -f:                                           Opções de linha de comando.
                                                                                           (linha 51)
        * -eu:                                          Opções de linha de comando.
                                                                                           (linha 56)
        * -eu:                                          Opções de linha de comando.
                                                                                           (linha 97)
        * -n:
                                                        Opções de linha de comando.
                                                                                           (linha 23)
        *                                               Comandos Comuns. (linha 20)
          -n, forçando de dentro de um script: -r:
        *
                                                        Opções de linha de comando.
                                                                                           (linha 135)
        * -s:
                                                        Opções de linha de comando.
                                                                                           (linha 148)
        *   -você:                                      Opções de linha de comando.
                                                                                           (linha 164)
        * -z:
                                                        Opções de linha de comando.
                                                                                           (linha 172)
        *
            : (rótulo) comando:                         Comandos de Programação.
                                                                                    (linha 14)
        *                                               Outros Comandos. (linha 194)
           = (imprimir número da linha) comando: * {}
        agrupamento de comandos: a                      Comandos Comuns. (linha 91)
        *                                               Outros Comandos. (linha 45)
           (anexar linhas de texto) comando: * alnum
        classe de caracteres: Expressões.               Classes de caracteres e suporte


                                                                                           (linha 44)
       * classe de caracteres alfa:                     Classes de caracteres e suporte
       Expressões.
                                                                                           (linha 49)
        * b (ramificação) comando:                      Comandos de Programação.
                                                                                          (linha 18)




       * classe de caracteres em                               Classes de caracteres e suporte
       branco: Expressões.
                                                                                          (linha 54)
        *                                                      Outros Comandos. (linha 157)
         c (mudar para linhas de texto) comando: *
       cntrl classe de caracteres:                             Classes de caracteres e suporte
       Expressões.
                                                                                          (linha 57)
        *                                                      Outros Comandos. (linha 255)
         Comando D (excluir primeira linha): *
       comando d (excluir): * classe                           Comandos Comuns. (linha 44)
       de caractere de dígito:                                 Classes de caracteres e suporte
       Expressões.
                                                                                          (linha 62)
        *
          e (avaliar) comando: F                               Comandos Estendidos. (linha 12)
        *
          (nome do arquivo) comando:                           Comandos Estendidos. (linha 30)
        *                                                      Outros Comandos. (linha 288)
          G (anexar Get) comando: g (get)
        *                                                      Outros Comandos. (linha 284)
          comando: * classe de
        caractere gráfico: Expressões.                         Classes de caracteres e suporte


                                                                                          (linha 65)
        *                                                      Outros Comandos. (linha 280)
           H (acrescentar Hold) comando:
        * h (hold) comando: * i                                Outros Comandos. (linha 276)
        (inserir linhas de texto) comando: * l (listar         Outros Comandos. (linha 104)
        de forma inequívoca) comando: * classe de              Outros Comandos. (linha 207)
        caractere inferior: Expressões.                        Classes de caracteres e suporte


                                                                                          (linha 68)
       *                                                       Outros Comandos. (linha 261)
         N (anexar próxima linha) comando: n
       *                                                       Comandos Comuns. (linha 61)
         (próxima linha) comando: P
       *                                                       Outros Comandos. (linha 273)
         (imprimir primeira linha) comando: p
       *                                                       Comandos Comuns. (linha 52)
         (imprimir) comando: *
       imprimir classe de caractere:                           Classes de caracteres e suporte
       Expressões.
                                                                                                 (linha 72)
        *                                                      Classes de caracteres e suporte
         classe de caractere punct:
       Expressões.
                                                                                          (linha 75)
        *                                                      Comandos Comuns. (linha 28)
         q (sair) comando: Q
        *
         (silencioso Sair) comando: r (ler                     Comandos Estendidos. (linha 36)
        *                                                      Outros Comandos. (linha 219)
         arquivo) comando: R (ler
        *
         linha) comando: s comando,                            Comandos Estendidos. (linha 53)
        *                                                      O comando "s". (linha 70)
         sinalizadores de opção: espaço
        *                                                      Classes de caracteres e suporte
         classe de caractere:
       Expressões.
                                                                                          (linha 80)
        *
          Comando T (testar e ramificar se falhou): Comandos estendidos. (linha 63) Comando t (teste e
        *
          desvio se for bem-sucedido): Comandos de Programação. (linha 22)
        *                                                      Classes de caracteres e suporte
         classe de caractere superior:
       Expressões.
                                                                                          (linha 84)
        *
          v (versão) comando: w                                Comandos Estendidos. (linha 69)
        *                                                      Outros Comandos. (linha 244)
          (gravar arquivo) comando: W
        *
          (gravar primeira linha) comando: x                   Comandos Estendidos. (linha 80)
        *                                                      Outros Comandos. (linha 292)
          (eXchange) comando: *
        xdigit character class: Expressions.                   Classes de caracteres e suporte


                                                                                           (linha 88)
        *                                                      Outros Comandos. (linha 11)
          y (transliterar) comando: z (Zap)
        * comando:                                             Comandos Estendidos. (linha 85)
