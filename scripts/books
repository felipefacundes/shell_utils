#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes


: <<'DOCUMENTATION'
This Bash script is designed to manage and display a list of books stored in a specified directory, allowing users to read them in various formats.

Purpose:
The script provides a user-friendly interface for selecting and reading books in formats such as PDF, TXT, and EPUB.

Strengths:
1. Format Support: Handles multiple book formats (PDF, TXT, EPUB).
2. User  Interaction: Prompts users to select a book by number, enhancing usability.
3. Error Handling: Includes checks for valid input and format recognition.
4. Temporary File Management: Converts PDF files to text for easier reading.
5. Clear Output: Uses 'less' for paginated viewing of book content.

Capabilities:
- Lists available books in the specified directory.
- Reads and displays the content of selected books based on their format.
- Provides a clean exit option for users.
DOCUMENTATION

# Capture Ctrl+C and end children processes
#trap '(kill -TERM -- -$$) &>/dev/null' INT TERM SIGHUP SIGQUIT SIGABRT SIGALRM
trap '(kill -TERM -- -$$) &>/dev/null' SIGINT SIGTERM SIGHUP SIGQUIT #EXIT

clear

SCRIPT="${0##*/}"
TMPDIR="${TMPDIR:-/tmp}"
TMPBOOKDIR="${TMPDIR}/${SCRIPT%.*}"
XDG_DOCUMENTS_DIR=${XDG_DOCUMENTS_DIR:-$(xdg-user-dir DOCUMENTS 2>/dev/null || echo "$HOME/Documents")}

# Setting the eBook folders
books_folder="${HOME}/.shell_utils/books"
xdg_books_folder="${XDG_DOCUMENTS_DIR}/Books"

[[ -d "${TMPBOOKDIR}" ]] && rm -rf "${TMPBOOKDIR}"
[[ ! -d "${TMPBOOKDIR}" ]] && mkdir -p "${TMPBOOKDIR}"
[[ ! -d "${xdg_books_folder}" ]] && mkdir -p "${xdg_books_folder}"

# Combining the two folders to get all ebooks
books_list=("${books_folder}"/*.* "${xdg_books_folder}"/*.*)

# ANSI color for highlighting the selected book
red="\033[1;31m"
highlight="\033[44;1;32m"  # Cyan background, bold green text
nc="\033[0m"  # Reset

# Function to display books list
display_books() {
    local list=()
    if [[ -n "$1" ]]; then
        list=("${filtered_books[@]}")
    else
        list=("${books_list[@]}")
    fi
    
    number=0
    for book in "${list[@]}"; do
        if [[ $number -eq $selected ]]; then
            echo -e "$highlight$number)    ${book}$nc"
        else
            echo -e "$number)    ${book}"
        fi
        ((number++)) || true
    done
}

_glow_no_kill() {
    local file="$1"
    env COLORTERM=8bit glow -p -s dark -- "$file" 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

markdown_reader() {
    local file="$1"
    local mr="$HOME/.shell_utils/scripts/markdown_reader.sh"
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 5 ]] && [[ -f "$mr" ]] &&
    "$mr" -nc -nf -- "$file" && return 0
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 5 ]] && command -v markdown_reader.sh &>/dev/null &&
    markdown_reader.sh -nc -nf -- "$file" && return 0
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 1 ]] && cmd_check glow glow &&
    _glow_no_kill "$file" && return 0
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 2 ]] && cmd_check bat bat &&
    env COLORTERM=8bit bat --color=always --style="plain" -- "$file" && return 0
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 3 ]] && cmd_check mdless mdless &&
    mdless -P -- "$file" && return 0
    [[ -z "$BOOKS_MARKDOWN" || "$BOOKS_MARKDOWN" == 4 ]] && cmd_check mdcat mdcat &&
    mdcat -- "$file" && return 0
}

cmd_check() {
    [[ "${#no_cmd[*]}" -gt 1 ]] && msg=$(echo "${no_cmd[*]}" | awk 'BEGIN {first=1} {for (i=1; i<=NF; i++) \
    {if (first) {printf "%s", $i; first=0} else {printf " or %s", $i}}} END {print ""}') || msg="${no_cmd[*]}"
    [[ "$1" == "-msg" ]] && echo "Install ${msg}" && no_cmd=() && exit 1
    ! command -v "$1" 1>/dev/null && no_cmd+=(\""$2"\") && return 1 || return 0
}

less_pid() {
    less -i &
    less_pid=$!
    wait "$less_pid" 
    return 0
}

margin() {
    cmd_check fold coreutils || cmd_check -msg
    cmd_check awk gawk || cmd_check -msg
    cmd_check less less || cmd_check -msg
    #fold -w 150 "$1" | sed 's/^/          /' | less -i &
    fold -w 150 "$1" | awk '{print "          " $0 "          "}' | less_pid
}

office_convert_bkp() {
    local file="$1"
    local temp_dir="${TMPBOOKDIR}/temp_book"
    local temp_file="${TMPBOOKDIR}/temp_book.txt"
    [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
    [[ -d "${temp_dir}" ]] && rm -rf "${temp_dir}"
    cmd_check pandoc pandoc && pandoc "$file" -t plain | tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}" && return 0 ||
    cmd_check libreoffice libreoffice && libreoffice --headless --convert-to txt --outdir "${temp_dir}" "$file" >/dev/null 2>&1 \
    && margin "${temp_dir}"/*.txt && return 0
    # shellcheck disable=SC2181
    [[ $? -ne 0 ]] && cmd_check -msg
}

any_file() {
    file="$1"
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    strings -n 10 "$file" 2>/dev/null | sed '/^[0-9]\{11\}/d' && return 0
}

office_convert() {
    local file="$1"
    local temp_dir="${TMPBOOKDIR}/temp_book"
    local temp_file="${TMPBOOKDIR}/temp_file.md"
    [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
    [[ -d "${temp_dir}" ]] && rm -rf "${temp_dir}"

    [[ "${ext_test}" =~ ^([Cc][Ss][Vv])$ ]] && cmd_check csvtable csvtable && csvtable "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Cc][Ss][Vv])$ ]] && cmd_check csvlook csvlook && csvlook -S "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Cc][Ss][Vv])$ ]] && awk -F, '{ printf "%-20s %-20s %-20s\n", $1, $2, $3 }' "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Cc][Ss][Vv])$ ]] && column -t -s, "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Rr][Tt][Ff])$ ]] && cmd_check catdoc catdoc && catdoc -- "$file" |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^([Rr][Tt][Ff])$ ]] && cmd_check unrtf unrtf && unrtf --text "$file" |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^([Dd][Oo][Cc])$ ]] && cmd_check antiword antiword && antiword "$file" |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^([Dd][Oo][Cc][Xx])$ ]] && cmd_check docx2txt docx2txt && docx2txt "$file" - 2>/dev/null |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^(odt|ods|odp|sxw)$ ]] && cmd_check odt2txt odt2txt && odt2txt "$file" |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^([Ss][Xx][Ww])$ ]] && cmd_check sxw2txt sxw2txt && sxw2txt "$file" |\
    tee "${temp_file}" >/dev/null 2>&1 && margin "${temp_file}"
    [[ "${ext_test}" =~ ^([Xx][Ll][Ss][Xx])$ ]] && cmd_check xlsx2csv xlsx2csv && xlsx2csv -- "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Xx][Ll][Ss][Xx])$ ]] && cmd_check xlscat xlscat && xlscat -L -R all "$file" | less_pid && return 0
    [[ "${ext_test}" =~ ^([Pp][Pp][Tt][Xx])$ ]] && cmd_check pptx2md pptx2md && pptx2md --disable-image --disable-wmf -o "$temp_file" "$file" &&
    markdown_reader "$temp_file" && return 0
    [[ "${ext_test}" =~ ^([Ee][Pp][Uu][Bb])$ ]] && cmd_check epr epr && epr -d "$file" 2>/dev/null |\
    sed '/^\s*$/d; /\[IMG:0\]/d; s/\[IMG:1\]//g' && return 0
    cmd_check pandoc pandoc && pandoc -s -t plain -- "$file" | tee "${temp_file}" >/dev/null 2>&1 &&
    margin "${temp_file}" && return 0
    cmd_check libreoffice libreoffice && libreoffice --headless --convert-to txt --outdir "${temp_dir}" "$file" >/dev/null 2>&1 &&
    margin "${temp_dir}"/*.txt && return 0 
    cmd_check -msg && echo && any_file "$file" && return 1
}

nexttmp () {
	declare new="${TMPBOOKDIR}/books.$RANDOM"
	echo "$new"
}

nodash() {
	prog="$1"
	shift
	[[ "$1" == - ]] && shift
	$prog "$@"
}

handle_w3m() {
	if [[ "$1" == *\?* ]]; then
		t=$(nexttmp)
		ln -s "$1" "$t"
		set "$t" "$1"
	fi
	nodash "w3m -dump -T text/html" "$1"
}

_html2text() {
    nodash html2text "$1" "$2" | less -i &
    less_pid=$!
    wait "$less_pid" 
    return 0
}

ishtml() {
	[[ $1 == - ]] && arg1=-stdin || arg1="$1"
	htmlopt=--unicode-snob
	cmd_check html2text python-html2text && html2text -utf8 </dev/null 2>/dev/null && htmlopt=-utf8
	# 3 lines following can easily be reshuffled according to the preferred tool
	cmd_check elinks elinks && nodash "elinks -dump -force-html" "$1" && return 0 ||
	cmd_check w3m w3m && handle_w3m "$1" && return 0 ||
	cmd_check lynx lynx && lynx -force_html -dump "$arg1" && return 0 ||
	# different versions of html2text existingi, force unicode
	[[ "$1" == https://* ]] && return 0 ||
	cmd_check html2text python-html2text && _html2text "$htmlopt" "$1" && return 0
    # shellcheck disable=SC2181
    [[ $? -ne 0 ]] && cmd_check -msg
}

imgview() {
    local file="$1"
    
    [[ -z "$BOOKS_IMG" || "$BOOKS_IMG" == 1 ]] && cmd_check img2sixel libsixel &&
    img2sixel -w "${BOOKS_SIXEL_W:-540}" -h "${BOOKS_SIXEL_H:-420}" "${file}" 2>/dev/null && return 0
    [[ -z "$BOOKS_IMG" || "$BOOKS_IMG" == 2 ]] && 
    cmd_check viu viu && viu -w "${BOOKS_VIU_H:-90}" -h "${BOOKS_VIU_H:-35}" "${file}" 2>/dev/null && return 0
    [[ -z "$BOOKS_IMG" || "$BOOKS_IMG" == 3 ]] && cmd_check catimg catimg &&
    catimg -w "${BOOKS_CATIMG_W:-100}" "${file}" 2>/dev/null && return 0 
    [[ -z "$BOOKS_IMG" || "$BOOKS_IMG" == 4 ]] && cmd_check chafa chafa &&
    chafa -s "${BOOKS_CHAFA_S:-50}" "${file}" 2>/dev/null && return 0

    cmd_check -msg && echo && any_file "$file" && return 1
}

pdfview() {
    local file="$1"
    temp_file="${TMPBOOKDIR}/temp_file.jpg"
    [[ -f "$temp_file" ]] && rm -f "$temp_file"

    cmd_check pdftotext poppler && 
    pdf_lines=$(pdftotext -l 1 -nopgbrk -q -- "$file" - | wc -l) &&
    [[ "$pdf_lines" -gt 0 ]] &&
    pdftotext -layout -nopgbrk "$file" "${temp_file}" 1>/dev/null &&
    margin "${temp_file}" && return 0
    cmd_check mutool mupdf && mutool draw -F txt -i -- "${file}" | less_pid && return 0 
    cmd_check magick imagemagick && 
    magick -- "${file}[0]" -auto-orient -filter Box -resize "$RESOLUTION" -quality 85 "$temp_file" 2>/dev/null &&
    [[ -f "$temp_file" ]] && imgview "$temp_file" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

# Function to select and open a book
select_book() {
    local book_path="$1"
    
    if [[ -z "$book_path" ]]; then
        local list=()
        if [[ -n "$search_term" ]]; then
            list=("${filtered_books[@]}")
        else
            list=("${books_list[@]}")
        fi
        book_path="${list[$selected]}"
    fi
    
    ext_test="${book_path##*.}"
    ext_test="${ext_test,,}" # lowercase

    case "$ext_test" in
        txt)
            margin "$book_path" && return 0
            ;;
        md|markdown)
            if ! markdown_reader "$book_path"; then
                printf '\n\e[33mMarkdown file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        pod)
            if ! podview "$book_path"; then
                printf '\n\e[33mPOD file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        pdf)
            if ! pdfview "$book_path"; then
                printf '\n\e[33mPDF file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        png|jpg|jpeg)
            if ! imgview "$book_path"; then
                printf '\n\e[33mImage file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        rtf|odt|ods|odp|sxw|doc|docx|xls|xlsx|ipynb|epub|ppt|pptx|csv)
            if ! office_convert "$book_path"; then
                printf '\n\e[33mOffice file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        djvu)
            if ! djvuview "$book_path"; then
                printf '\n\e[33mDjvu file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        postscript|ps)
            if ! psview "$book_path"; then
                printf '\n\e[33mPS file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        dvi)
            if ! dviview "$book_path"; then
                printf '\n\e[33mDVI file: %s\e[m\n' "${book_path##*/}"
                return 1
            else
                return 0
            fi
            ;;
        htm|html|xhtml)
            if ! ishtml "$book_path" |\
            fmt -w "${width}" | head -n "${sizeline}"; then
                printf '\n\e[33mWeb file: %s\e[m\n' "${book_path##*/}" 
                return 1
            else
                return 0
            fi
            ;;
        esac


    if [[ "${ext_test}" =~ ^([Mm][Dd])$ ]]; then
        markdown_reader "$book_path"
    elif [[ "${ext_test}" =~ ^([Oo][Dd][Tt])$ ]]; then
        office_convert "$book_path"
    elif [[ "${ext_test}" =~ ^([Rr][Tt][Ff])$ ]]; then
        office_convert "$book_path"
    elif [[ "${ext_test}" =~ ^([Xx][Mm][Ll])$ ]]; then
        ishtml "$book_path"
    elif [[ "${ext_test}" =~ ^([Hh][Tt][Mm])$ ]]; then
        ishtml "$book_path"
    elif [[ "${ext_test}" =~ ^([Hh][Tt][Mm][Ll])$ ]]; then
        ishtml "$book_path"
    elif [[ "${ext_test}" =~ ^([Dd][Oo][Cc][Xx])$ ]]; then
        office_convert "$book_path"
    elif [[ "${ext_test}" =~ ^([Dd][Oo][Cc])$ ]]; then
        office_convert "$book_path"
    elif [[ "${ext_test}" =~ ^([Tt][Xx][Tt])$ ]]; then
        margin "$book_path"
    elif [[ "${ext_test}" =~ ^([Ee][Pp][Uu][Bb])$ ]]; then
        cmd_check epr epr || cmd_check -msg
        epr "$book_path" 2>/dev/null && return 0
    elif [[ "${ext_test}" =~ ^([Pp][Dd][Ff])$ ]]; then
        declare -l temp_file="${TMPBOOKDIR}/temp_book.txt"
        [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
        cmd_check pdftotext poppler || cmd_check -msg 
        pdftotext -layout -nopgbrk "$book_path" "${temp_file}" 1>/dev/null
        margin "${temp_file}"
    else
        xdg-open "$book_path" || echo 'Unrecognized format' && exit 1
    fi
}

# Check if a book was provided as an argument
if [[ -n "$1" ]]; then
    select_book "$1"
    exit 0
fi

# Interactive navigation
selected=0
esc=$'\e'
up=$'\e[A'
down=$'\e[B'
search_term=""
filtered_books=()

temp_search_results="${TMPBOOKDIR}/grep_search_results.txt"

while true; do
    clear
    echo -e "\nUse ↑/↓ or w/s to navigate, Enter to select a book, 'f' to find by name, 'g' to grep content.\n"
    display_books "$search_term"
    echo -e "\nOr use 'q' to exit."

    IFS= read -rsn1 key  # Read first character

    if [[ "$key" == "$esc" ]]; then
        IFS= read -rsn2 rest
        key+="$rest"
    fi

    case "$key" in
        w|W|"$up")
            if [[ "$selected" -gt 0 ]]; then
                selected=$((selected - 1))
            fi
            ;;
        s|S|"$down")
            if [[ "$selected" -lt $((${#books_list[@]} - 1)) ]]; then
                selected=$((selected + 1))
            fi
            ;;
        f|F)
            echo -e "\nEnter search term: "
            read -r search_term
            mapfile -t filtered_books < <(find "$books_folder" "$xdg_books_folder" -type f -iname "*${search_term}*" -print0 2>/dev/null | xargs -0 -n1 echo)
            selected=0
            ;;
        g|G)
            echo -e "\nEnter content search term: "
            read -r search_term
            grep -irl "$search_term" "$books_folder" "$xdg_books_folder" > "$temp_search_results" 2>/dev/null
            mapfile -t filtered_books < "$temp_search_results"
            selected=0
            ;;
        "")
            break
            ;;
        q|Q)
            exit 0
            ;;
        *)
            echo -e "\n${red}Invalid key!${nc}"
            sleep 2
            ;;
    esac

done

# Display the selected book with highlight
clear
if [[ -n "$search_term" ]]; then
    echo -e "$highlight You selected: ${filtered_books[$selected]} $nc"
else
    echo -e "$highlight You selected: ${books_list[$selected]} $nc"
fi
select_book
