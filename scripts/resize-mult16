#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
resize-mult16 - Check if images are multiples of 16 and optionally resize them
Version: 1.1
License: GPLv3
Author: Felipe Facundes

DESCRIPTION:
This script checks if image dimensions are multiples of 16 and optionally resizes
them to the nearest multiple. This is particularly useful for Godot game engine
TileMaps and texture optimization.

WHY MULTIPLES OF 16 FOR GODOT?
───────────────────────────────
• Performance Optimization: Godot's rendering engine is optimized for textures
  with dimensions that are powers of two (16, 32, 64, 128, 256, 512, 1024, etc.).
• TileMap Compatibility: Godot's TileMap system uses 16x16 tiles by default.
  Images not multiples of 16 may be cropped or display incorrectly.
• Memory Alignment: Modern GPUs process textures more efficiently when dimensions
  are powers of two, reducing memory fragmentation.
• Mipmapping: Proper mipmap generation requires power-of-two dimensions for
  consistent texture filtering across different LOD levels.
• Best Practice: Keep images under 4096x4096 (4K) for broader hardware
  compatibility and better performance.

RECOMMENDED PRACTICES:
──────────────────────
1. Sprite sheets: Should have dimensions that are multiples of 16
2. Tile sets: Each tile should be 16x16, 32x32, 64x64, etc.
3. Texture atlases: Maintain power-of-two dimensions
4. UI elements: Align to 16-pixel grid for crisp rendering

REQUIREMENTS:
• ImageMagick (magick command)

EXAMPLES:
  resize-mult16 image.png                    # Check single image
  resize-mult16 -r image.png                 # Resize with confirmation
  resize-mult16 -rf *.png                    # Force resize all PNGs
  resize-mult16 -l -r                        # Batch process all images
  resize-mult16 -p -c black image.png        # Pad with black borders
  resize-mult16 -d image.png                 # Dry run (simulation)
  resize-mult16 -s 1080 image.png            # Resize to approximate 1080p (multiple of 16)
  resize-mult16 -s 1920x1080 image.png       # Resize to approximate 1920x1080 (multiple of 16)

OPTIONS:
  -h, --help           Show this help message
  -r, --resize         Automatically resize to nearest multiple of 16
  -f, --force          Force resize without confirmation
  -p, --pad            Pad images instead of stretching
  -c COLOR, --color COLOR  Padding color (default: transparent)
  -i METHOD, --interpolation METHOD  Interpolation method (default: box)
  -v, --verbose        Show detailed information
  -n, --no-backup      Don't create backup of original files
  -d, --dry-run        Simulate actions without modifying files
  -l, --loop           Batch process all matching images
  -o DIR, --output DIR Output directory for resized images
  -s SIZE, --size SIZE Target size (e.g., 1080 or 1920x1080). The image will be resized 
                        to the nearest multiple of 16 that approximates the target size.

TIPS FOR GODOT USERS:
─────────────────────
1. Import Settings: In Godot, set texture filter to "Nearest" for pixel art
2. TileMap Setup: Use 16x16 cell size for default tiles
3. Atlas Textures: Create texture atlases with dimensions like 256x256, 512x512
4. Performance: Textures over 2048x2048 may impact mobile performance
5. Compression: Use .png for lossless, .jpg for background images

SEE ALSO:
• Godot Documentation: https://docs.godotengine.org/
• ImageMagick: https://imagemagick.org/

BUGS & FEEDBACK:
Please report issues to: https://github.com/felipefacundes/shell_utils
DOCUMENTATION

# Default values
RESIZE=false
VERBOSE=false
FORCE=false
BACKUP=true
DRY_RUN=false
LOOP_MODE=false
PAD_MODE=false
PAD_COLOR="transparent"
INTERPOLATION="box" # Good for pixel art
OUTPUT_DIR=""
TARGET_SIZE=""      # Target size for -s option
TARGET_WIDTH=""     # Parsed target width
TARGET_HEIGHT=""    # Parsed target height

# Display usage information
show_usage() {
    echo "Usage: ${0##*/} [OPTIONS] <image_file(s)>"
    echo ""
    echo "Options:"
    echo "  -h, --help           Show this help message"
    echo "  -r, --resize         Automatically resize images to nearest multiple of 16"
    echo "  -f, --force          Force resize without confirmation"
    echo "  -p, --pad            Pad images instead of stretching (maintains aspect ratio)"
    echo "  -c COLOR, --color COLOR  Padding color (default: transparent)"
    echo "  -i METHOD, --interpolation METHOD  Interpolation method (default: box)"
    echo "  -v, --verbose        Show detailed information"
    echo "  -n, --no-backup      Don't create backup of original files"
    echo "  -d, --dry-run        Simulate actions without modifying files"
    echo "  -l, --loop           Enable loop mode for monitoring"
    echo "  -o DIR, --output DIR Output directory for resized images"
    echo "  -s SIZE, --size SIZE Target size (e.g., 1080 or 1920x1080). The image will be"
    echo "                        resized to the nearest multiple of 16 that approximates"
    echo "                        the target size while maintaining aspect ratio."
    echo ""
    echo "Examples:"
    echo "  ${0##*/} image.png                    # Check single image"
    echo "  ${0##*/} *.png                        # Check all PNG files"
    echo "  ${0##*/} -r image.png                 # Resize with confirmation"
    echo "  ${0##*/} -rf image.png                # Force resize without confirmation"
    echo "  ${0##*/} -p -c black image.png        # Pad with black color"
    echo "  ${0##*/} -l -r                        # Loop mode with resize"
    echo "  ${0##*/} -l -d                        # Loop mode dry-run"
    echo "  ${0##*/} -o ./output/ *.png           # Save to output directory"
    echo "  ${0##*/} -s 1080 image.png            # Resize to approximate 1080p height"
    echo "  ${0##*/} -s 1920x1080 image.png       # Resize to approximate 1920x1080"
    exit 0
}

# Check if ImageMagick is installed
check_dependencies() {
    if ! command -v magick &> /dev/null; then
        echo "Error: ImageMagick (magick) is not installed."
        echo "Install it with: sudo apt install imagemagick (Ubuntu/Debian)"
        echo "              or: sudo pacman -S imagemagick (Arch)"
        echo "              or: sudo dnf install ImageMagick (Fedora)"
        exit 1
    fi
}

# Validate color format
validate_color() {
    local color="$1"
    
    # Check if it's a named color or hex code
    if [[ "$color" == "transparent" ]] || 
       [[ "$color" =~ ^#[0-9A-Fa-f]{6}$ ]] || 
       [[ "$color" =~ ^#[0-9A-Fa-f]{3}$ ]] ||
       [[ "$color" =~ ^[a-zA-Z]+$ ]]; then
        return 0
    else
        echo "Warning: Color '$color' might not be valid. Using 'transparent' instead."
        return 1
    fi
}

# Parse target size argument
parse_target_size() {
    local size="$1"
    
    # Check if it's in format WxH
    if [[ "$size" =~ ^[0-9]+x[0-9]+$ ]]; then
        TARGET_WIDTH="${size%x*}"
        TARGET_HEIGHT="${size#*x}"
    # Check if it's a single number (assume height for landscape, but we'll use it as reference)
    elif [[ "$size" =~ ^[0-9]+$ ]]; then
        TARGET_WIDTH="$size"
        TARGET_HEIGHT="$size"
    else
        echo "Error: Invalid size format. Use format like 1080 or 1920x1080."
        exit 1
    fi
    
    # Validate numbers are positive
    if [ "$TARGET_WIDTH" -le 0 ] || [ "$TARGET_HEIGHT" -le 0 ]; then
        echo "Error: Dimensions must be positive numbers."
        exit 1
    fi
    
    if [ "$VERBOSE" = true ]; then
        echo "Target size parsed: ${TARGET_WIDTH}x${TARGET_HEIGHT}"
    fi
}

# Check if file is an image
is_image_file() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "Error: File '$file' does not exist."
        return 1
    fi
    
    # Check if file is an image using file command
    if file "$file" | grep -qE "image|bitmap"; then
        return 0
    else
        echo "Error: '$file' does not appear to be an image file."
        return 1
    fi
}

# Get image dimensions
get_image_dimensions() {
    local file="$1"
    local dimensions
    
    # Use magick identify to get dimensions    
    if ! dimensions=$(magick identify -format "%wx%h" "$file" 2>/dev/null); then
        echo "Error: Could not get dimensions for '$file'"
        return 1
    fi
    
    # Extract width and height
    local width height
    width=$(echo "$dimensions" | cut -d'x' -f1)
    height=$(echo "$dimensions" | cut -d'x' -f2)
    
    echo "$width $height"
}

# Calculate nearest multiple of 16
calculate_nearest_multiple() {
    local dimension=$1
    local method=$2  # "ceil" or "floor" or "round"
    
    case $method in
        "ceil")
            echo $(( ((dimension + 15) / 16) * 16 ))
            ;;
        "floor")
            echo $(( (dimension / 16) * 16 ))
            ;;
        "round")
            local lower=$(( (dimension / 16) * 16 ))
            local upper=$(( ((dimension + 15) / 16) * 16 ))
            
            if [ $((dimension - lower)) -lt $((upper - dimension)) ]; then
                echo $lower
            else
                echo $upper
            fi
            ;;
        *)
            echo $(( ((dimension + 15) / 16) * 16 ))
            ;;
    esac
}

# Calculate dimensions based on target size while maintaining aspect ratio
calculate_target_dimensions() {
    local original_width="$1"
    local original_height="$2"
    local target_width="$3"
    local target_height="$4"
    
    local new_width new_height
    local aspect_ratio
    
    # Calculate aspect ratio
    aspect_ratio=$(echo "scale=10; $original_width / $original_height" | bc 2>/dev/null)
    
    # If bc is not available, use awk as fallback
    if [ -z "$aspect_ratio" ] || [ "$aspect_ratio" = "0" ]; then
        aspect_ratio=$(awk "BEGIN {print $original_width / $original_height}")
    fi
    
    # Try to fit to target dimensions while maintaining aspect ratio
    # First, try scaling by width
    new_width="$target_width"
    new_height=$(echo "scale=0; $target_width / $aspect_ratio" | bc 2>/dev/null)
    
    # If bc failed, use awk
    if [ -z "$new_height" ] || [ "$new_height" = "0" ]; then
        new_height=$(awk "BEGIN {printf \"%.0f\", $target_width / $aspect_ratio}")
    fi
    
    # If height exceeds target, scale by height instead
    if [ "$new_height" -gt "$target_height" ]; then
        new_height="$target_height"
        new_width=$(echo "scale=0; $target_height * $aspect_ratio" | bc 2>/dev/null)
        
        if [ -z "$new_width" ] || [ "$new_width" = "0" ]; then
            new_width=$(awk "BEGIN {printf \"%.0f\", $target_height * $aspect_ratio}")
        fi
    fi
    
    # Round to nearest integer
    new_width=$(printf "%.0f" "$new_width" 2>/dev/null || echo "$new_width")
    new_height=$(printf "%.0f" "$new_height" 2>/dev/null || echo "$new_height")
    
    # Ensure minimum size of 16
    [ "$new_width" -lt 16 ] && new_width=16
    [ "$new_height" -lt 16 ] && new_height=16
    
    # Adjust to nearest multiple of 16
    new_width=$(calculate_nearest_multiple "$new_width" "round")
    new_height=$(calculate_nearest_multiple "$new_height" "round")
    
    echo "$new_width $new_height"
}

# Check if dimensions are multiples of 16
check_multiple_of_16() {
    local width=$1
    local height=$2
    
    if [ $((width % 16)) -eq 0 ] && [ $((height % 16)) -eq 0 ]; then
        return 0  # Both are multiples
    else
        return 1  # At least one is not a multiple
    fi
}

# Check if image needs resizing based on options
needs_resize() {
    local width=$1
    local height=$2
    
    # If -s is used, ALWAYS resize (to target size)
    if [ -n "$TARGET_SIZE" ]; then
        return 0  # Needs resize
    fi
    
    # If -r is used, only resize if not multiple of 16
    if [ "$RESIZE" = true ]; then
        if ! check_multiple_of_16 "$width" "$height"; then
            return 0  # Needs resize
        fi
    fi
    
    return 1  # No resize needed
}

# Display image information
display_info() {
    local file="$1"
    local width=$2
    local height=$3
    
    echo "=== Image: $file ==="
    echo "Current dimensions: ${width}x${height}"
    echo "Width:  $width pixels ($((width / 16)) tiles + $((width % 16)) extra pixels)"
    echo "Height: $height pixels ($((height / 16)) tiles + $((height % 16)) extra pixels)"
    
    if check_multiple_of_16 "$width" "$height"; then
        echo "✓ Image is already a multiple of 16"
        echo "  Perfect for Godot TileMap (${width}x${height} = $((width / 16))x$((height / 16)) tiles)"
    else
        echo "✗ Image is NOT a multiple of 16"
        
        # Calculate recommended dimensions
        local new_width; new_width=$(calculate_nearest_multiple "$width" "ceil")
        local new_height; new_height=$(calculate_nearest_multiple "$height" "ceil")
        
        echo "Recommended size: ${new_width}x${new_height}"
        echo "This would be: $((new_width / 16))x$((new_height / 16)) tiles"
        
        # Show difference
        local diff_w=$((new_width - width))
        local diff_h=$((new_height - height))
        
        if [ $diff_w -gt 0 ] || [ $diff_h -gt 0 ]; then
            echo "Would add: ${diff_w}px width, ${diff_h}px height"
        else
            echo "Would remove: $((-diff_w))px width, $((-diff_h))px height"
        fi
    fi
    echo ""
}

# Create backup of original file
create_backup() {
    local file="$1"
    local backup; backup="${file}.backup_$(date +%Y%m%d_%H%M%S)"
    
    # Check disk space before backup
    local file_size available_space
    file_size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
    available_space=$(df -P "$(dirname "$backup")" | awk 'NR==2 {print $4}')
    
    if [ -z "$file_size" ] || [ -z "$available_space" ]; then
        echo "Warning: Could not check disk space. Creating backup anyway."
    elif [ "$file_size" -gt "$available_space" ]; then
        echo "Warning: Not enough disk space for backup. Skipping backup."
        return 1
    fi
    
    if [ "$DRY_RUN" = true ]; then
        echo "[DRY RUN] Would create backup: $backup"
        return 0
    fi
    
    cp "$file" "$backup"
    echo "Backup created: $backup"
}

# Prepare output filename
prepare_output_filename() {
    local input_file="$1"
    
    if [ -n "$OUTPUT_DIR" ]; then
        # Ensure output directory exists
        mkdir -p "$OUTPUT_DIR" 2>/dev/null || {
            echo "Error: Cannot create output directory '$OUTPUT_DIR'"
            return 1
        }
        
        # Create output filename with path
        local basename
        basename=$(basename "$input_file")
        echo "${OUTPUT_DIR%/}/$basename"
    else
        # Use original file
        echo "$input_file"
    fi
}

_resize() {
    local input_file="$1"
    local output_file="$2"
    local new_width="$3"
    local new_height="$4"
    
    # Resize using magick
    if [ "$PAD_MODE" = true ]; then
        # Pad image (add borders)
        if [ "$DRY_RUN" = true ]; then
            echo "[DRY RUN] Would execute: magick \"$input_file\" -background \"$PAD_COLOR\" -gravity center -extent \"${new_width}x${new_height}\" \"$output_file\""
            return 0
        else
            magick "$input_file" -background "$PAD_COLOR" -gravity center \
                -extent "${new_width}x${new_height}" "$output_file"
        fi
    else
        # Resize image (stretch/shrink)
        if [ "$DRY_RUN" = true ]; then
            echo "[DRY RUN] Would execute: magick \"$input_file\" -filter \"$INTERPOLATION\" -resize \"${new_width}x${new_height}!\" \"$output_file\""
            return 0
        else
            magick "$input_file" -filter "$INTERPOLATION" -resize "${new_width}x${new_height}!" "$output_file"
        fi
    fi
}

# Resize image to target size or nearest multiple of 16
resize_image() {
    local file="$1"
    local width=$2
    local height=$3
    
    # Prepare output filename
    local output_file
    if ! output_file=$(prepare_output_filename "$file"); then
        return 1
    fi
    
    local new_width new_height
    
    # Determine target dimensions based on options
    if [ -n "$TARGET_SIZE" ]; then
        # Calculate dimensions based on target size while maintaining aspect ratio
        read new_width new_height <<< $(calculate_target_dimensions "$width" "$height" "$TARGET_WIDTH" "$TARGET_HEIGHT")
    else
        # Use nearest multiple of 16 (ceil method)
        new_width=$(calculate_nearest_multiple "$width" "ceil")
        new_height=$(calculate_nearest_multiple "$height" "ceil")
    fi
    
    # If dimensions haven't changed, nothing to do
    if [ "$width" -eq "$new_width" ] && [ "$height" -eq "$new_height" ]; then
        if [ "$VERBOSE" = true ]; then
            echo "Image already has target dimensions: ${width}x${height}"
        fi
        return 0
    fi
    
    if [ "$VERBOSE" = true ]; then
        echo "Resizing $file from ${width}x${height} to ${new_width}x${new_height}"
        if [ -n "$TARGET_SIZE" ]; then
            echo "Target size: ${TARGET_WIDTH}x${TARGET_HEIGHT} (approximate)"
        fi
        if [ "$file" != "$output_file" ]; then
            echo "Output file: $output_file"
        fi
    fi
    
    # Create backup if enabled and if we're modifying original file
    if [ "$BACKUP" = true ] && [ "$file" = "$output_file" ]; then
        create_backup "$file"
    fi
    
    if _resize "$file" "$output_file" "$new_width" "$new_height"; then
        if [ "$DRY_RUN" = false ]; then
            echo "✓ Successfully resized: $file"
            echo "  New size: ${new_width}x${new_height} ($((new_width / 16))x$((new_height / 16)) tiles)"
            if [ "$file" != "$output_file" ]; then
                echo "  Saved to: $output_file"
            fi
        else
            echo "[DRY RUN] Would resize: $file → ${new_width}x${new_height}"
        fi
    else
        echo "✗ Failed to resize: $file"
        return 1
    fi
}

# Ask for confirmation
ask_confirmation() {
    local file="$1"
    local width=$2
    local height=$3
    local new_width new_height
    
    if [ -n "$TARGET_SIZE" ]; then
        read new_width new_height <<< $(calculate_target_dimensions "$width" "$height" "$TARGET_WIDTH" "$TARGET_HEIGHT")
    else
        new_width=$(calculate_nearest_multiple "$width" "ceil")
        new_height=$(calculate_nearest_multiple "$height" "ceil")
    fi
    
    # If dimensions haven't changed, no need to ask
    if [ "$width" -eq "$new_width" ] && [ "$height" -eq "$new_height" ]; then
        echo "Image already has target dimensions: ${width}x${height}"
        return 2  # Special code for no change needed
    fi
    
    echo "Resize $file from ${width}x${height} to ${new_width}x${new_height}?"
    echo "This will be $((new_width / 16))x$((new_height / 16)) tiles for Godot."
    
    if [ -n "$TARGET_SIZE" ]; then
        echo "Target size: ${TARGET_WIDTH}x${TARGET_HEIGHT} (approximate)"
    fi
    
    if [ "$PAD_MODE" = true ]; then
        echo "Mode: Padding (maintains aspect ratio)"
        echo "Padding color: $PAD_COLOR"
    else
        echo "Mode: Scaling (changes aspect ratio)"
    fi
    
    if [ -n "$OUTPUT_DIR" ]; then
        echo "Output directory: $OUTPUT_DIR"
    fi
    
    read -p "Continue? [y/N]: " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Process a single image file
process_image() {
    local file="$1"
    
    # Skip backup files
    if [[ "$file" =~ \.backup_[0-9]{8}_[0-9]{6}$ ]]; then
        if [ "$VERBOSE" = true ]; then
            echo "Skipping backup file: $file"
        fi
        return 2  # Special return code for skipped backup
    fi
    
    # Check if file is an image
    if ! is_image_file "$file"; then
        return 1
    fi
    
    # Get dimensions
    local dimensions
    
    if ! dimensions=$(get_image_dimensions "$file"); then
        return 1
    fi
    
    local width; width=$(echo "$dimensions" | cut -d' ' -f1)
    local height; height=$(echo "$dimensions" | cut -d' ' -f2)
    
    # Display information (always show in verbose mode)
    if [ "$VERBOSE" = true ] || [ "$RESIZE" = false ]; then
        display_info "$file" "$width" "$height"
    fi
    
    # Check if resize is needed based on options
    if [ "$RESIZE" = true ] || [ -n "$TARGET_SIZE" ]; then
        if needs_resize "$width" "$height"; then
            if [ "$FORCE" = true ]; then
                # Force resize without confirmation
                resize_image "$file" "$width" "$height"
            else
                # Ask for confirmation
                ask_confirmation "$file" "$width" "$height"
                local confirm_result=$?
                
                if [ $confirm_result -eq 0 ]; then
                    resize_image "$file" "$width" "$height"
                elif [ $confirm_result -eq 2 ]; then
                    # No change needed (already target dimensions)
                    echo "✓ $file already has target dimensions: ${width}x${height}"
                    return 0
                else
                    echo "Skipped: $file"
                    return 2
                fi
            fi
        else
            # No resize needed - image is already multiple of 16 and using -r without -s
            if [ -z "$TARGET_SIZE" ] && [ "$RESIZE" = true ]; then
                echo "✓ $file is already a multiple of 16 (no resize needed)"
            fi
        fi
    fi
    
    return 0
}

# Loop batch processing function
loop_monitor() {
    echo "=== BATCH PROCESSING MODE ==="
    echo "Processing ALL image files in current directory matching patterns:"
    printf "  - %s\n" "${FILE_PATTERNS[@]}"
    echo ""
    
    # Collect all matching files
    local all_files=()
    local total_files=0
    
    echo "Scanning for files..."
    
    # Use shopt to handle null globs properly
    shopt -s nullglob
    for pattern in "${FILE_PATTERNS[@]}"; do
        for file in $pattern; do
            # Skip directories and non-regular files
            [ -f "$file" ] || continue
            
            # Skip backup files (files ending with .backup_*)
            if [[ "$file" =~ \.backup_[0-9]{8}_[0-9]{6}$ ]]; then
                continue
            fi
            
            # Check if it's an image file
            if file "$file" | grep -qE "image|bitmap"; then
                all_files+=("$file")
                ((total_files++))
            fi
        done
    done
    shopt -u nullglob
    
    if [ $total_files -eq 0 ]; then
        echo "No image files found matching patterns."
        echo "Supported patterns: ${FILE_PATTERNS[*]}"
        exit 0
    fi
    
    echo "Found $total_files image file(s) to process."
    echo ""
    
    # Ask for confirmation if not forced
    if [ "$FORCE" = false ]; then
        echo "This will process ALL $total_files image file(s):"
        
        # Show first few files
        local show_count=$(( total_files < 5 ? total_files : 5 ))
        for ((i=0; i<show_count; i++)); do
            echo "  - ${all_files[$i]}"
        done
        [ $total_files -gt 5 ] && echo "  ... and $((total_files - 5)) more"
        
        echo ""
        echo "Options active:"
        [ "$RESIZE" = true ] && echo "  - Resize: ON"
        [ -n "$TARGET_SIZE" ] && echo "  - Target size: ${TARGET_WIDTH}x${TARGET_HEIGHT}"
        [ "$DRY_RUN" = true ] && echo "  - Dry run: ON (simulation only)"
        [ "$PAD_MODE" = true ] && echo "  - Pad mode: ON"
        [ "$BACKUP" = true ] && echo "  - Backup: ON"
        
        read -p "Process ALL $total_files file(s)? [y/N]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
        fi
    fi
    
    # Process all files
    echo "=================================================="
    echo "Starting batch processing of $total_files file(s)..."
    echo ""
    
    local processed=0
    local resized=0
    local already_correct=0
    local skipped=0
    local errors=0
    
    for ((i=0; i<total_files; i++)); do
        local file="${all_files[$i]}"
        
        echo "--------------------------------------------------"
        echo "Processing file $((i + 1)) of $total_files: $(basename "$file")"
        
        # Process the file
        if process_image "$file"; then
            ((processed++))
            
            # Check if file was already correct
            if dimensions=$(get_image_dimensions "$file" 2>/dev/null); then
                local width; width=$(echo "$dimensions" | cut -d' ' -f1)
                local height; height=$(echo "$dimensions" | cut -d' ' -f2)
                
                if check_multiple_of_16 "$width" "$height"; then
                    # Only count as already correct if no resize was needed
                    if [ -z "$TARGET_SIZE" ] && [ "$RESIZE" = true ]; then
                        ((already_correct++))
                    fi
                fi
            fi
        else
            ((errors++))
        fi
    done
    
    echo "=================================================="
    echo "BATCH PROCESSING COMPLETE"
    echo "=================================================="
    echo "Summary:"
    echo "  Total files found: $total_files"
    
    if [ "$RESIZE" = true ]; then
        if [ -z "$TARGET_SIZE" ]; then
            echo "  Already multiple of 16: $already_correct"
        fi
        echo "  Successfully processed: $processed"
    else
        echo "  Successfully processed: $processed"
    fi
    
    echo "  Errors: $errors"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo "NOTE: This was a DRY RUN - no files were modified."
    fi
    
    if [ $errors -gt 0 ]; then
        echo "Some files had errors. Check the output above."
        exit 1
    fi
    
    exit 0
}

# Display Godot-specific recommendations
show_godot_tips() {
    echo "GODOT OPTIMIZATION TIPS:"
    echo "──────────────────────────"
    echo "1. Tile Size: Default is 16x16. Use multiples for best results."
    echo "2. Max Texture Size: Keep under 4096x4096 for compatibility."
    echo "3. Texture Filter: Use 'Nearest' for pixel art, 'Linear' for smooth."
    echo "4. Compression: PNG for UI/sprites, JPG for backgrounds."
    echo "5. Atlas Creation: Group small textures into power-of-two atlases."
    echo "6. Mipmaps: Disable for 2D sprites, enable for 3D textures."
    echo "7. VRAM: Monitor texture memory in Godot's debugger."
    echo ""
}

# Main function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_godot_tips
                show_usage
                ;;
            -r|--resize)
                RESIZE=true
                shift
                ;;
            -f|--force)
                FORCE=true
                RESIZE=true  # Force implies resize
                shift
                ;;
            -p|--pad)
                PAD_MODE=true
                shift
                ;;
            -c|--color)
                PAD_COLOR="$2"
                if ! validate_color "$PAD_COLOR"; then
                    PAD_COLOR="transparent"
                fi
                shift 2
                ;;
            -i|--interpolation)
                INTERPOLATION="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -n|--no-backup)
                BACKUP=false
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -l|--loop)
                LOOP_MODE=true
                shift
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -s|--size)
                TARGET_SIZE="$2"
                parse_target_size "$TARGET_SIZE"
                RESIZE=true  # -s implies resize
                shift 2
                ;;
            --)
                shift
                break
                ;;
            -*)
                echo "Error: Unknown option $1"
                show_usage
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Check dependencies
    check_dependencies
    
    # Store remaining arguments as file patterns
    local FILE_PATTERNS=("$@")
    
    # If no files specified and not in loop mode, show usage
    if [ ${#FILE_PATTERNS[@]} -eq 0 ] && [ "$LOOP_MODE" = false ]; then
        echo "Error: No image files specified."
        show_usage
    fi
    
    # If no file patterns in loop mode, use default patterns
    if [ ${#FILE_PATTERNS[@]} -eq 0 ] && [ "$LOOP_MODE" = true ]; then
        FILE_PATTERNS=("*.png" "*.jpg" "*.jpeg" "*.gif" "*.bmp" "*.tif" "*.tiff" "*.webp")
    fi
    
    # Loop mode
    if [ "$LOOP_MODE" = true ]; then
        loop_monitor
    fi
    
    # Normal mode - process files
    local processed=0
    local errors=0
    local already_correct=0
    local total_files=${#FILE_PATTERNS[@]}
    
    # Check if we have literal filenames (not patterns)
    if [ $total_files -gt 0 ]; then
        echo "Processing $total_files file(s)..."
        echo ""
        
        local current=0
        for file in "${FILE_PATTERNS[@]}"; do
            # Expand glob patterns if needed
            if [[ "$file" == *\** ]] || [[ "$file" == *\?* ]] || [[ "$file" == *\[* ]]; then
                # It's a pattern, expand it
                shopt -s nullglob
                for expanded_file in $file; do
                    [ -f "$expanded_file" ] || continue
                    ((current++))
                    echo "--------------------------------------------------"
                    echo "Processing file $current of ?: $(basename "$expanded_file")"
                    
                    if process_image "$expanded_file"; then
                        ((processed++))
                    else
                        ((errors++))
                    fi
                done
                shopt -u nullglob
            else
                # It's a literal filename
                if [ -f "$file" ]; then
                    ((current++))
                    echo "--------------------------------------------------"
                    echo "Processing file $current of $total_files: $(basename "$file")"
                    
                    if process_image "$file"; then
                        ((processed++))
                    else
                        ((errors++))
                    fi
                else
                    echo "Warning: File '$file' does not exist"
                    ((errors++))
                fi
            fi
        done
    fi
    
    # If no files were processed through the loop above, try pattern matching
    if [ $processed -eq 0 ] && [ $errors -eq 0 ]; then
        # Try to find files using common image patterns
        local found_files=0
        shopt -s nullglob
        for pattern in "${FILE_PATTERNS[@]}"; do
            for file in $pattern; do
                [ -f "$file" ] || continue
                ((found_files++))
            done
        done
        shopt -u nullglob
        
        if [ $found_files -gt 0 ]; then
            echo "Found $found_files file(s) matching patterns..."
            echo ""
            
            shopt -s nullglob
            for pattern in "${FILE_PATTERNS[@]}"; do
                for file in $pattern; do
                    [ -f "$file" ] || continue
                    echo "--------------------------------------------------"
                    echo "Processing file: $(basename "$file")"
                    
                    if process_image "$file"; then
                        ((processed++))
                    else
                        ((errors++))
                    fi
                done
            done
            shopt -u nullglob
        fi
    fi
    
    echo "=================================================="
    echo "Processing complete:"
    echo "  Files processed: $processed"
    
    if [ -z "$TARGET_SIZE" ] && [ "$RESIZE" = true ] && [ $already_correct -gt 0 ]; then
        echo "  Already multiple of 16: $already_correct"
    fi
    
    echo "  Errors: $errors"
    
    if [ $errors -gt 0 ]; then
        exit 1
    fi
}

# Trap Ctrl+C for graceful exit in loop mode
trap 'echo -e "\nExiting..."; exit 0' INT

# Run main function with all arguments
main "$@"