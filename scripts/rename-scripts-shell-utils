#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
Script: rename-scripts
Description: Renames scripts recursively, replacing underscores with hyphens
and removing .sh extensions, updating references in files
> Normalizes script filenames to Linux conventions (kebab-case, no ext).
DOCUMENTATION

# ------------------------------------------------------------------------------
# 1. CONFIGURATION & CONSTANTS
# ------------------------------------------------------------------------------

# Script identity
SCRIPT_NAME="${0##*/}"
APP_NAME="${SCRIPT_NAME%%.*}"

# Directory where target scripts are located
# SUGGESTION: Renamed from SCRIPTS_ROOT to TARGET_SCRIPTS_DIR for clarity
TARGET_SCRIPTS_DIR="${HOME}/.shell_utils/scripts/"

# Logging & Cache Configuration
CACHE_DIR="${HOME}/.cache/${APP_NAME}"
LOG_DIR="${CACHE_DIR}"
OLD_NAMES_FILE="${CACHE_DIR}/old_names"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
LOG_FILE="${LOG_DIR}/${APP_NAME}-${TIMESTAMP}.log"

# Colors for UI
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default Flags
DRY_RUN=false
VERBOSE=false
FORCE=false

# Enable recursive globbing for the "for" loop
shopt -s globstar nullglob

# ------------------------------------------------------------------------------
# 2. HELPER FUNCTIONS
# ------------------------------------------------------------------------------

log() {
    local level="$1"
    local message="$2"
    local log_entry; log_entry="$(date +'%Y-%m-%d %H:%M:%S') [${level}] ${message}"

    # Always write to log file if directory exists
    if [[ -d "$LOG_DIR" ]]; then
        echo "$log_entry" >> "$LOG_FILE"
    fi

    # Output to console based on verbosity
    if [[ "$VERBOSE" == "true" ]] || [[ "$level" == "ERROR" ]] || [[ "$level" == "INFO" ]]; then
        case "$level" in
            "INFO")  echo -e "${GREEN}[INFO]${NC} $message" ;;
            "WARN")  echo -e "${YELLOW}[WARN]${NC} $message" ;;
            "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
            "DEBUG") [[ "$VERBOSE" == "true" ]] && echo -e "${BLUE}[DEBUG]${NC} $message" ;;
        esac
    fi
}

show_help() {
    echo -e "Usage: $SCRIPT_NAME [OPTIONS]"
    echo ""
    echo "Normalizes filenames in $TARGET_SCRIPTS_DIR recursively."
    echo ""
    echo "Options:"
    echo "  -h, --help       Show this help message"
    echo "  -d, --dry-run    Simulate changes without modifying files"
    echo "  -v, --verbose    Enable verbose output"
    echo "  -f, --force      Execute without user confirmation"
    echo ""
    echo "Conventions applied:"
    echo "  1. Replace underscores (_) with hyphens (-)"
    echo "  2. Remove .sh extension"
}

init_environment() {
    if [[ ! -d "$TARGET_SCRIPTS_DIR" ]]; then
        echo -e "${RED}[ERROR]${NC} Target directory not found: $TARGET_SCRIPTS_DIR"
        exit 1
    fi

    mkdir -p "$LOG_DIR"
    touch "$OLD_NAMES_FILE"
    
    # Check write permissions
    if [[ ! -w "$TARGET_SCRIPTS_DIR" ]]; then
        echo -e "${RED}[ERROR]${NC} No write permission for: $TARGET_SCRIPTS_DIR"
        exit 1
    fi
}

register_old_name() {
    local original_name="${1##*/}"
    local new_name="${2##*/}"
    
    # Check if name exists in old_names using grep -q (quiet) to avoid duplicates
    if ! grep -Fxq "$original_name" "$OLD_NAMES_FILE"; then
        if [[ "$DRY_RUN" == "false" ]]; then
            echo "$original_name     ->     $new_name" >> "$OLD_NAMES_FILE"
            log "DEBUG" "Registered old name: $original_name"
        else
            log "DEBUG" "[DRY-RUN] Would register old name: $original_name"
        fi
    fi
}

# ------------------------------------------------------------------------------
# 3. MAIN LOGIC
# ------------------------------------------------------------------------------

# Parse Arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -h|--help) show_help; exit 0 ;;
        -d|--dry-run) DRY_RUN=true; shift ;;
        -v|--verbose) VERBOSE=true; shift ;;
        -f|--force) FORCE=true; shift ;;
        *) echo "Unknown parameter passed: $1"; show_help; exit 1 ;;
    esac
done

init_environment

echo -e "Starting script normalization..."
echo -e "Target: ${BLUE}$TARGET_SCRIPTS_DIR${NC}"
echo -e "Log file: ${BLUE}$LOG_FILE${NC}"
[[ "$DRY_RUN" == "true" ]] && echo -e "${YELLOW}*** DRY RUN MODE ENABLED ***${NC}"

# Confirmation (unless forced)
if [[ "$FORCE" == "false" && "$DRY_RUN" == "false" ]]; then
    read -rp "Are you sure you want to rename files in this directory? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        echo "Operation cancelled."
        exit 0
    fi
fi

log "INFO" "Starting processing..."

count_processed=0
count_renamed=0
count_errors=0

# Recursive Loop using globstar (enabled in config)
for file_path in "$TARGET_SCRIPTS_DIR"/**/*; do
    
    # Requirement: process only regular files
    if [[ -f "$file_path" ]]; then
        
        dir_name=$(dirname "$file_path")
        base_name=$(basename "$file_path")
        
        # 1. Replace underscores with hyphens
        new_base_name="${base_name//_/-}"
        
        # 2. Remove .sh extension (if it exists)
        new_base_name="${new_base_name%.sh}"
        
        # Construct full new path
        new_file_path="${dir_name}/${new_base_name}"
        
        blacklist_dir=$(realpath "$file_path")

        # Check if renaming is actually needed
        if [[ "$file_path" != "$new_file_path" ]] && \
            ! [[ "$blacklist_dir" =~ "/scripts/utilities/" ]] && \
            ! [[ "$blacklist_dir" =~ "/scripts/helps/" ]]; then

            log "INFO" "Processing: $base_name -> $new_base_name"
            
            # Safety check: avoid overwriting existing files
            if [[ -e "$new_file_path" ]]; then
                log "WARN" "Skipping: Target file already exists ($new_base_name)"
                ((count_errors++))
                continue
            fi
            
            # Step C: Rename
            if [[ "$DRY_RUN" == "false" ]]; then                
                if mv "$file_path" "$new_file_path"; then
                    log "INFO" "Successfully renamed: $file_path -> $new_file_path"
                    ((count_renamed++))
                    # Step B: Register Old Name
                    # Using only the filename relative to the project or the basename as needed?
                    # Storing the full original path for clarity.
                    register_old_name "$file_path" "$new_base_name"
                else
                    log "ERROR" "Failed to rename: $file_path"
                    ((count_errors++))
                fi
            else
                log "INFO" "[DRY-RUN] Would rename: $file_path -> $new_file_path"
            fi
            
        elif [[ "$file_path" == "$new_file_path" ]]; then
            log "DEBUG" "Skipping: $base_name (Already normalized)"
        elif [[ "$blacklist_dir" =~ "/scripts/utilities/" ]] || [[ "$blacklist_dir" =~ "/scripts/helps/" ]]; then
            log "DEBUG" "Skipping: $base_name (Blacklisted directory)"
        fi
        
        ((count_processed++))
    fi
done

# ------------------------------------------------------------------------------
# 4. SUMMARY
# ------------------------------------------------------------------------------

echo "------------------------------------------------"
log "INFO" "Process completed."
log "INFO" "Files scanned: $count_processed"
log "INFO" "Files renamed: $count_renamed"
log "INFO" "Errors: $count_errors"

if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "${YELLOW}This was a dry run. No changes were made.${NC}"
fi

exit 0