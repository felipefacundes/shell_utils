#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
Script: rename-shell-scripts
Description: Recursively renames shell scripts replacing underscores with
             hyphens and removes .sh extensions, updating all references
Author: Generated for shell utilities standardization
Version: 1.0.0
DOCUMENTATION

# Constants
readonly SHELL_UTILS_DIR="$HOME/.shell_utils"
readonly SCRIPTS_DIR="$SHELL_UTILS_DIR/scripts"
readonly SCRIPT_NAME="${0##*/}"
readonly SCRIPT_BASENAME="${SCRIPT_NAME%%.*}"
readonly CACHE_DIR="$HOME/.cache/$SCRIPT_BASENAME"
readonly TMP_COUNT_FILE="$CACHE_DIR/${SCRIPT_BASENAME}_counts.tmp"
LOG_FILE="$CACHE_DIR/${SCRIPT_BASENAME}-$(date +%Y%m%d-%H%M%S).log"

# Directories to ignore
readonly IGNORE_DIRS=("$SHELL_UTILS_DIR/.git")

# Colors for output
readonly COLOR_RED='\033[0;31m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_RESET='\033[0m'

# Global variables
DRY_RUN=false
VERBOSE=false
FORCE=false

# Function to check if directory should be ignored
should_ignore() {
    local path="$1"
    
    for ignore_dir in "${IGNORE_DIRS[@]}"; do
        if [[ "$path" == "$ignore_dir"* ]]; then
            return 0  # true - should ignore
        fi
    done
    
    return 1  # false - should not ignore
}

# Function for logging
log_message() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo -e "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" >/dev/null
}

log_info() {
    log_message "INFO" "$1"
    [[ "$VERBOSE" == true ]] && echo -e "${COLOR_BLUE}[INFO]${COLOR_RESET} $1"
}

log_warning() {
    log_message "WARN" "$1"
    echo -e "${COLOR_YELLOW}[WARN] $1${COLOR_RESET}"
}

log_success() {
    log_message "SUCCESS" "$1"
    echo -e "${COLOR_GREEN}[SUCCESS] $1${COLOR_RESET}"
}

log_error() {
    log_message "ERROR" "$1"
    echo -e "${COLOR_RED}[ERROR] $1${COLOR_RESET}" >&2
}

# Creates cache directory if it doesn't exist
setup_cache_dir() {
    if [[ ! -d "$CACHE_DIR" ]]; then
        mkdir -p "$CACHE_DIR"
        log_info "Cache directory created: $CACHE_DIR"
    fi
}

# Checks if directory exists
validate_directories() {
    if [[ ! -d "$SHELL_UTILS_DIR" ]]; then
        log_error "Directory $SHELL_UTILS_DIR not found!"
        exit 1
    fi
    
    if [[ ! -d "$SCRIPTS_DIR" ]]; then
        log_error "Directory $SCRIPTS_DIR not found!"
        exit 1
    fi
}

# Function to generate new file name
generate_new_name() {
    local old_name="$1"
    local base_name
    
    # Remove .sh extension if it exists
    if [[ "$old_name" == *.sh ]]; then
        base_name="${old_name%.sh}"
    else
        base_name="$old_name"
    fi
    
    # Replace underscores with hyphens
    base_name="${base_name//_/-}"
    
    echo "$base_name"
}

# Updates count in temporary file
update_count() {
    local type="$1"
    local value="$2"
    
    # Create or update count file
    if [[ -f "$TMP_COUNT_FILE" ]]; then
        # Read existing counts
        local files_renamed=0
        local refs_updated=0
        local errors=0
        
        if grep -q "^FILES_RENAMED=" "$TMP_COUNT_FILE"; then
            files_renamed=$(grep "^FILES_RENAMED=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
        
        if grep -q "^REFS_UPDATED=" "$TMP_COUNT_FILE"; then
            refs_updated=$(grep "^REFS_UPDATED=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
        
        if grep -q "^ERRORS=" "$TMP_COUNT_FILE"; then
            errors=$(grep "^ERRORS=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
        
        # Update the specific count
        case "$type" in
            "FILES_RENAMED")
                files_renamed=$((files_renamed + value))
                ;;
            "REFS_UPDATED")
                refs_updated=$((refs_updated + value))
                ;;
            "ERRORS")
                errors=$((errors + value))
                ;;
        esac
        
        # Write back to file
        echo "FILES_RENAMED=$files_renamed" > "$TMP_COUNT_FILE"
        echo "REFS_UPDATED=$refs_updated" >> "$TMP_COUNT_FILE"
        echo "ERRORS=$errors" >> "$TMP_COUNT_FILE"
    else
        # Create new file with initial values
        case "$type" in
            "FILES_RENAMED")
                echo "FILES_RENAMED=$value" > "$TMP_COUNT_FILE"
                echo "REFS_UPDATED=0" >> "$TMP_COUNT_FILE"
                echo "ERRORS=0" >> "$TMP_COUNT_FILE"
                ;;
            "REFS_UPDATED")
                echo "FILES_RENAMED=0" > "$TMP_COUNT_FILE"
                echo "REFS_UPDATED=$value" >> "$TMP_COUNT_FILE"
                echo "ERRORS=0" >> "$TMP_COUNT_FILE"
                ;;
            "ERRORS")
                echo "FILES_RENAMED=0" > "$TMP_COUNT_FILE"
                echo "REFS_UPDATED=0" >> "$TMP_COUNT_FILE"
                echo "ERRORS=$value" >> "$TMP_COUNT_FILE"
                ;;
        esac
    fi
}

# Reads counts from temporary file
read_counts() {
    local files_renamed=0
    local refs_updated=0
    local errors=0
    
    if [[ -f "$TMP_COUNT_FILE" ]]; then
        if grep -q "^FILES_RENAMED=" "$TMP_COUNT_FILE"; then
            files_renamed=$(grep "^FILES_RENAMED=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
        
        if grep -q "^REFS_UPDATED=" "$TMP_COUNT_FILE"; then
            refs_updated=$(grep "^REFS_UPDATED=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
        
        if grep -q "^ERRORS=" "$TMP_COUNT_FILE"; then
            errors=$(grep "^ERRORS=" "$TMP_COUNT_FILE" | cut -d'=' -f2)
        fi
    fi
    
    echo "$files_renamed $refs_updated $errors"
}

# Processes file renaming
process_file_rename() {
    local file_path="$1"
    local dir_path="${file_path%/*}"
    local old_filename="${file_path##*/}"
    local new_filename
    
    new_filename=$(generate_new_name "$old_filename")
    
    # If name hasn't changed, ignore
    if [[ "$old_filename" == "$new_filename" ]]; then
        [[ "$VERBOSE" == true ]] && log_info "Name unchanged: $old_filename"
        return 0
    fi
    
    local new_path="$dir_path/$new_filename"
    
    # Checks if new file already exists
    if [[ -e "$new_path" ]]; then
        if [[ "$FORCE" == true ]]; then
            log_warning "Overwriting existing file: $new_path"
        else
            log_error "File $new_path already exists. Use -f to overwrite."
            update_count "ERRORS" 1
            return 1
        fi
    fi
    
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${COLOR_BLUE}[DRY RUN]${COLOR_RESET} Rename: $old_filename -> $new_filename"
        return 0
    fi
    
    # Renames the file
    if mv -v "$file_path" "$new_path"; then
        log_success "Renamed: $old_filename -> $new_filename"
        echo "RENAME|$file_path|$new_path" >> "$LOG_FILE"
        update_count "FILES_RENAMED" 1
        return 0
    else
        log_error "Failed to rename: $file_path"
        update_count "ERRORS" 1
        return 1
    fi
}

# Searches and replaces file references (ignoring .git)
update_references() {
    local old_name="$1"
    local new_name="$2"
    local matches=0
    
    [[ "$VERBOSE" == true ]] && log_info "Searching for references to: $old_name"
    
    # Searches for references to old file, ignoring .git
    while IFS= read -r file; do
        # Ignores directories from ignore list
        if should_ignore "$file"; then
            continue
        fi
        
        if [[ -f "$file" ]]; then
            matches=$((matches + 1))
            
            if [[ "$DRY_RUN" == true ]]; then
                log_info "[DRY RUN] Update $file: $old_name -> $new_name"
            else
                # Replaces references (without creating .bak backup)
                sed -i "s/\b$old_name\b/$new_name/g" "$file"
                
                log_info "Updated: $file"
                echo "REF_UPDATE|$file|$old_name|$new_name" >> "$LOG_FILE"
                update_count "REFS_UPDATED" 1
            fi
        fi
    done < <(grep -r -l --exclude-dir=.git "\b$old_name\b" "$SHELL_UTILS_DIR" 2>/dev/null || true)
    
    [[ "$VERBOSE" == true ]] && log_info "Found $matches references for $old_name"
}

# Processes recursive renaming
rename_scripts_recursively() {
    local renamed_count=0
    local error_count=0
    
    log_info "Starting processing in: $SCRIPTS_DIR"
    log_info "Dry run mode: $DRY_RUN"
    log_info "Verbose mode: $VERBOSE"
    log_info "Ignoring directory: $SHELL_UTILS_DIR/.git"
    
    # Reset count file
    echo "FILES_RENAMED=0" > "$TMP_COUNT_FILE"
    echo "REFS_UPDATED=0" >> "$TMP_COUNT_FILE"
    echo "ERRORS=0" >> "$TMP_COUNT_FILE"
    
    # Finds all files recursively
    while IFS= read -r file; do
        # Checks if file should be ignored
        if should_ignore "$file"; then
            [[ "$VERBOSE" == true ]] && log_info "Ignoring file in .git directory: $file"
            continue
        fi
        
        local old_filename="${file##*/}"
        
        # Processes only files containing _ or ending with .sh
        if [[ "$old_filename" == *"_"* ]] || [[ "$old_filename" == *.sh ]]; then
            if process_file_rename "$file"; then
                local new_filename
                new_filename=$(generate_new_name "$old_filename")
                
                # Updates references if not dry run and name changed
                if [[ "$DRY_RUN" == false ]] && [[ "$old_filename" != "$new_filename" ]]; then
                    update_references "$old_filename" "$new_filename"
                    # Also updates for version without .sh if applicable
                    if [[ "$old_filename" == *.sh ]]; then
                        update_references "${old_filename%.sh}" "$new_filename"
                    fi
                fi
                
                renamed_count=$((renamed_count + 1))
            else
                error_count=$((error_count + 1))
            fi
        else
            [[ "$VERBOSE" == true ]] && log_info "Ignoring file (no _ or .sh): $old_filename"
        fi
    done < <(find "$SCRIPTS_DIR" -type f)
    
    # Read final counts
    read counts_str < <(read_counts)
    local final_counts=($counts_str)
    local files_renamed=${final_counts[0]}
    local refs_updated=${final_counts[1]}
    local errors=${final_counts[2]}
    
    log_info "Processing completed: $files_renamed files renamed, $errors errors"
    
    if [[ "$files_renamed" -gt 0 ]] && [[ "$DRY_RUN" == false ]]; then
        log_success "Renaming completed successfully!"
        log_info "Detailed log available at: $LOG_FILE"
    fi
}

# Shows help
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Renames scripts recursively, replacing underscores (_) with hyphens (-) and
removing .sh extensions, updating references in files.

OPERATIONS PERFORMED:
  1. Renames files in $SCRIPTS_DIR and subdirectories
  2. Replaces all '_' with '-' in file names
  3. Removes '.sh' extension from file names
  4. Updates references in files in $SHELL_UTILS_DIR
  5. Automatically ignores directory $SHELL_UTILS_DIR/.git

Options:
  -h, --help      Shows this help message
  -d, --dry-run   Executes in simulation mode, without making changes
  -v, --verbose   Verbose mode, shows detailed information
  -f, --force     Overwrites existing files without asking

Examples:
  $SCRIPT_NAME                    # Executes normal renaming
  $SCRIPT_NAME -d -v              # Verbose simulation mode
  $SCRIPT_NAME -f                 # Forces file overwriting

Directories:
  Shell Utils:    $SHELL_UTILS_DIR
  Scripts:        $SCRIPTS_DIR
  Logs:           $CACHE_DIR

Note: No .bak backup will be created during the process.
EOF
}

# Shows execution summary
show_execution_summary() {
    # Read counts from temporary file
    read counts_str < <(read_counts)
    local final_counts=($counts_str)
    local files_renamed=${final_counts[0]}
    local refs_updated=${final_counts[1]}
    local errors=${final_counts[2]}
    
    echo ""
    echo "╔════════════════════════════════════════╗"
    echo "║          Execution Summary             ║"
    echo "╚════════════════════════════════════════╝"
    echo ""
    echo "  Files renamed:        $files_renamed"
    echo "  References updated:   $refs_updated"
    echo "  Errors:               $errors"
    echo ""
    echo "  Log file: $LOG_FILE"
    echo ""
    echo "[INFO] Script execution completed"
    echo ""
}

# Cleans up temporary files
cleanup() {
    if [[ -f "$TMP_COUNT_FILE" ]]; then
        rm -f "$TMP_COUNT_FILE"
    fi
}

# Processes command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -f|--force)
                FORCE=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# Main function
main() {
    parse_arguments "$@"
    setup_cache_dir
    validate_directories
    
    # Set up trap to clean up temp files on exit
    trap cleanup EXIT
    
    echo -e "${COLOR_BLUE}=== Starting execution of $SCRIPT_NAME ===${COLOR_RESET}"
    log_info "Scripts directory: $SCRIPTS_DIR"
    log_info "Log file: $LOG_FILE"
    echo ""
    
    rename_scripts_recursively
    
    echo ""
    echo -e "${COLOR_BLUE}=== End of execution ===${COLOR_RESET}"
    
    # Show execution summary
    show_execution_summary
    
    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        echo -e "${COLOR_YELLOW}Dry run mode activated. No changes were made.${COLOR_RESET}"
        echo "Execute without the -d option to apply changes."
    fi
}

# Executes main script
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi