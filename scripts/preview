#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
A simple file manager with file preview based on "fff" and "ranger". It uses "lf" as a base, 
adding support for file preview with "ueberzug" and integration with custom commands for efficient navigation. 
It includes configurable shortcuts to simplify file manipulation.
DOCUMENTATION

clear

setup_config() {
    local config_file="$CONFIG_PATH/preview.conf"
    
    # If config file already exists, source it
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        return
    fi
    
    # Create the configuration file with default values and explanations
    cat > "$config_file" << 'EOF'
# Preview configuration file

# Enable/disable hidden files view by default (0: disabled, 1: enabled)
# Set to 1 to show hidden files when preview starts
PREVIEW_HIDDEN=""

# Enable/disable using LS_COLORS for file coloring (0: disabled, 1: enabled)
# Set to 1 to use colors defined in LS_COLORS environment variable
PREVIEW_LS_COLORS=""

# File format string for displaying files
# %f is replaced with the filename
PREVIEW_FILE_FORMAT=""

# Default program to open files with (default: xdg-open)
PREVIEW_OPENER=""

# Change directory on exit (0: disabled, 1: enabled)
# Set to 1 to change to the last directory viewed when preview exits
PREVIEW_CD_ON_EXIT=""

# Path to file that stores the last directory
PREVIEW_CD_FILE=""

# Color for directories (default: blue)
PREVIEW_COL1=""

# Color for status line background (default: blue)
PREVIEW_STATUS_BACKGROUND=""

# Color for selected item (not used directly in this version)
PREVIEW_COL3=""

# Color for selected item highlight (default: cyan)
PREVIEW_SETECTED_HIGHLIGHT=""

# Color for status line text (default: black)
PREVIEW_STATUS_FOREGROUND=""

# Key binding to navigate into directory or open file (default: l or right arrow)
PREVIEW_KEY_CHILD1=""
PREVIEW_KEY_CHILD2=""
PREVIEW_KEY_CHILD3=""
PREVIEW_KEY_CHILD4=""

# Key binding to navigate to parent directory (default: h or left arrow or backspace)
PREVIEW_KEY_PARENT1=""
PREVIEW_KEY_PARENT2=""
PREVIEW_KEY_PARENT3=""
PREVIEW_KEY_PARENT4=""
PREVIEW_KEY_PARENT5=""

# Key binding to scroll down (default: j or down arrow)
PREVIEW_KEY_SCROLL_DOWN1=""
PREVIEW_KEY_SCROLL_DOWN2=""
PREVIEW_KEY_SCROLL_DOWN3=""

# Key binding to scroll up (default: k or up arrow)
PREVIEW_KEY_SCROLL_UP1=""
PREVIEW_KEY_SCROLL_UP2=""
PREVIEW_KEY_SCROLL_UP3=""

# Key binding to go to the top of the file list (default: g)
PREVIEW_KEY_TO_TOP=""

# Key binding to go to the bottom of the file list (default: G)
PREVIEW_KEY_TO_BOTTOM=""

# Key binding to toggle showing hidden files (default: .)
PREVIEW_KEY_HIDDEN=""

# Key binding to search for files (default: /)
PREVIEW_KEY_SEARCH=""

# Key binding to exit search mode and return to normal view while keeping selection
# Add your preferred key here (example: ")
PREVIEW_KEY_EXIT_SEARCH=""
PREVIEW_KEY_EXIT_SEARCH2=""

# Key binding to open a shell in the current directory (default: !)
PREVIEW_KEY_SHELL=""

# Key binding to rename a file (default: r)
PREVIEW_KEY_RENAME=""

# Key binding to create a directory (default: n)
PREVIEW_KEY_MKDIR=""

# Key binding to create a file (default: f)
PREVIEW_KEY_MKFILE=""

# Key binding to go to a specific directory (default: :)
PREVIEW_KEY_GO_DIR=""

# Key binding to go to home directory (default: ~)
PREVIEW_KEY_GO_HOME=""

# Key binding to go to previous directory (default: -)
PREVIEW_KEY_PREVIOUS=""

# Key binding to refresh the current directory (default: e)
PREVIEW_KEY_REFRESH=""

# Key binding to copy a file (default: C)
PREVIEW_KEY_COPY=""

# Key binding to toggle preview mode (default: Ctrl+P)
# Ctrl+P is represented as '\x10'
PREVIEW_KEY_TOGGLE_PREVIEW=""
EOF

    # Make the config file user-executable
    chmod u+x "$config_file"
    
    # Source the newly created config file
    source "$config_file"
}

get_os() {
    case $OSTYPE in
        darwin*)
            opener=open
            file_flags=bIL
        ;;
        haiku)
            opener=open
        ;;
    esac
}

setup_terminal() {
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"
    stty -echo
}

reset_terminal() {
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'
    stty echo
}

clear_screen() {
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_items"
}

setup_options() {
    [[ $PREVIEW_FILE_FORMAT == *%f* ]] && {
        file_pre=${PREVIEW_FILE_FORMAT/'%f'*}
        file_post=${PREVIEW_FILE_FORMAT/*'%f'}
    }

    file -I &>/dev/null || : "${file_flags:=biL}"
}

get_term_size() {
    read -r LINES COLUMNS < <(stty size)
    
    if ((preview_mode == 1)); then
        ((max_items=${PREVIEW_MAX_ITEMS:-9}))
        ((preview_area=LINES-max_items-3)) # -3 For the delimiter and status line
    else
        ((max_items=LINES-3))
    fi
}

get_ls_colors() {
    [[ -z $LS_COLORS ]] && {
        PREVIEW_LS_COLORS=0
        return
    }

    IFS=: read -ra ls_cols <<< "$LS_COLORS"

    for ((i=0;i<${#ls_cols[@]};i++)); {
        [[ ${ls_cols[i]} =~ ^\*[^\.] ]] &&
            ls_patterns+="${ls_cols[i]/=*}|"

        [[ ${ls_cols[i]} =~ ^(\*|\.) ]] && {
            ls_cols[i]=${ls_cols[i]#\*}
            ls_cols[i]=ls_${ls_cols[i]#.}
        }
    }

    ls_cols=("${ls_cols[@]//[^a-zA-Z0-9=\\;]/_}")

    ls_patterns=${ls_patterns//\*}
    ls_patterns=${ls_patterns%?}

    export "${ls_cols[@]}" &>/dev/null
}

get_mime_type() {
    mime_type=$(file "-${file_flags:-biL}" "$1" 2>/dev/null | awk '{print $1}')
    mime_type2=$(file --dereference --brief --mime-type -- "$1" 2>/dev/null)
    mime_type_full=$(file "$1" | sed -n 's/.*:\s*\(.*\)/\1/p')
    mime_type="${mime_type,,}"
    mime_type2="${mime_type,,}"
    mime_type_full="${mime_type_full,,}"
}

status_line() {
    #PWD_escaped=${PWD//[^[:print:]]/^[}
    
    # Define color codes
    previous_directory=$(printf '%b\n' "\033[${PWD_PREVIOUS_DIRECTORY:-1;38;5;16}m")    # Black ansi 256   
    last_dir=$(printf '%b\n' "\033[${PWD_LAST_DIR:-1;33}m")                             # Yellow
    bar=$(printf '%b\n' "\033[${PWD_BAR:-1;96}m")                                       # Cyan
    ncpf=$(printf '\033[0m')                                                            # No color (reset)
    
    # Get base directory and current directory
    basedir="$(dirname "$PWD")"
    lastdir="$(basename "$PWD")"
    
    # Default colors if not specified in config
    status_background="48;5;128"   # Purple background
    status_foreground="1;38;5;16"  # Black foreground
    
    # Format the PWD with colors
    PWD_color=$(printf '%b\n' "$basedir" | awk -v previous_directory="$previous_directory" -v bar="$bar" -v last_dir="$last_dir" -v reset="$ncpf" -v lastdir="$lastdir" '
    {
        gsub("/", bar "/" previous_directory); # Colors all bars "/" in bar, keeping the rest previous_directory
        print previous_directory $0 bar "/" last_dir lastdir reset; # Red Way, Green Bars and Last Yellow Folder
    }')
    
    # Set mode info
    local mode_info=""
    if ((preview_mode == 1)); then
        mode_info="[Preview] "
    else
        mode_info="[Normal] "
    fi
    
    # The key fix: correct escape sequence format for colors
    # We need to use the full format: \e[<foreground>;<background>m
    # Instead of using separate escape sequences
    
    # Build the complete color sequence
    local color_seq="\e["
    
    # Add foreground if specified
    if [[ -n "${PREVIEW_STATUS_FOREGROUND:-$status_foreground}" ]]; then
        color_seq+="${PREVIEW_STATUS_FOREGROUND:-$status_foreground}"
    fi
    
    # Add semicolon between foreground and background if both are present
    if [[ -n "${PREVIEW_STATUS_FOREGROUND:-$status_foreground}" ]] && [[ -n "${PREVIEW_STATUS_BACKGROUND:-$status_background}" ]]; then
        color_seq+=";"
    fi
    
    # Add background if specified
    if [[ -n "${PREVIEW_STATUS_BACKGROUND:-$status_background}" ]]; then
        color_seq+="${PREVIEW_STATUS_BACKGROUND:-$status_background}"
    fi
    
    # Close the sequence
    color_seq+="m"
    
    # Print the status line with correct color formatting
    printf '\e7\e[%sH%b%*s\r%s%s %s\e[m\e[%sH\e[K\e8' \
        "$((LINES-1))" \
        "$color_seq" \
        "$COLUMNS" "" \
        "$mode_info" \
        "($((scroll+1))/$((list_total+1)))" \
        "${PWD_color}" \
        "$LINES"
}

read_dir() {
    local dirs
    local files
    local item_index

    printf '\e]2;preview: %s\e'\\ "$PWD"

    [[ $PWD == / ]] && PWD=

    for item in "$PWD"/*; do
        if [[ -d $item ]]; then
            dirs+=("$item")
            ((item_index++))

            [[ $item == "$OLDPWD" ]] &&
                ((previous_index=item_index))
        else
            files+=("$item")
        fi
    done

    list=("${dirs[@]}" "${files[@]}")

    [[ -z ${list[0]} ]] &&
        list[0]=empty

    ((list_total=${#list[@]}-1))

    cur_list=("${list[@]}")
}

get_background_from_foreground() {
    local foreground_code="$1"
    local bg_color_code=49  # Default background (no color)
    
    # Extract color codes
    local IFS=';'
    read -ra color_parts <<< "$foreground_code"
    
    for part in "${color_parts[@]}"; do
        # Convert normal foreground (30-37) to background (40-47)
        if ((part >= 30 && part <= 37)); then
            bg_color_code=$((part + 10))
        # Convert bright foreground (90-97) to background (100-107)
        elif ((part >= 90 && part <= 97)); then
            bg_color_code=$((part + 10))
        fi
    done
    
    # Return the background color code
    echo "$bg_color_code"
}

print_line() {
    local file_name=${list[$1]##*/}
    local file_ext=${file_name##*.}
    local format
    local suffix

    if [[ -z ${list[$1]} ]]; then
        return

    elif [[ -d ${list[$1]} ]]; then
        format+=\\e[${di:-1;3${PREVIEW_COL1:-2}}m
        suffix+=/

    elif [[ -b ${list[$1]} ]]; then
        format+=\\e[${bd:-40;33;01}m

    elif [[ -c ${list[$1]} ]]; then
        format+=\\e[${cd:-40;33;01}m

    elif [[ -x ${list[$1]} ]]; then
        format+=\\e[${ex:-01;32}m

    elif [[ -h ${list[$1]} && ! -e ${list[$1]} ]]; then
        format+=\\e[${mi:-01;31;7}m

    elif [[ -h ${list[$1]} ]]; then
        format+=\\e[${ln:-01;36}m

    elif [[ -p ${list[$1]} ]]; then
        format+=\\e[${pi:-40;33}m

    elif [[ -S ${list[$1]} ]]; then
        format+=\\e[${so:-01;35}m

    elif [[ $PREVIEW_LS_COLORS == 1 &&
            $ls_patterns &&
            $file_name =~ ($ls_patterns)$ ]]; then
        match=${BASH_REMATCH[0]}
        file_ext=ls_${match//[^a-zA-Z0-9=\\;]/_}
        format+=\\e[${!file_ext:-${fi:-37}}m

    elif [[ $PREVIEW_LS_COLORS == 1 &&
            $file_ext != "$file_name" &&
            $file_ext =~ ^[a-zA-Z0-9_]*$ ]]; then
        file_ext=ls_${file_ext}
        format+=\\e[${!file_ext:-${fi:-37}}m

    else
        format+=\\e[${fi:-37}m
    fi

    if [[ -n "$PREVIEW_SETECTED_HIGHLIGHT" ]]; then
        # Only highlights the selected line in normal mode
        if ((preview_mode == 0 && $1 == scroll)) || ((preview_mode == 1 && $1 == displayed_selection)); then
            format+="\\e[1;3${PREVIEW_SETECTED_HIGHLIGHT:-6};7m"
        fi

    else
        # Only highlights the selected line in normal mode
        if ((preview_mode == 0 && $1 == scroll)) || ((preview_mode == 1 && $1 == displayed_selection)); then
            # Extract the anxe codes from string format (removing the escapes)
            local current_format="${format//\\e/\e}"
            # Extract the color codes after the first [
            local color_codes="${current_format#*[}"
            color_codes="${color_codes%m*}"
            
            # Obtain the corresponding background code
            bg_code=$(get_background_from_foreground "$color_codes")
            
            # Add the background code with white and bold text
            format+="\\e[1;${bg_code};38;5;16m"
        fi
    fi

    file_name=${file_name//[^[:print:]]/^[}

    printf '\r%b%s\e[m\r' \
        "${file_pre}${format}" \
        "${file_name}${suffix}${file_post}"
}

draw_dir() {
    local scroll_start=$scroll
    local scroll_new_pos
    local scroll_end

    ((find_previous == 1)) && {
        ((scroll_start=previous_index-1))
        ((scroll=scroll_start))

        find_previous=
    }

    if ((list_total < max_items || scroll < max_items/2)); then
        ((scroll_start=0))
        ((scroll_end=max_items))
        ((scroll_new_pos=scroll+1))

    elif ((list_total - scroll < max_items/2)); then
        ((scroll_start=list_total-max_items+1))
        ((scroll_new_pos=max_items-(list_total-scroll)))
        ((scroll_end=list_total+1))

    else
        ((scroll_start=scroll-max_items/2))
        ((scroll_end=scroll_start+max_items))
        ((scroll_new_pos=max_items/2+1))
    fi

    printf '\e[H'

    if ((preview_mode == 1)); then
        # In Preview mode, we need to track which file is visually selected
        displayed_selection=scroll
    fi
    
    for ((i=scroll_start;i<scroll_end;i++)); {
        ((i > scroll_start)) &&
            printf '\n'
        print_line "$i"
    }

    if ((preview_mode == 0)); then
        # In normal mode, we move the cursor to the position of the selected file
        printf '\e[%sH' "$scroll_new_pos"
        ((y=scroll_new_pos))
    else 
        # In Preview mode, we do not move the cursor to the selected line
        printf '\e[H'
        ((y=1))
        
        draw_delimiter
        draw_file_preview
    fi
}

draw_delimiter() {
    printf '\e[%sH' "$((max_items+1))"
    printf '\e[33m%*s\e[m\n' "$COLUMNS" "" | tr ' ' '='
}

cmd_check() {
    [[ "${#no_cmd[*]}" -gt 1 ]] && msg=$(echo "${no_cmd[*]}" | awk 'BEGIN {first=1} {for (i=1; i<=NF; i++) \
    {if (first) {printf "%s", $i; first=0} else {printf " or %s", $i}}} END {print ""}') || msg="${no_cmd[*]}"
    [[ "$1" == "-msg" ]] && printf "(It was not possible to display the file)\nInstall %s\n" "$msg" && no_cmd=() && return 0
    ! command -v "$1" 1>/dev/null && no_cmd+=(\""$2"\") && return 1 || return 0
}

any_file() {
    file="$1"
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    head -n "${sizeline}" <(strings -n 10 "$file") 2>/dev/null | sed '/^[0-9]\{11\}/d' && return 0
}

_exiftool() {
    local file="$1"
    timeout -k 1 1 exiftool "$file" 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

_identify() {
    local file="$1"
    timeout -k 1 1 identify -verbose "$file" 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

_pandoc() {
    local file="$1"
    timeout -k 1 1 pandoc -s -t plain -- "$file" 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

_libreoffice() {
    local file="$1"
    local dir="$2"
    timeout -k 1 1 libreoffice --headless --convert-to txt --outdir "$dir" "$file" >/dev/null 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

_glow() {
    local file="$1"
    timeout -k 1 .6 env COLORTERM=8bit glow -s dark -- "$file" 2>/dev/null
    status=$? && [[ "$status" == 0 ]] && return 0
    [[ "$status" -gt 0 ]] && return 1
}

archive() {
    local file="$1"
    [[ "${file_ext}" =~ ^iso ]] && cmd_check isoinfo cdrtools &&
    isoinfo -i "${file}" -l | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^7z ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^rar ]] && cmd_check unrar unrar &&
    unrar lt -p- -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^rar ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^(zlib|zz)$ ]] && cmd_check zlib-flate qpdf &&
    zlib-flate -uncompress < "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^(zst|zstd)$ ]] && cmd_check zstdcat zstd &&
    zstd -lv "${file}" | head -n "${sizeline}" && return 0
    cmd_check atool atool && atool --list -- "${file}" | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    cmd_check bsdtar libarchive && ! bsdtar --list --file "${file}" &>/dev/null &&
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && return 1
    cmd_check bsdtar libarchive && bsdtar --list --file "${file}" | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^exe ]] && cmd_check 7z 7zip &&
    file "${file}" | sed -n 's/.*:\s*\(.*\)/\1/p' &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^iso ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

office_convert() {
    local file="$1"
    local temp_dir="${TMP_DIR}/temp_book"
    local temp_file="${TMP_DIR}/temp_file.md"
    [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
    [[ -d "${temp_dir}" ]] && rm -rf "${temp_dir}"

    [[ "${file_ext}" =~ ^([Cc][Ss][Vv])$ ]] && cmd_check csvtable csvtable && (csvtable "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Cc][Ss][Vv])$ ]] && cmd_check csvlook csvlook && (csvlook -S "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Cc][Ss][Vv])$ ]] && awk -F, '{ printf "%-20s %-20s %-20s\n", $1, $2, $3 }' "$file" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^([Cc][Ss][Vv])$ ]] && column -t -s, "$file" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^([Rr][Tt][Ff])$ ]] && cmd_check catdoc catdoc && (catdoc -- "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Rr][Tt][Ff])$ ]] && cmd_check unrtf unrtf && (unrtf --text "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Dd][Oo][Cc])$ ]] && cmd_check antiword antiword && (antiword "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Dd][Oo][Cc][Xx])$ ]] && cmd_check docx2txt docx2txt && (docx2txt "$file" - 2>/dev/null | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^(odt|ods|odp|sxw)$ ]] && cmd_check odt2txt odt2txt && (odt2txt "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Ss][Xx][Ww])$ ]] && cmd_check sxw2txt sxw2txt && (sxw2txt "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Xx][Ll][Ss][Xx])$ ]] && cmd_check xlsx2csv xlsx2csv && (xlsx2csv -- "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Xx][Ll][Ss][Xx])$ ]] && cmd_check xlscat xlscat && (xlscat -L -R all "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Pp][Pp][Tt][Xx])$ ]] && cmd_check pptx2md pptx2md && (pptx2md --disable-image --disable-wmf -o "$temp_file" "$file" &&
    markdown_reader "$temp_file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Ee][Pp][Uu][Bb])$ ]] && cmd_check epr epr && (epr -d "$file" 2>/dev/null |\
    sed '/^\s*$/d; /\[IMG:0\]/d; s/\[IMG:1\]//g' | fmt -w "${width}" | head -n "${sizeline}") && return 0
    cmd_check pandoc pandoc && (_pandoc "$file" | head -n "${sizeline}") && return 0
    cmd_check libreoffice libreoffice && _libreoffice "${temp_dir}" "$file" >/dev/null 2>&1 && 
    head -n "${sizeline}" "${temp_dir}"/*.txt && return 0 
    cmd_check -msg && echo && any_file "$file" && return 1
}

markdown_reader() {
    local file="$1"
    local mr="$HOME/.shell_utils/scripts/markdown_reader.sh"
    [[ -f "$mr" ]] && "$mr" -nl -- "$file" | head -n "${sizeline}" && return 0
    command -v markdown_reader.sh &>/dev/null && markdown_reader.sh -nl -- "$file" | head -n "${sizeline}" && return 0
    cmd_check glow glow && env COLORTERM=8bit glow -- "$file" | head -n "${sizeline}" && return 0
    cmd_check bat bat && env COLORTERM=8bit bat --paging=never --style=plain -- "$file" | head -n "${sizeline}" && return 0
    cmd_check mdless mdless && mdless -P -- "$file" | head -n "${sizeline}" && return 0
    cmd_check mdcat mdcat && mdcat -- "$file" | head -n "${sizeline}" && return 0
}

imgview() {
    local file="$1"
    local factor="$2"
    
    [[ "$factor" =~ ^-?[0-9]+$ ]] && {
        cmd_check img2sixel libsixel && img2sixel -w 300 -h 200 "${file}" 2>/dev/null && return 0
        cmd_check viu viu -w 50 -h 16 && viu "${file}" 2>/dev/null && return 0
        cmd_check catimg catimg && catimg -w 60 "${file}" 2>/dev/null && return 0 
        cmd_check chafa chafa && chafa -s 25 "${file}" 2>/dev/null && return 0
    }
    [[ -z "$factor" ]] && {
        cmd_check img2sixel libsixel && img2sixel -w 540 -h 420 "${file}" 2>/dev/null && return 0
        cmd_check viu viu -w 90 -h 35 && viu "${file}" 2>/dev/null && return 0
        cmd_check catimg catimg && catimg -w 100 "${file}" 2>/dev/null && return 0 
        cmd_check chafa chafa && chafa -s 50 "${file}" 2>/dev/null && return 0
    }
    cmd_check exiftool perl-image-exiftool && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_exiftool "${file}" | head -n "${sizeline}") && return 0
    cmd_check identify imagemagick && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_identify "${file}" | head -n "${sizeline}") && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

fontview() {
    local file="$1"
    temp_file="${TMP_DIR}/temp_file.png"
    [[ -f "$temp_file" ]] && rm -f "$temp_file"
    cmd_check fontimage fontforge && fontimage -o "${temp_file}" \
                    --pixelsize "120" \
                    --fontname \
                    --pixelsize "80" \
                    --text "  ABCDEFGHIJKLMNOPQRSTUVWXYZ  " \
                    --text "  abcdefghijklmnopqrstuvwxyz  " \
                    --text "  0123456789.:,;(*!?') ff fl fi ffi ffl  " \
                    --text "  A white sheep peacefully grazes on the green pasture.  " \
                    "${file}" </dev/null 2>/dev/null &&
    [[ -f "$temp_file" ]] && imgview "$temp_file" && return 0
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && 
    [[ "${file_ext}" =~ ^(ttf|ttc|otf|pfa|pfb|ps|bdf|gbdf|pcf|snf|nfnt|fon|fnt|woff|woff2|svg|sfnt|sfd)$ ]] && 
    echo && cmd_check -msg && return 1
}

img2info() {
    local file="$1"
    temp_file="${TMP_DIR}/temp_file.jpg"
    [[ -f "$temp_file" ]] && rm -f "$temp_file"

    cmd_check magick imagemagick && ls "${TMP_DIR}" && 
    magick -- "${file}[0]" -auto-orient -filter Box -resize "$RESOLUTION" -quality 85 "$temp_file" 2>/dev/null &&
    [[ -f "$temp_file" ]] && imgview "$temp_file" && return 0
    cmd_check exiftool perl-image-exiftool && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_exiftool "${file}" | head -n "${sizeline}") && return 0
    cmd_check identify imagemagick && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_identify "${file}" | head -n "${sizeline}") && return 0
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo && cmd_check -msg && return 1
}

video2static() {
    local file="$1"
    local sizeline=27
    local info="${TMP_DIR}/info.txt"
    local resolution="${RESOLUTION/x/:}"
    local temp_file="${TMP_DIR}/temp_file.jpg"
    [[ "${OS,,}" =~ "android" ]] && local sizeline=11

    function if_ff_extract {
        [[ -f "$temp_file" ]] && {
            # echo "$(imgview "$temp_file" 2)" > "${info}"
            # echo "$(media_info "$file" | fold -w "${FOLD:-100}")" >> "${info}"
            # column -t -s $'\n' "${info}"
            # rm -f "${info}"
            imgview "$temp_file" 2
            media_info "$file"
        } && return 0
    }

    [[ -f "$info" ]] && rm -f "$info"
    [[ -f "$temp_file" ]] && rm -f "$temp_file"
    cmd_check ffmpeg ffmpeg && 
    # black_start=$(ffmpeg -i "${file}" -vf "blackdetect=d=0.1:pic_th=0.98" -f null - 2>&1 | \
    # awk -F'start:' '/black_start/ {print $2}' | awk '{print $1}' | head -n 1) &&
    # [[ -n "$black_start" ]] && ffmpeg -i "${file}" -ss "$black_start" -frames:v 1 "$temp_file" </dev/null 2>/dev/null &&
    ffmpeg -i "${file}" -vf "select=eq(n\,30),scale=$resolution" -vsync vfr -frames:v 1 -q:v 5 "$temp_file" </dev/null 2>/dev/null &&
    if_ff_extract && return 0
    ffmpeg -i "${file}" -vf "scale=$resolution" -vsync vfr -frames:v 1 -q:v 5 "$temp_file" </dev/null 2>/dev/null &&
    if_ff_extract && return 0
    media_info "${file}" && return 0
    return 1
}

media_info() {
    local file="$1"
    [[ "$sizeline" != 11 ]] && sizeline=27
    # [[ "${OS,,}" =~ "android" ]] && cmd_check mediainfo mediainfo && 
    # mediainfo "${file}" | sed '/General/d; /Complete name/d; s/                   //; s|\(.*:\)\s*.*/\([^/]*\)\(\.[^.]*\)$|\1\3|' | head -n "${sizeline}" && return 0
    cmd_check mediainfo mediainfo && mediainfo "${file}" |\
    sed '/General/d; /Complete name/d; /^Video/d; /^Audio/d; /^$/d; s/                   //; s|\(.*:\)\s*.*/|\1 |' |\
    head -n "${sizeline}" && return 0
    cmd_check exiftool perl-image-exiftool && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_exiftool "${file}" | head -n "${sizeline}") && return 0
    cmd_check ffmpeg ffmpeg && ffmpeg -i "${file}" 2>/dev/null && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

pdfview() {
    local file="$1"
    temp_file="${TMP_DIR}/temp_file.jpg"
    [[ -f "$temp_file" ]] && rm -f "$temp_file"

    cmd_check pdftotext poppler && 
    pdf_lines=$(pdftotext -l 1 -nopgbrk -q -- "${file}" - | wc -l) &&
    [[ "$pdf_lines" -gt 0 ]] &&
    pdftotext -l 1 -nopgbrk -q -- "${file}" - | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    cmd_check mutool mupdf && mutool draw -F txt -i -- "${file}" 1-10 | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0 
    cmd_check magick imagemagick && 
    magick -- "${file}[0]" -auto-orient -filter Box -resize "$RESOLUTION" -quality 85 "$temp_file" 2>/dev/null &&
    [[ -f "$temp_file" ]] && imgview "$temp_file" && return 0
    cmd_check pdfinfo poppler && pdfinfo "$file" && return 0
    cmd_check exiftool perl-image-exiftool && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_exiftool "${file}" | head -n "${sizeline}") && return 0
    cmd_check identify imagemagick && file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo &&
    (_identify "${file}" | head -n "${sizeline}") && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

torrentview() {
    local file="$1"
    cmd_check transmission-show transmission-cli && transmission-show -- "$file" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

djvuview() {
    local file="$1"
    cmd_check djvutxt djvutxt && djvutxt "$file" | head -n "${sizeline}" && return 0
    cmd_check exiftool exiftool &&
    (_exiftool "${file}" | head -n "${sizeline}") && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

podview() {
    local file="$1"
    cmd_check pod2text pod2text && pod2text "$file" 2>/dev/null | head -n "${sizeline}" && return 0
    cmd_check perldoc perldoc && perldoc -T "$file" 2>/dev/null | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

psview() {
    local file="$1"
    cmd_check ps2ascii ghostscript && nodash ps2ascii "$file" 2>/dev/null | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

classview() {
    local file="$1"
    cmd_check procyon-decompiler procyon-decompiler && procyon-decompiler "$file" 2>/dev/null | head -n "${sizeline}" && return 0
    cmd_check procyon procyon && procyon "$file" 2>/dev/null | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

dviview() {
    local file="$1"
    cmd_check dvi2tty dvi2tty && dvi2tty -q "$file" | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

pgpview() {
    local file="$1"
    cmd_check gpg gnupg && gpg --decrypt --quiet --no-tty --batch --yes "$file" | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

opensslview() {
    local file="$1"
    [[ "${file_ext}" =~ ^([Cc][Ss][Rr])$ ]] && 
    cmd_check openssl openssl && openssl req -text -noout -in "$file" | head -n "${sizeline}" && return 0
    cmd_check openssl openssl && openssl storeutl -text -noout "$file" | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

jsonview() {
    local file="$1"
    cmd_check jq jq && jq --color-output . "${file}" | head -n "${sizeline}" && return 0
    cmd_check python python && python -m json.tool -- "${file}" | head -n "${sizeline}" && return 0
    cmd_check -msg && echo && any_file "$file" && return 1
}

nexttmp () {
	declare new="${TMP_DIR}/preview.$RANDOM"
	echo "$new"
}

nodash() {
	prog="$1"
	shift
	[[ "$1" == - ]] && shift
	$prog "$@"
}

handle_w3m() {
	if [[ "$1" == *\?* ]]; then
		t=$(nexttmp)
		ln -s "$1" "$t"
		set "$t" "$1"
	fi
	nodash "w3m -dump -T text/html" "$1"
}

_html2text() {
    nodash html2text "$1" "$2" | less -i &
    less_pid=$!
    wait "$less_pid" 
    return 0
}

ishtml() {
	[[ "$1" == - ]] && arg1=-stdin || arg1="$1"
	htmlopt=--unicode-snob
	cmd_check html2text python-html2text && html2text -utf8 </dev/null 2>/dev/null && htmlopt=-utf8
	# 3 lines following can easily be reshuffled according to the preferred tool
	cmd_check elinks elinks && nodash "elinks -dump -force-html" "$1" </dev/null 2>/dev/null && return 0
	cmd_check w3m w3m && handle_w3m "$1" </dev/null 2>/dev/null && return 0
	cmd_check lynx lynx && lynx -force_html -dump "$arg1" </dev/null 2>/dev/null && return 0
	# different versions of html2text existingi, force unicode
	[[ "$1" == https://* ]] && return 0
	cmd_check html2text python-html2text && _html2text "$htmlopt" "$1" </dev/null 2>/dev/null && return 0
    file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p' && echo && cmd_check -msg && return 1
}

highlight_code() {
    local file="$1"
    COLOR_RESET='\033[0m' 
    COLOR_CODE='\033[38;5;155;48;5;241m'
    HIGHLIGHT_OPTIONS="--replace-tabs=${HIGHLIGHT_TABWIDTH:-8} --style=${HIGHLIGHT_STYLE:-pablo} ${HIGHLIGHT_OPTIONS:-}"

    ## Syntax highlight
    if [[ "$( tput colors )" -ge 256 ]]; then
        local pygmentize_format='terminal256'
        local highlight_format='xterm256'
    else
        local pygmentize_format='terminal'
        local highlight_format='ansi'
    fi
    if [ -z "$lang" ]; then
        lang="$file_ext"  # Default language
    fi

    # Attempt syntax highlighting with specified language
    cmd_check bat bat && env COLORTERM=8bit bat --color=always --style="plain" -- "${file}" && return 0
    cmd_check source-highlight source-highlight &&
    source-highlight -f esc -s "$lang" -i "$file" 2>/dev/null && return 0
    cmd_check pygmentize python-pygments && 
    pygmentize -f "${pygmentize_format}" -O "style=${PYGMENTIZE_STYLE:-autumn}" -- "${file}" && return 0
    cmd_check highlight highlight && env HIGHLIGHT_OPTIONS="${HIGHLIGHT_OPTIONS}" highlight \
        --out-format="${highlight_format}" \
        --force -- "${file}" 2>/dev/null && return 0
    cmd_check glow glow && _glow "${file}" && return 0
    cmd_check mdless mdless && mdless -P -- "${file}" && return 0
    cmd_check mdcat mdcat && mdcat -- "${file}" && return 0
    while IFS= read -r line; do
        printf "${COLOR_CODE}%s${COLOR_RESET}\n" "$line"
    done < "$file"
}

margin() {
    local file="$1"
    cmd_check fold coreutils || cmd_check -msg
    cmd_check awk gawk || cmd_check -msg
    #fold -w 150 "$1" | sed 's/^/          /' | less -i &
    # [[ "${OS,,}" =~ "android" ]] && fold -w "${FOLD:-50}" "$file" | awk '{print "   " $0 "   "}' | \
    # head -n "${sizeline}" && return 0
    fmt -w "${width}" -u "$file" | awk '{printf "%-20s\n", $0}' | head -n "${sizeline}" && return 0
}

draw_file_preview() {
    local selected_file="${list[scroll]}"
    [[ "${OS,,}" != "android" ]] && local sizeline="${sizeline:-30}"
    [[ "${OS,,}" =~ "android" ]] && local sizeline="${sizeline:-20}"
    [[ "${OS,,}" != "android" ]] && local width="${width:-200}"
    [[ "${OS,,}" =~ "android" ]] && local width="${width:-50}"
    
    # Cleans the preview area
    for ((i=max_items+2; i<LINES-1; i++)); do
        printf '\e[%sH\e[K' "$i"
    done
    
    printf '\e[%sH' "$((max_items+2))"
    
    if [[ -f "$selected_file" ]]; then
        local file_ext="${selected_file##*.}"
        file_ext="${file_ext,,}" # lowercase
        
        # Displays the current file name in the preview area
        printf '\e[36mFile: %s\e[m\n\n' "${selected_file##*/}"

        case "$file_ext" in
            a|apk|apk+|xapk|ace|alz|arc|arj|bz|bz2|cab|cpio|deb|gz|jar|oxt|lha|lz|lzh|lzma|lzo|rar|exe|rpm|\
            7z|7zz|7za|7zr|rz|t7z|tar|tbz|tbz2|tgz|tlz|txz|tZ|tzo|war|xpi|xz|Z|zip|zst|zstd|iso|vsix|zlib|zz)
                [[ "${file}" =~ \.img(\.[^.]+)?$ ]] && any_file "$selected_file" && return 0
                [[ "$file_ext" == "tar" ]] && any_file "$selected_file" && return 0
                if ! archive "$selected_file"; then
                    return 1
                else
                    return 0
                fi
                ;;
            img)
                any_file "$selected_file" && return 0
                ;;
            txt)
                margin "$selected_file" && return 0
                ;;
            md|markdown)
                if ! markdown_reader "$selected_file"; then
                    return 1
                else
                    return 0
                fi
                ;;
            class)
                if ! classview "$selected_file"; then
                    return 1
                else
                    return 0
                fi
                ;;
            pod)
                if ! podview "$selected_file"; then
                    printf '\n\e[33mPOD file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            pdf)
                if ! pdfview "$selected_file"; then
                    printf '\n\e[33mPDF file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            torrent)
                if ! torrentview "$selected_file"; then
                    printf '\n\e[33mTorrent file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            mp4|m4v|mov|avi|wmv|flv|webm|mkv|mpg|mpeg|3gp|3g2|ogv|asf|rm|rmvb|vob|ts|m2ts|mts|f4v|divx)
                if ! video2static "$selected_file"; then
                    printf '\n\e[33mVideo file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            mp3|wav|aac|m4a|flac|ogg|oga|opus|wma|alac|aiff|aif|au|snd|amr|ac3|dts|caf|mka|dff|dsf|wv|wvc)
                if ! media_info "$selected_file"; then
                    printf '\n\e[33mAudio file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            png|jpg|jpeg)
                if ! imgview "$selected_file"; then
                    printf '\n\e[33mImage file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            rtf|odt|ods|odp|sxw|doc|docx|xls|xlsx|ipynb|epub|ppt|pptx|csv)
                if ! office_convert "$selected_file"; then
                    printf '\n\e[33mOffice file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            djvu)
                if ! djvuview "$selected_file"; then
                    printf '\n\e[33mDjvu file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            postscript|ps)
                if ! psview "$selected_file"; then
                    printf '\n\e[33mPS file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            x509|crl|csr)
                if ! opensslview "$selected_file"; then
                    printf '\n\e[33mx509/CRL/CSR/CA file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            pgp)
                if ! pgpview "$selected_file"; then
                    printf '\n\e[33mPGP file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            dvi)
                if ! dviview "$selected_file"; then
                    printf '\n\e[33mDVI file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            htm|html|xhtml)
                if ! ishtml "$selected_file" |\
                fmt -w "${width}" | head -n "${sizeline}"; then
                    printf '\n\e[33mWeb file: %s\e[m\n' "${selected_file##*/}" 
                    return 1
                else
                    return 0
                fi
                ;;
            json)
                if ! jsonview "$selected_file"; then
                    printf '\n\e[33mJSON file: %s\e[m\n' "${selected_file##*/}"
                    return 1
                else
                    return 0
                fi
                ;;
            *)
                get_mime_type "$selected_file"
                if [[ "$mime_type" == *"font"* ]]; then
                    if ! fontview "$selected_file"; then
                        printf '\n\e[33mFont file: %s\e[m\n' "${selected_file##*/}"
                        return 1
                    else
                        return 0
                    fi
                elif [[ "$mime_type" == *"image"* || "$mime_type" =~ "image" ]]; then
                    if ! img2info "$selected_file"; then
                        printf '\n\e[33mImage file: %s\e[m\n' "${selected_file##*/}"
                        return 1
                    else
                        return 0
                    fi
                elif [[ "$mime_type" == *"text"* || "$mime_type" == *"xml"* || "$mime_type" == *"empty"* || "$mime_type2" =~ ^text/.+|application/xml$ ]]; then
                    highlight_code "$selected_file" | head -n "${sizeline}" 2>/dev/null
                    return 0
                elif [[ "$mime_type_full" =~ (audio|sound|video|media) || "$mime_type" =~ (audio|video) || "$mime_type2" =~ ^(video|audio)/.+$ ]]; then
                    if ! media_info "$selected_file"; then
                        printf '\n\e[33mMedia file: %s\e[m\n' "${selected_file##*/}"
                        return 1
                    else
                        return 0
                    fi
                else
                    any_file "$selected_file" && return 0
                    return 1
                fi
                ;;
        esac

    elif [[ -d "$selected_file" ]]; then
        local leng="$(ls -1A "$selected_file" | wc -l)"
        printf '\e[36mDirectory: %s\e[m\n' "${selected_file##*/}"
        [[ "$leng" == 0 ]] && printf '\e[36mEmpty folder\e[m\n\n'
        [[ "$leng" -gt 0 ]] && printf '\e[36mTotal Files: %s\e[m\n\n' "$leng"
        ls -lha --group-directories-first --color=always "$selected_file" | head -n 2
        printf '%s\n' "----------------------------------------------------"
        # Count the number of items returned by LS
        item_count=$(ls -pa --group-directories-first "$selected_file" | wc -l)
        # Check that the number of items is greater than 30
        if [ "$item_count" -le 30 ]; then
            # If it is less than 30, displays all items with intact colors
            ls -pa --group-directories-first --color=always "$selected_file"
            return 0
        else
            # If it is more than 30, it limits the display for the first 30 items
            ls -pa --group-directories-first --color=always "$selected_file" | head -n "${sizeline}"
            return 0
        fi
    else
        printf '\e[33mNo selected files\e[m\n'
        return 1
    fi
}

redraw() {
    [[ "$1" == full ]] && {
        read_dir
        scroll=0
    }

    clear_screen
    draw_dir
    status_line
}

toggle_preview_mode() {
    preview_mode=$((preview_mode == 0 ? 1 : 0))
    get_term_size
    redraw
}

xdg_open() {
    nohup "${PREVIEW_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
    disown
}

open() {
    if [[ -d "$1"/ ]]; then
        search=
        search_end_early=
        cd "${1:-/}" ||:
        redraw full

    elif [[ -f "$1" ]]; then
        get_mime_type "$1"

        case "$mime_type" in
            text/*|*x-empty*|*json*)
                ((file_picker == 1)) && {
                    printf '%s\n' "$1" > \
                        "${XDG_CACHE_HOME:=${HOME}/.cache}/preview/opened_file"
                    exit
                }

                clear_screen
                reset_terminal
                "${VISUAL:-${EDITOR:-vi}}" "$1"
                setup_terminal
                redraw
            ;;

            *)
                nohup "${PREVIEW_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                disown
            ;;
        esac
    fi
}

cmd_line() {
    cmd_reply=${4:-}  # Set initial value if provided as 4th parameter
    printf '\e7\e[%sH\e[?25h' "$LINES"

    while IFS= read -rsn 1 -p $'\r\e[K'"${1}${cmd_reply}" read_reply; do
        case $read_reply in
            $'\177'|$'\b')
                cmd_reply=${cmd_reply%?}
                unset comp c
            ;;
            $'\t')
                comp_glob="$cmd_reply*"

                [[ $2 == dirs ]] &&
                    comp_glob="$cmd_reply*/"

                [[ -z ${comp[0]} ]] &&
                    IFS=$'\n' read -d "" -ra comp < <(compgen -G "$comp_glob")

                [[ -n ${comp[c]} ]] && {
                    cmd_reply=${comp[c]}
                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
                }
            ;;
            $'\e'|${3:-null})
                read "${read_flags[@]}" -rsn 2
                cmd_reply=
                break
            ;;
            "")
                [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {
                    printf '\e[?25l'

                    open "${list[0]}"
                    search_end_early=1
                    unset comp c
                    return
                }

                break
            ;;
            ${2:-null})
                cmd_reply=$read_reply
                break
            ;;
            "~")
                cmd_reply+=$HOME
            ;;
            *)
                cmd_reply+=$read_reply
                unset comp c
            ;;
        esac

        [[ $2 == search ]] && {
            printf '\e[?25l'

            list=("$PWD"/*"$cmd_reply"*)
            ((list_total=${#list[@]}-1))

            scroll=0
            redraw
            printf '\e[%sH\e[?25h' "$LINES"
        }
    done
    unset comp c
    printf '\e[2K\e[?25l\e8'
}

keys() {
    local key="$1"
    [[ "${OS,,}" =~ "android" ]] && LOOP_SCROLL=0

    [[ "$key" == $'\e' ]] && {
        read "${read_flags[@]}" -rsn 2

        [[ "${1}${REPLY}" == $'\e\e['* ]] &&
            read "${read_flags[@]}" -rsn 1 _

        local special_key="${1}${REPLY}"
    }

    case "${special_key:-$key}" in
        [0-9])
            fav_var="PREVIEW_FAV_$key"
            # Check if the favorite directory is set
            if [[ -z "${!fav_var}" ]]; then
                # No favorite directory set for this number
                printf '\e7\e[%sH\e[K%s\e8' "$LINES" "Favorite directory not set for key $key. Use export PREVIEW_FAV_$key='/path/to/directory' to set."
                # read -n 1 -s -r -p "" </dev/tty >/dev/null 2>/dev/null
                # printf '\e[%sH\e[K\e8' "$LINES"  # Clear line
            else
                # Attempt to change to the favorite directory
                if [[ -d "${!fav_var}" ]]; then
                    cd "${!fav_var}" &>/dev/null ||:
                    open "$PWD"
                else
                    # Directory does not exist
                    printf '\e7\e[%sH\e[K%s\e8' "$LINES" "Error: Favorite directory ${!fav_var} does not exist."
                    # read -n 1 -s -r -p "" </dev/tty >/dev/null 2>/dev/null
                    # printf '\e[%sH\e[K\e8' "$LINES"  # Clear line
                fi
            fi
        ;;
        ${PREVIEW_KEY_ERASE:=E})
            [[ ! -e "${list[scroll]}" ]] &&
                return
                cmd_line "delete ${list[scroll]##*/}? (y/N): "
            [[ "$cmd_reply" =~ ^[Yy]$ ]] &&
                if [[ -w "${list[scroll]}" ]]; then
                    if [[ -d "${list[scroll]}" ]]; then
                        rm -rf "${list[scroll]}"
                    else
                        rm -f "${list[scroll]}"
                    fi
                    redraw full
                else
                    cmd_line "warn: no write access to file/directory."
                fi
        ;;
        ${PREVIEW_KEY_PREVIEW1:=P}|\
        ${PREVIEW_KEY_PREVIEW2:=$'\x10'}) # Ctrl+P
            toggle_preview_mode
        ;;
        ${PREVIEW_KEY_XDG_OPEN:=""})
            xdg_open "${list[scroll]}"
        ;;
        ${PREVIEW_KEY_CHILD1:=l}|\
        ${PREVIEW_KEY_CHILD2:=$'\e[C'}|\
        ${PREVIEW_KEY_CHILD3:=$'\eOC'})
            open "${list[scroll]}"
        ;;
        ${PREVIEW_KEY_PARENT1:=h}|\
        ${PREVIEW_KEY_PARENT2:=$'\e[D'}|\
        ${PREVIEW_KEY_PARENT3:=$'\177'}|\
        ${PREVIEW_KEY_PARENT4:=$'\b'}|\
        ${PREVIEW_KEY_PARENT5:=$'\eOD'})
            if ((search == 1 && search_end_early != 1)); then
                open "$PWD"

            elif [[ $PWD && $PWD != / ]]; then
                find_previous=1
                open "${PWD%/*}"
            fi
        ;;
        ${PREVIEW_KEY_SCROLL_DOWN1:=j}|\
        ${PREVIEW_KEY_SCROLL_DOWN2:=$'\e[B'}|\
        ${PREVIEW_KEY_SCROLL_DOWN3:=$'\eOB'})
            if [[ "${LOOP_SCROLL:-1}" == 0 ]]; then
                ((scroll < list_total)) && {
                    ((scroll++))
                    
                    if ((preview_mode == 0)); then
                        ((y < max_items)) && ((y++))
                        print_line "$((scroll-1))"
                        printf '\n'
                        print_line "$scroll"
                    else
                        # No modo preview, apenas atualizamos a área de preview
                        draw_file_preview
                        # Redraw para atualizar o status line
                        redraw
                        return
                    fi
                    
                    status_line
                }
            else
                if ((scroll < list_total)); then
                    ((scroll++))
                else
                    # Se estiver no último item, volta para o primeiro
                    ((scroll=0))
                    redraw
                    return
                fi
                
                if ((preview_mode == 0)); then
                    ((y < max_items)) && ((y++))
                    print_line "$((scroll-1))"
                    printf '\n'
                    print_line "$scroll"
                else
                    # No modo preview, apenas atualizamos a área de preview
                    draw_file_preview
                    # Redraw para atualizar o status line
                    redraw
                    return
                fi

                status_line
            fi
        ;;
        ${PREVIEW_KEY_SCROLL_UP1:=k}|\
        ${PREVIEW_KEY_SCROLL_UP2:=$'\e[A'}|\
        ${PREVIEW_KEY_SCROLL_UP3:=$'\eOA'})
            if [[ "${LOOP_SCROLL:-1}" == 0 ]]; then
                ((scroll > 0)) && {
                    ((scroll--))

                    if ((preview_mode == 0)); then
                        print_line "$((scroll+1))"

                        if ((y < 2)); then
                            printf '\e[L'
                        else
                            printf '\e[A'
                            ((y--))
                        fi

                        print_line "$scroll"
                    else
                        # No modo preview, apenas atualizamos a área de preview
                        draw_file_preview
                        # Redraw para atualizar o status line
                        redraw
                        return
                    fi

                    status_line
                }
            else
                if ((scroll > 0)); then
                    ((scroll--))
                else
                    # Se estiver no primeiro item, vai para o último
                    ((scroll=list_total))
                    redraw
                    return
                fi

                if ((preview_mode == 0)); then
                    print_line "$((scroll+1))"

                    if ((y < 2)); then
                        printf '\e[L'
                    else
                        printf '\e[A'
                        ((y--))
                    fi

                    print_line "$scroll"
                else
                    # No modo preview, apenas atualizamos a área de preview
                    draw_file_preview
                    # Redraw para atualizar o status line
                    redraw
                    return
                fi

                status_line
            fi
        ;;
        ${PREVIEW_KEY_TO_TOP:=g})
            ((scroll != 0)) && {
                scroll=0
                redraw
            }
        ;;
        ${PREVIEW_KEY_TO_BOTTOM:=G})
            ((scroll != list_total)) && {
                ((scroll=list_total))
                redraw
            }
        ;;
        ${PREVIEW_KEY_HIDDEN:=.})
            shopt_flags=(u s)
            shopt -"${shopt_flags[((a=${a:=$PREVIEW_HIDDEN}>0?0:++a))]}" dotglob
            redraw full
        ;;
        ${PREVIEW_KEY_SEARCH:=/})
            cmd_line "/" "search"
            if [[ -z ${list[*]} ]]; then
                list=("${cur_list[@]}")
                ((list_total=${#list[@]}-1))
                redraw
                search=
            else
                search=1
            fi
        ;;
        ${PREVIEW_KEY_SHELL:=!})
            reset_terminal
            export PREVIEW_LEVEL
            ((PREVIEW_LEVEL++))

            cd "$PWD" && "$SHELL"
            setup_terminal
            redraw full
        ;;

        ${PREVIEW_KEY_COPY:=C})
            [[ ! -e "${list[scroll]}" ]] &&
                return
            
            # Generate suggested name with _copy suffix
            local filename="${list[scroll]##*/}"
            local basename="${filename%.*}"
            local extension="${filename##*.}"
            
            # Handle files without extension
            if [[ "$basename" == "$extension" ]]; then
                suggested_name="${basename}_copy"
            else
                suggested_name="${basename}_copy.${extension}"
            fi
            
            cmd_line "copy ${filename} to: " "" "" "$suggested_name"
            
            [[ "$cmd_reply" ]] &&
                if [[ -e "${PWD}/${cmd_reply}" ]]; then
                    cmd_line "warn: '${cmd_reply}' already exists. Overwrite? (y/N): "
                    
                    if [[ "$cmd_reply" =~ ^[Yy]$ ]]; then
                        if cp -r "${list[scroll]}" "${PWD}/${cmd_reply}" 2>/dev/null; then
                            redraw full
                        else
                            cmd_line "warn: copy failed."
                        fi
                    fi
                elif [[ -r "${list[scroll]}" ]]; then
                    if cp -r "${list[scroll]}" "${PWD}/${cmd_reply}" 2>/dev/null; then
                        redraw full
                    else
                        cmd_line "warn: copy failed."
                    fi
                else
                    cmd_line "warn: no read access to file/directory."
                fi
        ;;

        ${PREVIEW_KEY_RENAME:=R})
            [[ ! -e ${list[scroll]} ]] && [[ ! -w ${list[scroll]} ]] &&
                return

            cmd_line "rename ${list[scroll]##*/}: "

            [[ "$cmd_reply" ]] &&
                if [[ -e "$cmd_reply" ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w "${list[scroll]}" ]]; then
                    mv "${list[scroll]}" "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to file."
                fi
        ;;
        ${PREVIEW_KEY_MKDIR:=M})
            cmd_line "mkdir: " "dirs"

            [[ "$cmd_reply" ]] &&
                if [[ -e "$cmd_reply" ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w "$PWD" ]]; then
                    mkdir -p "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;
        ${PREVIEW_KEY_MKFILE:=F})
            cmd_line "mkfile: "

            [[ "$cmd_reply" ]] &&
                if [[ -e "$cmd_reply" ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w "$PWD" ]]; then
                    : > "$cmd_reply"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;
        ${PREVIEW_KEY_GO_DIR:=$'\x07'}) # Control+G
            cmd_line "go to dir: " "dirs"

            cd "$PWD" &>/dev/null ||:

            [[ "$cmd_reply" ]] &&
                cd "${cmd_reply/\~/$HOME}" &>/dev/null &&
                    open "$PWD"
        ;;
        ${PREVIEW_KEY_GO_HOME1:='~'}|\
        ${PREVIEW_KEY_GO_HOME2:=H})
            open ~
        ;;
        ${PREVIEW_KEY_PREVIOUS:=-})
            open "$OLDPWD"
        ;;
        ${PREVIEW_KEY_REFRESH:=A})
            open "$PWD"
        ;;
        # Control+D
        ${PREVIEW_KEY_QUIT1:=$'\x04'}|\
        ${PREVIEW_KEY_QUIT2:='='}|\
        ${PREVIEW_KEY_QUIT3:=Q}|\
        ${PREVIEW_KEY_QUIT4:=q})
            : "${PREVIEW_CD_FILE:=${XDG_CACHE_HOME:=${HOME}/.cache}/preview/.preview_d}"

            [[ -w "$PREVIEW_CD_FILE" ]] &&
                rm "$PREVIEW_CD_FILE"

            [[ "${PREVIEW_CD_ON_EXIT:=1}" == 1 ]] &&
                printf '%s\n' "$PWD" > "$PREVIEW_CD_FILE"

            clear
            exit 0
        ;;
    esac
    if ((search == 1)); then
        case ${special_key:-$1} in
            ${PREVIEW_KEY_EXIT_CLEAR_SEARCH1:="'"}|\
            ${PREVIEW_KEY_EXIT_CLEAR_SEARCH2:=\"})

            # Maintains the current selected file
            local current_selection=${list[scroll]}
            
            # Restores the original list
            list=("${cur_list[@]}")
            ((list_total=${#list[@]}-1))
            
            # Finds the file index selected in the original list
            for ((i=0; i<=list_total; i++)); do
                if [[ "${list[i]}" == "$current_selection" ]]; then
                    scroll=$i
                    break
                fi
            done
            
            # Redefines the search state
            search=
            
            # Redesign the screen
            redraw

            ;;
        esac
    fi
}

main() {
    OS=$(uname -o)
    SCRIPT="${0##*/}"
    TMPDIR="${TMPDIR:-/tmp}"
    TMP_DIR="${TMPDIR}/${SCRIPT%.*}"
    CACHE_PATH="${XDG_CACHE_HOME:=${HOME}/.cache}/preview"
    CONFIG_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/preview"
    
    # Read the user settings, if any, first of all
    setup_config

    RESOLUTION="${RESOLUTION:-854x480}"
    RESOLUTION="${RESOLUTION/X/x}"
    LS_C="rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:*.exe=00;33:ex=01;32:*.7z=01;31:*.ace=01;31:*.alz=01;31:*.apk=01;31:*.xapk=01;31:*.apk+=01;31:*.arc=01;31:*.arj=01;31:*.bz=01;31:*.bz2=01;31:*.cab=01;31:*.cpio=01;31:*.crate=01;31:*.deb=01;31:*.drpm=01;31:*.dwm=01;31:*.dz=01;31:*.ear=01;31:*.egg=01;31:*.esd=01;31:*.gz=01;31:*.jar=01;31:*.lha=01;31:*.lrz=01;31:*.lz=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.lzo=01;31:*.pyz=01;31:*.rar=01;31:*.rpm=01;31:*.rz=01;31:*.sar=01;31:*.swm=01;31:*.t7z=01;31:*.tar=01;31:*.taz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tgz=01;31:*.tlz=01;31:*.txz=01;31:*.tz=01;31:*.tzo=01;31:*.tzst=01;31:*.udeb=01;31:*.war=01;31:*.whl=01;31:*.wim=01;31:*.xz=01;31:*.z=01;31:*.zip=01;31:*.zoo=01;31:*.zst=01;31:*.avif=01;35:*.pdf=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:"
    export LS_COLORS="${LS_COLORS:-$LS_C}"
    [[ -d "${TMP_DIR}" ]] && rm -rf "${TMP_DIR}"
    [[ ! -d "$CONFIG_PATH" ]] && mkdir -p "$CONFIG_PATH"
    [[ ! -d "$CACHE_PATH" ]] && mkdir -p "$CACHE_PATH"
    [[ ! -d "${TMP_DIR}" ]] && mkdir -p "${TMP_DIR}"

    cd "${2:-$1}" &>/dev/null ||:

    [[ "$1" == -v ]] && {
        printf '%s\n' "preview 1.0"
        exit
    }

    [[ "$1" == -h ]] && {
        man preview
        exit
    }

    [[ "$1" == -p ]] &&
        file_picker=1

    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.05)

    ((${PREVIEW_LS_COLORS:=1} == 1)) &&
        get_ls_colors

    ((${PREVIEW_HIDDEN:=0} == 1)) &&
        shopt -s dotglob

    shopt -s nocaseglob nullglob

    trap 'reset_terminal' EXIT
    trap 'get_term_size; redraw' WINCH
    
    # Preview mode boot (now as standard)
    preview_mode=1
    displayed_selection=0

    get_os
    get_term_size
    setup_options
    setup_terminal
    redraw full

    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && keys "$REPLY"

        [[ -t 1 ]] || exit 1
    }
}

main "$@"