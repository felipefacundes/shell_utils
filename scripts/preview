#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
A simple file manager with file preview based on "fff" and "ranger". It uses "lf" as a base, 
adding support for file preview with "ueberzug" and integration with custom commands for efficient navigation. 
It includes configurable shortcuts to simplify file manipulation.
DOCUMENTATION

SCRIPT="${0##*/}"
TMPDIR="${TMPDIR:-/tmp}"
LOOP_SCROLL="${LOOP_SCROLL:-1}"
TMP_DIR="${TMPDIR}/${SCRIPT%.*}"
export LS_COLORS="rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.7z=01;31:*.ace=01;31:*.alz=01;31:*.apk=01;31:*.arc=01;31:*.arj=01;31:*.bz=01;31:*.bz2=01;31:*.cab=01;31:*.cpio=01;31:*.crate=01;31:*.deb=01;31:*.drpm=01;31:*.dwm=01;31:*.dz=01;31:*.ear=01;31:*.egg=01;31:*.esd=01;31:*.gz=01;31:*.jar=01;31:*.lha=01;31:*.lrz=01;31:*.lz=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.lzo=01;31:*.pyz=01;31:*.rar=01;31:*.rpm=01;31:*.rz=01;31:*.sar=01;31:*.swm=01;31:*.t7z=01;31:*.tar=01;31:*.taz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tgz=01;31:*.tlz=01;31:*.txz=01;31:*.tz=01;31:*.tzo=01;31:*.tzst=01;31:*.udeb=01;31:*.war=01;31:*.whl=01;31:*.wim=01;31:*.xz=01;31:*.z=01;31:*.zip=01;31:*.zoo=01;31:*.zst=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:"

get_os() {
    case $OSTYPE in
        darwin*)
            opener=open
            file_flags=bIL
        ;;
        haiku)
            opener=open
        ;;
    esac
}

setup_terminal() {
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"
    stty -echo
}

reset_terminal() {
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'
    stty echo
}

clear_screen() {
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_items"
}

setup_options() {
    [[ $PREVIEW_FILE_FORMAT == *%f* ]] && {
        file_pre=${PREVIEW_FILE_FORMAT/'%f'*}
        file_post=${PREVIEW_FILE_FORMAT/*'%f'}
    }

    file -I &>/dev/null || : "${file_flags:=biL}"
}

get_term_size() {
    read -r LINES COLUMNS < <(stty size)
    
    if ((preview_mode == 1)); then
        ((max_items=9))
        ((preview_area=LINES-max_items-3)) # -3 For the delimiter and status line
    else
        ((max_items=LINES-3))
    fi
}

get_ls_colors() {
    [[ -z $LS_COLORS ]] && {
        PREVIEW_LS_COLORS=0
        return
    }

    IFS=: read -ra ls_cols <<< "$LS_COLORS"

    for ((i=0;i<${#ls_cols[@]};i++)); {
        [[ ${ls_cols[i]} =~ ^\*[^\.] ]] &&
            ls_patterns+="${ls_cols[i]/=*}|"

        [[ ${ls_cols[i]} =~ ^(\*|\.) ]] && {
            ls_cols[i]=${ls_cols[i]#\*}
            ls_cols[i]=ls_${ls_cols[i]#.}
        }
    }

    ls_cols=("${ls_cols[@]//[^a-zA-Z0-9=\\;]/_}")

    ls_patterns=${ls_patterns//\*}
    ls_patterns=${ls_patterns%?}

    export "${ls_cols[@]}" &>/dev/null
}

get_mime_type() {
    mime_type=$(file "-${file_flags:-biL}" "$1" 2>/dev/null)
}

status_line() {
    #PWD_escaped=${PWD//[^[:print:]]/^[}

    cyanf=$(printf '\033[1;96m')      # Red with printf
    greenpf=$(printf '\033[1;32m')    # Green with printf
    yellowpf=$(printf '\033[1;33m')   # Yellow with printf
    ncpf=$(printf '\033[0m')          # Reset with printf
    basedir="$(dirname "$PWD")"
    lastdir="$(basename "$PWD")"

    PWD_color=$(printf '%b\n' "$basedir" | awk -v red="$cyanf" -v green="$greenpf" -v yellow="$yellowpf" -v reset="$ncpf" -v lastdir="$lastdir" '
    {
        gsub("/", green "/" red);  # Colors all bars "/" in green, keeping the rest red
        print red $0 green "/" yellow lastdir reset;  # Red Way, Green Bars and Last Yellow Folder
    }')
    
    local mode_info=""
    if ((preview_mode == 1)); then
        mode_info="[Preview] "
    else
        mode_info="[Normal] "
    fi

    printf '\e7\e[%sH\e[3%s;4%sm%*s\r%s%s %s\e[m\e[%sH\e[K\e8' \
           "$((LINES-1))" \
           "${PREVIEW_COL5:-0}" \
           "${PREVIEW_COL2:-1}" \
           "$COLUMNS" "" \
           "$mode_info" \
           "($((scroll+1))/$((list_total+1)))" \
           "${PWD_color}" \
           "$LINES"
}

read_dir() {
    local dirs
    local files
    local item_index

    printf '\e]2;preview: %s\e'\\ "$PWD"

    [[ $PWD == / ]] && PWD=

    for item in "$PWD"/*; do
        if [[ -d $item ]]; then
            dirs+=("$item")
            ((item_index++))

            [[ $item == "$OLDPWD" ]] &&
                ((previous_index=item_index))
        else
            files+=("$item")
        fi
    done

    list=("${dirs[@]}" "${files[@]}")

    [[ -z ${list[0]} ]] &&
        list[0]=empty

    ((list_total=${#list[@]}-1))

    cur_list=("${list[@]}")
}

get_background_from_foreground() {
    local foreground_code="$1"
    local bg_color_code=49  # Default background (no color)
    
    # Extract color codes
    local IFS=';'
    read -ra color_parts <<< "$foreground_code"
    
    for part in "${color_parts[@]}"; do
        # Convert normal foreground (30-37) to background (40-47)
        if ((part >= 30 && part <= 37)); then
            bg_color_code=$((part + 10))
        # Convert bright foreground (90-97) to background (100-107)
        elif ((part >= 90 && part <= 97)); then
            bg_color_code=$((part + 10))
        fi
    done
    
    # Return the background color code
    echo "$bg_color_code"
}

print_line() {
    local file_name=${list[$1]##*/}
    local file_ext=${file_name##*.}
    local format
    local suffix

    if [[ -z ${list[$1]} ]]; then
        return

    elif [[ -d ${list[$1]} ]]; then
        format+=\\e[${di:-1;3${PREVIEW_COL1:-2}}m
        suffix+=/

    elif [[ -b ${list[$1]} ]]; then
        format+=\\e[${bd:-40;33;01}m

    elif [[ -c ${list[$1]} ]]; then
        format+=\\e[${cd:-40;33;01}m

    elif [[ -x ${list[$1]} ]]; then
        format+=\\e[${ex:-01;32}m

    elif [[ -h ${list[$1]} && ! -e ${list[$1]} ]]; then
        format+=\\e[${mi:-01;31;7}m

    elif [[ -h ${list[$1]} ]]; then
        format+=\\e[${ln:-01;36}m

    elif [[ -p ${list[$1]} ]]; then
        format+=\\e[${pi:-40;33}m

    elif [[ -S ${list[$1]} ]]; then
        format+=\\e[${so:-01;35}m

    elif [[ $PREVIEW_LS_COLORS == 1 &&
            $ls_patterns &&
            $file_name =~ ($ls_patterns)$ ]]; then
        match=${BASH_REMATCH[0]}
        file_ext=ls_${match//[^a-zA-Z0-9=\\;]/_}
        format+=\\e[${!file_ext:-${fi:-37}}m

    elif [[ $PREVIEW_LS_COLORS == 1 &&
            $file_ext != "$file_name" &&
            $file_ext =~ ^[a-zA-Z0-9_]*$ ]]; then
        file_ext=ls_${file_ext}
        format+=\\e[${!file_ext:-${fi:-37}}m

    else
        format+=\\e[${fi:-37}m
    fi

    # Only highlights the selected line in normal mode
    # if ((preview_mode == 0 && $1 == scroll)) || ((preview_mode == 1 && $1 == displayed_selection)); then
    #     format+="\\e[1;3${PREVIEW_COL4:-6};7m"
    # fi

    # Only highlights the selected line in normal mode
    if ((preview_mode == 0 && $1 == scroll)) || ((preview_mode == 1 && $1 == displayed_selection)); then
        # Extract the anxe codes from string format (removing the escapes)
        local current_format="${format//\\e/\e}"
        # Extract the color codes after the first [
        local color_codes="${current_format#*[}"
        color_codes="${color_codes%m*}"
        
        # Obtain the corresponding background code
        local bg_code=$(get_background_from_foreground "$color_codes")
        
        # Add the background code with white and bold text
        format+="\\e[1;${bg_code};93m"
    fi

    file_name=${file_name//[^[:print:]]/^[}

    printf '\r%b%s\e[m\r' \
        "${file_pre}${format}" \
        "${file_name}${suffix}${file_post}"
}

draw_dir() {
    local scroll_start=$scroll
    local scroll_new_pos
    local scroll_end

    ((find_previous == 1)) && {
        ((scroll_start=previous_index-1))
        ((scroll=scroll_start))

        find_previous=
    }

    if ((list_total < max_items || scroll < max_items/2)); then
        ((scroll_start=0))
        ((scroll_end=max_items))
        ((scroll_new_pos=scroll+1))

    elif ((list_total - scroll < max_items/2)); then
        ((scroll_start=list_total-max_items+1))
        ((scroll_new_pos=max_items-(list_total-scroll)))
        ((scroll_end=list_total+1))

    else
        ((scroll_start=scroll-max_items/2))
        ((scroll_end=scroll_start+max_items))
        ((scroll_new_pos=max_items/2+1))
    fi

    printf '\e[H'

    if ((preview_mode == 1)); then
        # In Preview mode, we need to track which file is visually selected
        displayed_selection=scroll
    fi
    
    for ((i=scroll_start;i<scroll_end;i++)); {
        ((i > scroll_start)) &&
            printf '\n'
        print_line "$i"
    }

    if ((preview_mode == 0)); then
        # In normal mode, we move the cursor to the position of the selected file
        printf '\e[%sH' "$scroll_new_pos"
        ((y=scroll_new_pos))
    else 
        # In Preview mode, we do not move the cursor to the selected line
        printf '\e[H'
        ((y=1))
        
        draw_delimiter
        draw_file_preview
    fi
}

draw_delimiter() {
    printf '\e[%sH' "$((max_items+1))"
    printf '\e[33m%*s\e[m\n' "$COLUMNS" "" | tr ' ' '='
}

cmd_check() {
    [[ "${#no_cmd[*]}" -gt 1 ]] && msg=$(echo "${no_cmd[*]}" | awk 'BEGIN {first=1} {for (i=1; i<=NF; i++) \
    {if (first) {printf "%s", $i; first=0} else {printf " or %s", $i}}} END {print ""}') || msg="${no_cmd[*]}"
    [[ "$1" == "-msg" ]] && printf "(It was not possible to display the file)\nInstall %s\n" "$msg" && no_cmd=() && return 0
    ! command -v "$1" 1>/dev/null && no_cmd+=(\""$2"\") && return 1 || return 0
}

office_convert() {
    local file="$1"
    local temp_dir="${TMP_DIR}/temp_book"
    local temp_file="${TMP_DIR}/temp_file.txt"
    [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
    [[ -d "${temp_dir}" ]] && rm -rf "${temp_dir}"

    [[ "${file_ext}" =~ ^([Rr][Tt][Ff])$ ]] && cmd_check catdoc catdoc && (catdoc -- "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^([Dd][Oo][Cc])$ ]] && cmd_check antiword antiword && (antiword "$file" | head -n "${sizeline}") && return 0
    [[ "${file_ext}" =~ ^(odt|ods|odp|sxw)$ ]] && cmd_check odt2txt odt2txt && (odt2txt "$file" | head -n "${sizeline}") && return 0
    cmd_check pandoc pandoc && (pandoc -s -t plain -- "$file" | head -n "${sizeline}") && return 0
    cmd_check libreoffice libreoffice && libreoffice --headless --convert-to txt --outdir "${temp_dir}" "$file" >/dev/null 2>&1 \
    && head -n "${sizeline}" "${temp_dir}"/*.txt && return 0 
    cmd_check -msg && return 1
}

markdown_reader() {
    ~/.shell_utils/scripts/markdown_reader.sh "$@" | head -n "${sizeline}"
}

archive() {
    local file="$1"
    [[ "${file_ext}" =~ ^iso ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^7z ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^rar ]] && cmd_check unrar unrar &&
    unrar lt -p- -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^rar ]] && cmd_check 7z 7zip &&
    7z l -p -- "${file}" | head -n "${sizeline}" && return 0
    [[ "${file_ext}" =~ ^(zst|zstd)$ ]] && cmd_check zstdcat zstd &&
    zstd -lv "${file}" | head -n "${sizeline}" && return 0
    cmd_check atool atool && atool --list -- "${file}" | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    cmd_check bsdtar libarchive && bsdtar --list --file "${file}" | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    head -n "${sizeline}" <(strings -n 10 "$selected_file") 2>/dev/null && return 0
    cmd_check -msg && return 1
}

imgview() {
    local file="$1"
    cmd_check img2sixel libsixel && img2sixel -w 640 -h 480 "${file}" && return 0
    cmd_check viu viu -w 100 -h 40 && viu "${file}" && return 0
    cmd_check catimg catimg && catimg -w 80 "${file}" && return 0 
    cmd_check chafa chafa && chafa -s 40 "${file}" && return 0
    cmd_check exiftool perl-image-exiftool && exiftool "${file}" | \
    head -n "${sizeline}" && return 0
    cmd_check -msg && return 1
}

pdfview() {
    local file="$1"
    local width="$2"

    cmd_check pdftotext poppler && pdftotext -l 10 -nopgbrk -q -- "${file}" - | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0
    cmd_check mutool mupdf && mutool draw -F txt -i -- "${file}" 1-10 | \
    fmt -w "${width}" | head -n "${sizeline}" && return 0 
    cmd_check exiftool perl-image-exiftool && exiftool "${file}" | \
    head -n "${sizeline}" && return 0
    local temp_file="${TMP_DIR}/temp_file.png"
    [[ -f "${temp_file}" ]] && rm -f "${temp_file}"
    cmd_check magick imagemagick && magick -- "${file}" -auto-orient "${temp_file}"
    [[ -f "${temp_file}" ]] && imgview "${temp_file}" 2>/dev/null || cmd_check -msg && return 1
}

draw_file_preview() {
    local selected_file="${list[scroll]}"
    local sizeline=15
    local width=70
    
    # Cleans the preview area
    for ((i=max_items+2; i<LINES-1; i++)); do
        printf '\e[%sH\e[K' "$i"
    done
    
    printf '\e[%sH' "$((max_items+2))"
    
    if [[ -f "$selected_file" ]]; then
        local file_ext="${selected_file##*.}"
        file_ext="${file_ext,,}" # lowercase
        
        # Displays the current file name in the preview area
        printf '\e[36mFile: %s\e[m\n\n' "${selected_file##*/}"
        
        case "$file_ext" in
            a|ace|alz|arc|arj|bz|bz2|cab|cpio|deb|gz|jar|lha|lz|lzh|lzma|lzo|rar|7z|\
            rpm|rz|t7z|tar|tbz|tbz2|tgz|tlz|txz|tZ|tzo|war|xpi|xz|Z|zip|zst|zstd|iso)
                [[ "$file_ext" == "tar" ]] && head -n "${sizeline}" <(strings -n 10 "$selected_file") 2>/dev/null | sed '/^[0-9]\{11\}/d'
                archive "$selected_file" 
                ;;
            md)
                markdown_reader "$selected_file"
                ;;
            pdf)
                if ! pdfview "$selected_file" "$width"; then
                    printf '\n\e[33mPDF file: %s\e[m\n' "${selected_file##*/}"
                fi
                ;;
            png|jpg|jpeg|avif)
                if ! imgview "$selected_file"; then
                    printf '\n\e[33mImage file: %s\e[m\n' "${selected_file##*/}"
                fi
                ;;
            rtf|odt|ods|odp|sxw|doc|docx)
                if ! office_convert "$selected_file"; then
                    printf '\n\e[33mOffice file: %s\e[m\n' "${selected_file##*/}"
                fi
                ;;
            *)
                get_mime_type "$selected_file"
                if [[ "$mime_type" == *"text"* || "$mime_type" == *"empty"* ]]; then
                    head -n "${sizeline}" "$selected_file" 2>/dev/null
                else
                    head -n "${sizeline}" <(strings -n 10 "$selected_file") 2>/dev/null | sed '/^[0-9]\{11\}/d'
                fi
                ;;
        esac

    elif [[ -d "$selected_file" ]]; then
        printf '\e[36mDirectory: %s\e[m\n' "${selected_file##*/}"
        printf '\e[36mTotal Files: %s\e[m\n\n' "$(ls -1A "$selected_file" | wc -l)"
        ls -lha --group-directories-first --color=always "$selected_file" | head -n 2
        printf '%s\n' "----------------------------------------------------"
        # Count the number of items returned by LS
        item_count=$(ls -pa --group-directories-first "$selected_file" | wc -l)
        # Check that the number of items is greater than 30
        if [ "$item_count" -le 30 ]; then
            # If it is less than 30, displays all items with intact colors
            ls -pa --group-directories-first --color=always "$selected_file"
        else
            # If it is more than 30, it limits the display for the first 30 items
            ls -pa --group-directories-first --color=always "$selected_file" | head -n "${sizeline}"
        fi
    else
        printf '\e[33mNo selected files\e[m\n'
    fi
}

redraw() {
    [[ $1 == full ]] && {
        read_dir
        scroll=0
    }

    clear_screen
    draw_dir
    status_line
}

toggle_preview_mode() {
    preview_mode=$((preview_mode == 0 ? 1 : 0))
    get_term_size
    redraw
}

open() {
    if [[ -d $1/ ]]; then
        search=
        search_end_early=
        cd "${1:-/}" ||:
        redraw full

    elif [[ -f $1 ]]; then
        get_mime_type "$1"

        case "$mime_type" in
            text/*|*x-empty*|*json*)
                ((file_picker == 1)) && {
                    printf '%s\n' "$1" > \
                        "${XDG_CACHE_HOME:=${HOME}/.cache}/preview/opened_file"
                    exit
                }

                clear_screen
                reset_terminal
                "${VISUAL:-${EDITOR:-vi}}" "$1"
                setup_terminal
                redraw
            ;;

            *)
                nohup "${PREVIEW_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                disown
            ;;
        esac
    fi
}

cmd_line() {
    cmd_reply=
    printf '\e7\e[%sH\e[?25h' "$LINES"

    while IFS= read -rsn 1 -p $'\r\e[K'"${1}${cmd_reply}" read_reply; do
        case $read_reply in
            $'\177'|$'\b')
                cmd_reply=${cmd_reply%?}
                unset comp c
            ;;
            $'\t')
                comp_glob="$cmd_reply*"

                [[ $2 == dirs ]] &&
                    comp_glob="$cmd_reply*/"

                [[ -z ${comp[0]} ]] &&
                    IFS=$'\n' read -d "" -ra comp < <(compgen -G "$comp_glob")

                [[ -n ${comp[c]} ]] && {
                    cmd_reply=${comp[c]}
                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
                }
            ;;
            $'\e'|${3:-null})
                read "${read_flags[@]}" -rsn 2
                cmd_reply=
                break
            ;;
            "")
                [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {
                    printf '\e[?25l'

                    open "${list[0]}"
                    search_end_early=1
                    unset comp c
                    return
                }

                break
            ;;
            ${2:-null})
                cmd_reply=$read_reply
                break
            ;;
            "~")
                cmd_reply+=$HOME
            ;;
            *)
                cmd_reply+=$read_reply
                unset comp c
            ;;
        esac

        [[ $2 == search ]] && {
            printf '\e[?25l'

            list=("$PWD"/*"$cmd_reply"*)
            ((list_total=${#list[@]}-1))

            scroll=0
            redraw
            printf '\e[%sH\e[?25h' "$LINES"
        }
    done
    unset comp c
    printf '\e[2K\e[?25l\e8'
}

keys() {
    local os=$(uname -o)
    [[ "$os" =~ "Android" ]] && LOOP_SCROLL=0
    [[ $1 == $'\e' ]] && {
        read "${read_flags[@]}" -rsn 2

        [[ ${1}${REPLY} == $'\e\e['* ]] &&
            read "${read_flags[@]}" -rsn 1 _

        local special_key=${1}${REPLY}
    }

    case ${special_key:-$1} in
        ${PREVIEW_KEY_DELETE1:=D}|\
        ${PREVIEW_KEY_DELETE2:=$'\x7e'}) # Delete
            [[ ! -e ${list[scroll]} ]] &&
                return
                
            cmd_line "delete ${list[scroll]##*/}? (y/N): "
            
            [[ $cmd_reply =~ ^[Yy]$ ]] &&
                if [[ -w ${list[scroll]} ]]; then
                    if [[ -d ${list[scroll]} ]]; then
                        rm -rf "${list[scroll]}"
                    else
                        rm -f "${list[scroll]}"
                    fi
                    redraw full
                else
                    cmd_line "warn: no write access to file/directory."
                fi
        ;;
        ${PREVIEW_KEY_PREVIEW1:=P}|\
        ${PREVIEW_KEY_PREVIEW2:=$'\x10'}) # Ctrl+P
            toggle_preview_mode
        ;;
        ${PREVIEW_KEY_CHILD1:=l}|\
        ${PREVIEW_KEY_CHILD2:=$'\e[C'}|\
        ${PREVIEW_KEY_CHILD3:=""}|\
        ${PREVIEW_KEY_CHILD4:=$'\eOC'})
            open "${list[scroll]}"
        ;;
        ${PREVIEW_KEY_PARENT1:=h}|\
        ${PREVIEW_KEY_PARENT2:=$'\e[D'}|\
        ${PREVIEW_KEY_PARENT3:=$'\177'}|\
        ${PREVIEW_KEY_PARENT4:=$'\b'}|\
        ${PREVIEW_KEY_PARENT5:=$'\eOD'})
            if ((search == 1 && search_end_early != 1)); then
                open "$PWD"

            elif [[ $PWD && $PWD != / ]]; then
                find_previous=1
                open "${PWD%/*}"
            fi
        ;;
        ${PREVIEW_KEY_SCROLL_DOWN1:=j}|\
        ${PREVIEW_KEY_SCROLL_DOWN2:=$'\e[B'}|\
        ${PREVIEW_KEY_SCROLL_DOWN3:=$'\eOB'}|\
        ${PREVIEW_KEY_SCROLL_DOWN4:=$'\x42'})
            if [[ "$LOOP_SCROLL" == 0 ]]; then
                ((scroll < list_total)) && {
                    ((scroll++))
                    
                    if ((preview_mode == 0)); then
                        ((y < max_items)) && ((y++))
                        print_line "$((scroll-1))"
                        printf '\n'
                        print_line "$scroll"
                    else
                        # No modo preview, apenas atualizamos a área de preview
                        draw_file_preview
                        # Redraw para atualizar o status line
                        redraw
                        return
                    fi
                    
                    status_line
                }
            else
                if ((scroll < list_total)); then
                    ((scroll++))
                else
                    # Se estiver no último item, volta para o primeiro
                    ((scroll=0))
                    redraw
                    return
                fi
                
                if ((preview_mode == 0)); then
                    ((y < max_items)) && ((y++))
                    print_line "$((scroll-1))"
                    printf '\n'
                    print_line "$scroll"
                else
                    # No modo preview, apenas atualizamos a área de preview
                    draw_file_preview
                    # Redraw para atualizar o status line
                    redraw
                    return
                fi

                status_line
            fi
        ;;
        ${PREVIEW_KEY_SCROLL_UP1:=k}|\
        ${PREVIEW_KEY_SCROLL_UP2:=$'\e[A'}|\
        ${PREVIEW_KEY_SCROLL_UP3:=$'\eOA'}|\
        ${PREVIEW_KEY_SCROLL_UP4:=$'\x41'})
            if [[ "$LOOP_SCROLL" == 0 ]]; then
                ((scroll > 0)) && {
                    ((scroll--))

                    if ((preview_mode == 0)); then
                        print_line "$((scroll+1))"

                        if ((y < 2)); then
                            printf '\e[L'
                        else
                            printf '\e[A'
                            ((y--))
                        fi

                        print_line "$scroll"
                    else
                        # No modo preview, apenas atualizamos a área de preview
                        draw_file_preview
                        # Redraw para atualizar o status line
                        redraw
                        return
                    fi

                    status_line
                }
            else
                if ((scroll > 0)); then
                    ((scroll--))
                else
                    # Se estiver no primeiro item, vai para o último
                    ((scroll=list_total))
                    redraw
                    return
                fi

                if ((preview_mode == 0)); then
                    print_line "$((scroll+1))"

                    if ((y < 2)); then
                        printf '\e[L'
                    else
                        printf '\e[A'
                        ((y--))
                    fi

                    print_line "$scroll"
                else
                    # No modo preview, apenas atualizamos a área de preview
                    draw_file_preview
                    # Redraw para atualizar o status line
                    redraw
                    return
                fi

                status_line
            fi
        ;;
        ${PREVIEW_KEY_TO_TOP:=g})
            ((scroll != 0)) && {
                scroll=0
                redraw
            }
        ;;
        ${PREVIEW_KEY_TO_BOTTOM:=G})
            ((scroll != list_total)) && {
                ((scroll=list_total))
                redraw
            }
        ;;
        ${PREVIEW_KEY_HIDDEN:=.})
            shopt_flags=(u s)
            shopt -"${shopt_flags[((a=${a:=$PREVIEW_HIDDEN}>0?0:++a))]}" dotglob
            redraw full
        ;;
        ${PREVIEW_KEY_SEARCH:=/})
            cmd_line "/" "search"
            if [[ -z ${list[*]} ]]; then
                list=("${cur_list[@]}")
                ((list_total=${#list[@]}-1))
                redraw
                search=
            else
                search=1
            fi
        ;;
        ${PREVIEW_KEY_SHELL:=!})
            reset_terminal
            export PREVIEW_LEVEL
            ((PREVIEW_LEVEL++))

            cd "$PWD" && "$SHELL"
            setup_terminal
            redraw full
        ;;
        ${PREVIEW_KEY_RENAME:=r})
            [[ ! -e ${list[scroll]} ]] &&
                return

            cmd_line "rename ${list[scroll]##*/}: "

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w ${list[scroll]} ]]; then
                    mv "${list[scroll]}" "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to file."
                fi
        ;;
        ${PREVIEW_KEY_MKDIR:=n})
            cmd_line "mkdir: " "dirs"

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w $PWD ]]; then
                    mkdir -p "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;
        ${PREVIEW_KEY_MKFILE:=f})
            cmd_line "mkfile: "

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w $PWD ]]; then
                    : > "$cmd_reply"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;
        ${PREVIEW_KEY_GO_DIR:=:})
            cmd_line "go to dir: " "dirs"

            cd "$PWD" &>/dev/null ||:

            [[ $cmd_reply ]] &&
                cd "${cmd_reply/\~/$HOME}" &>/dev/null &&
                    open "$PWD"
        ;;
        ${PREVIEW_KEY_GO_HOME:='~'})
            open ~
        ;;
        ${PREVIEW_KEY_PREVIOUS:=-})
            open "$OLDPWD"
        ;;
        ${PREVIEW_KEY_REFRESH:=e})
            open "$PWD"
        ;;
        ${PREVIEW_KEY_QUIT1:=$'\x04'}|\
        ${PREVIEW_KEY_QUIT2:='='}|\
        ${PREVIEW_KEY_QUIT3:=q})
            : "${PREVIEW_CD_FILE:=${XDG_CACHE_HOME:=${HOME}/.cache}/preview/.preview_d}"

            [[ -w $PREVIEW_CD_FILE ]] &&
                rm "$PREVIEW_CD_FILE"

            [[ ${PREVIEW_CD_ON_EXIT:=1} == 1 ]] &&
                printf '%s\n' "$PWD" > "$PREVIEW_CD_FILE"

            clear
            exit 0
        ;;
    esac
}

main() {
    cd "${2:-$1}" &>/dev/null ||:

    [[ $1 == -v ]] && {
        printf '%s\n' "preview 2.2"
        exit
    }

    [[ $1 == -h ]] && {
        man preview
        exit
    }

    [[ $1 == -p ]] &&
        file_picker=1

    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.05)

    ((${PREVIEW_LS_COLORS:=1} == 1)) &&
        get_ls_colors

    ((${PREVIEW_HIDDEN:=0} == 1)) &&
        shopt -s dotglob

    mkdir -p "${XDG_CACHE_HOME:=${HOME}/.cache}/preview"

    shopt -s nocaseglob nullglob

    trap 'reset_terminal' EXIT

    trap 'get_term_size; redraw' WINCH
    
    # Preview mode boot (now as standard)
    preview_mode=1
    displayed_selection=0

    get_os
    get_term_size
    setup_options
    setup_terminal
    redraw full

    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && keys "$REPLY"

        [[ -t 1 ]] || exit 1
    }
}

main "$@"