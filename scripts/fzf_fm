#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes
trap "" SIGTSTP  # No Ctrl+Z.

: <<'DOCUMENTATION'
Preview pane for files (text, images, PDFs) with adjustable width (20-150 via Ctrl-h/l)
Directory browsing with exa/ls fallback, hidden file toggle, and recursive search
Keybind-driven operations (open/edit files, toggle views, mark selections)
MIME-type handling (text editors, image viewers, media players)
Persistent settings in ~/.cache including preview margins and UI preferences
ANSI colors/icons support with bat/highlight for syntax highlighting
Debug logging and temporary file cleanup system for stability
Uses fzf for fuzzy finding and is based on ranger and lesspipe for file previews
DOCUMENTATION

clear

# Check and change to directory if provided
if test -n "$1" && test -d "$1"; then
    initial_dir=$(realpath "$1")
else
    initial_dir="$PWD"
fi

# Settings
VERSION=1.0
SCRIPT="${0##*/}"
TMPDIR="${TMPDIR:-/tmp}"
TMP_FZF_DIR="${TMPDIR}/${SCRIPT%.*}"
CACHE_FZF_DIR="${XDG_CACHE_HOME:=${HOME}/.cache}/${SCRIPT%.*}"
CONFIG_FZF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/${SCRIPT%.*}"
MARGIN_PREVIEW="${CACHE_FZF_DIR}/margin_preview"
[[ ! -d "$TMP_FZF_DIR" ]] && mkdir -p "$TMP_FZF_DIR"
[[ ! -d "$CACHE_FZF_DIR" ]] && mkdir -p "$CACHE_FZF_DIR"
[[ ! -d "$CONFIG_FZF_DIR" ]] && mkdir -p "$CONFIG_FZF_DIR"
[[ -n "$TERMUX_VERSION" ]] && [[ ! -f "$MARGIN_PREVIEW" ]] && echo 30 | tee "$MARGIN_PREVIEW" >/dev/null
[[ -z "$TERMUX_VERSION" ]] && [[ ! -f "$MARGIN_PREVIEW" ]] && echo 150 | tee "$MARGIN_PREVIEW" >/dev/null
exec 2>"${TMPDIR}/${SCRIPT%.*}-debug.log"
MARK_LOG="${TMP_FZF_DIR}/mark.log"
touch "$MARK_LOG"  
MARKED_FILES_FILE="${TMP_FZF_DIR}/marked_files"
touch "$MARKED_FILES_FILE"
# Main configuration
SCRIPT_PATH="$(realpath "$0")"
preview_cmd="bash \"$SCRIPT_PATH\" --preview-file {}"
read -ra redraw <<< "$preview_cmd"
generate_mark_file() {
	marked_files=()
	[[ -f "$MARKED_FILES_FILE" ]] && rm -f "$MARKED_FILES_FILE"
	[[ ! -f "$MARKED_FILES_FILE" ]] && touch "$MARKED_FILES_FILE"
}
# Prepare the Archive Array
declare -a marked_files=()
# Loads the files marked in both array and the file
if [[ -f "$MARKED_FILES_FILE" ]]; then
    readarray -t marked_files < "$MARKED_FILES_FILE"
else
    touch "$MARKED_FILES_FILE"
fi
{ [[ -n "$XTERM_VERSION" ]] && message_width=$(($(tput cols) - 1)); } || message_width=$(($(tput cols) / 3))		# 1/3 of the terminal width
{ [[ -n "$XTERM_VERSION" ]] && message_height=$(($(tput lines) - 1)); } || message_height=$(($(tput lines) / 4))	# 1/4 of the terminal height

cleanup() { [[ -d "$TMP_FZF_DIR" ]] && rm -rf "$TMP_FZF_DIR" 2>/dev/null; }

help() {
    cat << EOF
FZF FILE MANAGER HELP - KEY BINDINGS

Navigation:
  ↑/↓ or Tab/Shift-Tab  - Move selection up/down
  Enter                 - Open selected file/directory
  Right                 - Open selected file/directory
  Left                  - Go up one level
  Ctrl-q/Ctrl-c/Esc     - Exit file manager
  F1 or ?               - Show this help menu

View Modes:
  Ctrl-p                - Toggle preview panel
  Ctrl-h                - Increase preview margin (+5)
  Ctrl-l                - Decrease preview margin (-5)
  Ctrl-r/F5             - Refresh current view
  Alt-h                 - Toggle hidden files visibility
  Alt-c                 - Toggle cyclic scrolling

Search Modes:
  Ctrl-f                - Toggle recursive search
  Type text             - Search/filter items

File Operations:
  Ctrl-d                - Mark selected file (logs to temporary file)
  Ctrl-e                - Delete selected or marked files
  Alt-a                 - Mark/unmark selected file
  Right/Enter           - Open file with appropriate handler

Preview Features:
  - Text files:         Syntax highlighting (bat/highlight/fallback to head)
  - Images:             Thumbnail preview (magick/viu/chafa/fallback to file info)
  - PDFs:               Text extraction (pdftotext/fallback to file info)
  - Directories:        List contents (exa/ls)
  - Other files:        File type information and strings extraction
  - Adjustable margin:  Dynamic resizing (20-150) with Ctrl-h/Ctrl-l

Configuration:
  - Preview margin:     Persisted in $MARGIN_PREVIEW
  - UI Preferences:     Stored in $CACHE_FZF_DIR (recursive, hidden files, cycle)
  - Debug logs:         Written to ${TMPDIR}/${SCRIPT%.*}-debug.log
  - Marked files:       Persisted in $MARKED_FILES_FILE

New Features:
  - Help system:        Accessible via F1/? key with whiptail dialog option
  - File deletion:      Single or multiple marked files with confirmation
  - Marking system:     Toggle mark/unmark files with visual feedback ([<])
  - MIME-type handling:  Enhanced support for json, csv, xml, scripts, audio, video
  - Directory view:     Improved with exa/ls fallback and icons
  - Recursive search:   Toggleable with fd/find for deep directory exploration
  - Path display:       Color-coded current directory with ANSI support
  - Stability:          Robust error handling, temp file cleanup, debug logging

Note: 
- All temporary files are stored in $TMP_FZF_DIR
- Press any key to close this help
- Version $VERSION
EOF
}

dialog_help() {
    # Create a temporary file with Help content
    local helpfile="${TMP_FZF_DIR}/help.txt"
    help > "$helpfile"
    
    # Show using Whiptail with Scroll
    whiptail --title "File Manager Help" --scrolltext --textbox "$helpfile" "$message_height" "$message_width"
    
    # Remove temporary file
    rm -f "$helpfile"
}

setup_config() {
    local config_file="$CONFIG_FZF_DIR/fzf_fm.conf"
    
    # If config file already exists, source it
    if [[ -f "$config_file" ]]; then
        source "$config_file"
        return 0
    fi
    
    # Create the configuration file with default values and explanations
    cat > "$config_file" << 'EOF'
# Preview configuration file

# Default preview mode
# Default: 1 (preview mode)
# 0 for normal mode, 1 for preview mode
#PREVIEW_MODE=""

# Maximum items to show in preview mode
# Default: 9
# Number of items displayed in the file list when in preview mode
#PREVIEW_MAX_ITEMS=""

# Enable/disable hidden files view by default
# Default: 0 (disabled)
# Set to 1 to show hidden files when preview starts
#PREVIEW_HIDDEN=""

# Enable/disable using LS_COLORS for file coloring
# Default: 1 (enabled)
# Set to 1 to use colors defined in LS_COLORS environment variable
#PREVIEW_LS_COLORS=""

# File format string for displaying files
# Default: "%f"
# %f is replaced with the filename
#PREVIEW_FILE_FORMAT=""

# Default program to open files with
# Default: "xdg-open"
# Specify the command to open files
#PREVIEW_OPENER=""

# Change directory on exit
# Default: 1 (enabled)
# Set to 1 to change to the last directory viewed when the preview application exits
#PREVIEW_CD_ON_EXIT=""

# Path to file that stores the last directory
# Default: "${XDG_CACHE_HOME:-$HOME/.cache}/preview/.preview_d"
# Specify where to store the last visited directory
#PREVIEW_CD_FILE=""

# Color for directories
# Default: "2" (blue)
# ANSI color code for directory display
#PREVIEW_COL_DIRECTORY=""

# Color for status line background
# Default: "48;5;128" (purple)
# ANSI color code for status line background
#PREVIEW_STATUS_BACKGROUND=""

# Color for selected item highlight
# Default: "6" (cyan)
# ANSI color code for highlighting selected items
#PREVIEW_SELECTED_HIGHLIGHT=""

# Color for status line text
# Default: "1;38;5;16" (black)
# ANSI color code for status line text
#PREVIEW_STATUS_FOREGROUND=""

# Color for PWD PREVIOUS DIRECTORY in status line text
# Default: "1;38;5;16" (black)
# ANSI color code for status line text
#PWD_PREVIOUS_DIRECTORY=""

# Color for PWD LAST DIR in status line text
# Default: "1;33" (yellow)
# ANSI color code for status line text
#PWD_LAST_DIR=""

# Color for PWD BAR in status line text
# Default: "1;96" (cyan)
# ANSI color code for status line text
#PWD_BAR=""

# Key bindings for navigation and actions

# Enter a directory or open a file (primary key binding)
# Default: "l"
# Key to enter directories or open files
#PREVIEW_KEY_CHILD1=""

# Navigate into directory or open file (second binding)
# Default: "\e[C" (right arrow)
# Alternative key to enter directories or open files
#PREVIEW_KEY_CHILD2=""

# Navigate into directory or open file (third binding)
# Default: "\eOC" (right arrow in some terminals)
# Alternative key to enter directories or open files
#PREVIEW_KEY_CHILD3=""

# Navigate into directory or open file (fourth binding)
# Default: "" (none)
# Additional key to enter directories or open files
#PREVIEW_KEY_CHILD4=""

# Navigate to parent directory (first binding)
# Default: "h"
# Key to go to parent directory
#PREVIEW_KEY_PARENT1=""

# Navigate to parent directory (second binding)
# Default: "\e[D" (left arrow)
# Alternative key to go to parent directory
#PREVIEW_KEY_PARENT2=""

# Navigate to parent directory (third binding)
# Default: "\177" (backspace)
# Alternative key to go to parent directory
#PREVIEW_KEY_PARENT3=""

# Navigate to parent directory (fourth binding)
# Default: "\b" (backspace)
# Alternative key to go to parent directory
#PREVIEW_KEY_PARENT4=""

# Navigate to parent directory (fifth binding)
# Default: "\eOD" (left arrow in some terminals)
# Additional key to go to parent directory
#PREVIEW_KEY_PARENT5=""

# Scroll down (primary key binding)
# Default: "j"
# Key to scroll down file list
#PREVIEW_KEY_SCROLL_DOWN1=""

# Scroll down (second binding)
# Default: "\e[B" (down arrow)
# Alternative key to scroll down the file list
#PREVIEW_KEY_SCROLL_DOWN2=""

# Scroll down (third binding)
# Default: "\eOB" (down arrow in some terminals)
# Additional key to scroll down the file list
#PREVIEW_KEY_SCROLL_DOWN3=""

# Scroll up (first binding)
# Default: "k"
# Key to scroll up the file list
#PREVIEW_KEY_SCROLL_UP1=""

# Scroll up (second binding)
# Default: "\e[A" (up arrow)
# Alternative key to scroll up the file list
#PREVIEW_KEY_SCROLL_UP2=""

# Scroll up (third binding)
# Default: "\eOA" (up arrow in some terminals)
# Additional key to scroll up the file list
#PREVIEW_KEY_SCROLL_UP3=""

# Go to top of file list
# Default: "g"
# Key to jump to the top of the file list
#PREVIEW_KEY_TO_TOP=""

# Go to bottom of file list
# Default: "G"
# Key to jump to the bottom of the file list
#PREVIEW_KEY_TO_BOTTOM=""

# Toggle visibility of hidden files
# Default: "."
# Key to toggle visibility of hidden files
#PREVIEW_KEY_HIDDEN=""

# Search for files
# Default: "/"
# Key to start file search
#PREVIEW_KEY_SEARCH=""

# Exit search mode (primary key binding)
# Default: "'"
# Key to exit search mode while preserving the current selection
#PREVIEW_KEY_EXIT_CLEAR_SEARCH1=""

# Exit search mode (second binding)
# Default: "\""
# Alternative key to exit search mode while keeping selection
#PREVIEW_KEY_EXIT_CLEAR_SEARCH2=""

# Open shell in current directory
# Default: "!"
# Key to open a shell in the current directory
#PREVIEW_KEY_SHELL=""

# Rename file
# Default: "R"
# Key to rename a file or directory
#PREVIEW_KEY_RENAME=""

# Create directory
# Default: "m"
# Key to create a new directory
#PREVIEW_KEY_MKDIR=""

# Create file
# Default: "F"
# Key to create a new file
#PREVIEW_KEY_MKFILE=""

# Go to specific directory
# Default: "\x07" (Ctrl+G)
# Key to navigate to a specific directory
#PREVIEW_KEY_GO_DIR=""

# Go to home directory (first binding)
# Default: "~"
# Key to go to the home directory
#PREVIEW_KEY_GO_HOME1=""

# Go to home directory (second binding)
# Default: "H"
# Alternative key to go to the home directory
#PREVIEW_KEY_GO_HOME2=""

# Go to previous directory
# Default: "-"
# Key to go to the previous directory
#PREVIEW_KEY_PREVIOUS=""

# Refresh current directory
# Default: "r"
# Key to refresh the file list
#PREVIEW_KEY_REFRESH=""

# Copy file
# Default: "C"
# Key to copy a file or directory
#PREVIEW_KEY_COPY=""

# Copy to clipboard
# Default: "Z"
# Key to copy a file to clipboard
#PREVIEW_KEY_CLIPBOARD=""

# Key binding to create symlinks
# Default: "S"
# Key to create symbolic links for selected files or directories
#PREVIEW_KEY_SYMLINK=""

# Toggle preview mode (first binding)
# Default: "P"
# Key to toggle between normal and preview modes
#PREVIEW_KEY_PREVIEW1=""

# Toggle preview mode (second binding)
# Default: "\x10" (Ctrl+P)
# Alternative key to toggle between normal and preview modes
#PREVIEW_KEY_PREVIEW2=""

# Quit program (first binding)
# Default: "\x04" (Ctrl+D)
# Key to exit the program
#PREVIEW_KEY_QUIT1=""

# Quit program (second binding)
# Default: "="
# Alternative key to exit the program
#PREVIEW_KEY_QUIT2=""

# Quit program (third binding)
# Default: "Q"
# Alternative key to exit the program
#PREVIEW_KEY_QUIT3=""

# Quit program (fourth binding)
# Default: "q"
# Alternative key to exit the program
#PREVIEW_KEY_QUIT4=""

# Show file attributes
# Default: "x"
# Key to display file attributes
#PREVIEW_KEY_ATTRIBUTES=""

# Toggle executable flag
# Default: "X"
# Key to toggle the executable permission of a file
#PREVIEW_KEY_EXECUTABLE=""

# Extract archive
# Default: "e"
# Key to extract an archive file to folder
#PREVIEW_KEY_EXTRACT=""

# Delete file/directory
# Default: "E"
# Key to delete a file or directory
#PREVIEW_KEY_ERASE=""

# Move file/directory
# Default: "M"
# Key to move a file or directory
#PREVIEW_KEY_MOVE=""

# Mark file/directory
# Default: "y"
# Key to mark a file or directory
#PREVIEW_KEY_MARK=""

# Key to mark all files in the current directory
# Default: "Y"
#PREVIEW_KEY_MARK_ALL=""

# Clear all marked files and directories
# Default: "c"
# Key to clear all marked files and directories
#PREVIEW_KEY_CLEAR_MARK=""

# Format for marked files
# Default: "" (none)
# %f is replaced with the filename
#PREVIEW_MARK_FORMAT=""

# Color for marked files
# Default: "1" (red)
# ANSI color code for marked file display
#PREVIEW_COL_MARKED=""

# Show image and info in terminal
# Default: "i"
# Key to display an image and info in the terminal
#PREVIEW_KEY_INFO=""

# Markdown preview settings
# Preferred markdown preview tool
# Default: "5" (markdown_reader.sh)
# 1: glow, 2: bat, 3: mdless, 4: mdcat, 5: markdown_reader.sh
#PREVIEW_MARKDOWN=""

# Key binding to open file with xdg-open
# Default: "" (none)
# Key to open files using xdg-open or specified opener
#PREVIEW_KEY_XDG_OPEN=""

# Image preview settings
# Preferred image preview tool
# Default: "1" (img2sixel)
# 1: img2sixel, 2: viu, 3: catimg, 4: chafa
#PREVIEW_IMG=""

# Width of full-size img2sixel preview
# Default: "540"
# Width in pixels for full-size image preview with img2sixel
#PREVIEW_SIXEL_W=""

# Height for img2sixel full-size preview
# Default: "420"
# Height in pixels for full-size image preview with img2sixel
#PREVIEW_SIXEL_H=""

# Width for viu full-size preview
# Default: "90"
# Width in characters for full-size image preview with viu
#PREVIEW_VIU_W=""

# Height for viu full-size preview
# Default: "35"
# Height in characters for full-size image preview with viu
#PREVIEW_VIU_H=""

# Width for catimg full-size preview
# Default: "100"
# Width in characters for full-size image preview with catimg
#PREVIEW_CATIMG_W=""

# Size for chafa full-size preview
# Default: "50"
# Size specification for full-size image preview with chafa
#PREVIEW_CHAFA_S=""

# Width for img2sixel thumbnail preview
# Default: "300"
# Width in pixels for thumbnail preview with img2sixel
#PREVIEW_THUMB_SIXEL_W=""

# Height for img2sixel thumbnail preview
# Default: "200"
# Height in pixels for thumbnail preview with img2sixel
#PREVIEW_THUMB_SIXEL_H=""

# Width for viu thumbnail preview
# Default: "50"
# Width in characters for thumbnail preview with viu
#PREVIEW_THUMB_VIU_W=""

# Height for viu thumbnail preview
# Default: "16"
# Height in characters for thumbnail preview with viu
#PREVIEW_THUMB_VIU_H=""

# Width for catimg thumbnail preview
# Default: "60"
# Width in characters for thumbnail preview with catimg
#PREVIEW_THUMB_CATIMG_W=""

# Size for chafa thumbnail preview
# Default: "25"
# Size specification for thumbnail preview with chafa
#PREVIEW_THUMB_CHAFA_S=""

# Scroll behavior
# Default: "1" (loop)
# 0: no loop (stops at ends), 1: loop (wraps around)
#PREVIEW_LOOP_SCROLL=""

# Favorite directory for key 0-9
# Example: PREVIEW_FAV_0=~/Documents PREVIEW_FAV_1=~/Pictures
# Default: "" (none)
# Path to a favorite directory accessed with key 0-9
#PREVIEW_FAV_0=""
#PREVIEW_FAV_1=""
#PREVIEW_FAV_2=""
#PREVIEW_FAV_3=""
#PREVIEW_FAV_4=""
#PREVIEW_FAV_5=""
#PREVIEW_FAV_6=""
#PREVIEW_FAV_7=""
#PREVIEW_FAV_8=""
#PREVIEW_FAV_9=""

# Command to show file attributes
# Default: "stat"
# Command used to display file attributes
#PREVIEW_STAT_CMD=""

# Shell nesting level
# Default: "" (starts unset, incremented when opening shells)
# Tracks the nesting level of shell instances
#PREVIEW_LEVEL=""

# Resolution for image and video previews
# Default: "854x480"
# Resolution used for resizing images and videos (format: WIDTHxHEIGHT)
#RESOLUTION=""

# Width for text folding in preview
# Default: "5"
# Maximum line width for text wrapping with fold command
#PREVIEW_MARGIN=""

# Maximum lines for file content preview
# Default: "30" (non-Android) or "20" (Android)
# Number of lines to display in file content previews
#sizeline=""

# Maximum width for text preview
# Default: "200" (non-Android) or "50" (Android)
# Width in characters for text formatting in previews
#width=""

# Tab width for code highlighting
# Default: "8"
# Number of spaces to replace tabs with when highlighting code
#HIGHLIGHT_TABWIDTH=""

# Style for code highlighting
# Default: "pablo"
# Highlight style to use with the highlight command
#HIGHLIGHT_STYLE=""

# Additional options for code highlighting
# Default: ""
# Extra options to pass to the highlight command
#HIGHLIGHT_OPTIONS=""

# Style for pygmentize code highlighting
# Default: "autumn"
# Pygmentize style to use for syntax highlighting
#PYGMENTIZE_STYLE=""
EOF

    # Make the config file user-executable
    chmod u+x "$config_file"
    
    # Source the newly created config file
    source "$config_file"
}

messages() {
	whiptail --title "$1" --msgbox "$2" "$message_height" "$message_width" >/dev/null 2>&1 >/dev/tty
}

########################## PREVIEW FILE MANAGER
cmd_check() {
    { [[ "${#no_cmd[*]}" -gt 1 ]] && msg=$(echo "${no_cmd[*]}" | awk 'BEGIN {first=1} {for (i=1; i<=NF; i++) \
    {if (first) {printf "%s", $i; first=0} else {printf " or %s", $i}}} END {print ""}'); } || msg="${no_cmd[*]}"
    [[ "$1" == "-msg" ]] && printf '\e7\e[%sH\e[K%s\e8' "$LINES" "(It was not possible to display the file). Install $msg" &&
    no_cmd=() && read -rsn 1 -p "" </dev/tty >/dev/null 2>/dev/null && return 0
    ! command -v "$1" 1>/dev/null && no_cmd+=(\""$2"\") && return 1 || return 0
}

margin() {
    local file="$1"
    { cmd_check fold coreutils &&
    fold -s -w $(($(tput cols) - ${PREVIEW_MARGIN:-5})) "$file" && return 0; } ||
    cmd_check -msg && return 1
}

any_file() {
    file="$1"
    margin <(file "$file" | sed -n 's/.*:\s*\(.*\)/\1/p') && echo &&
    margin <(strings -n 10 "$file") 2>/dev/null | sed '/^[0-9]\{11\}/d' && return 0
}

########################## FZF FILE MANAGER
# Function for cleaning paths returned by the FZF
clean_path() {
    local path="$1"
    echo "$path" | awk '{gsub(/^[[:space:]]+|[[:space:]]+$/, ""); gsub(/^'\''|'\''$/, ""); gsub(/'\''/, ""); gsub(/\\+/, ""); print}'
}

f_header_text() {
	find_status=$([ -f "$CACHE_FZF_DIR/find" ] && echo "on" || echo "off")
	cycle_status=$([ -f "$CACHE_FZF_DIR/cycle" ] && echo "on" || echo "off")
	preview_status=$([ ! -f "$CACHE_FZF_DIR/hidepreview" ] && echo "on" || echo "off")

	# Builds header_text with marked Files
	marked_files_status=""
	if [ ${#marked_files[@]} -gt 0 ]; then
		marked_files_status="Marked files:\n"
		for file in "${marked_files[@]}"; do
			if [[ -n "$file" ]]; then
				basename=$(basename "$file")
				marked_files_status+=" $(echo "$basename" | cut -c1-28) [<]\n"
			fi
		done
		# Removes the section if no valid file has been added
		if [[ "$marked_files_status" == "Marked files:\n" ]]; then
			marked_files_status="No files marked"
		fi
	else
		marked_files_status="No files marked"
	fi

	cat <<-EOF | echo -e "$(cat)"
	╭─ STATUS ────────────────────────╮
	 ? for help |
	 Preview:$preview_status | Cycle:$cycle_status | 🔍:$find_status
	 $marked_files_status
	╰─────────────────────────────────╯
	EOF
}

mark() {
    local file="$1"
    # Get the absolute path of the file
    local real_path
    real_path=$(realpath "$file" 2>/dev/null) || {
        echo "$(date): mark: Failure when obtaining realpath to '$file'" >> "$MARK_LOG"
        return 1
    }

    # Loads the current array of the file
    local temp_marked_files=()
    if [[ -s "$MARKED_FILES_FILE" ]]; then
        readarray -t temp_marked_files < "$MARKED_FILES_FILE"
    fi

    # Check if the file is already marked
    local index
    for index in "${!temp_marked_files[@]}"; do
        if [[ "${temp_marked_files[index]}" == "$real_path" ]]; then
            # Removes the file if it is already marked
            unset 'temp_marked_files[index]'
            # Save the updated array or clean the empty file
            if [ ${#temp_marked_files[@]} -eq 0 ]; then
                : > "$MARKED_FILES_FILE"  # Cleans the file
            else
                printf "%s\n" "${temp_marked_files[@]}" > "$MARKED_FILES_FILE"
            fi
            return 0
        fi
    done

    # Add the file to the array if not marked
    temp_marked_files+=("$real_path")
    # Save the updated array
    printf "%s\n" "${temp_marked_files[@]}" > "$MARKED_FILES_FILE"
}

mark_all_only() {
    # Clean previous markings
    generate_mark_file
    
    # Get the list of all visible files/directories
    local file_list=()
    if [[ -f "$CACHE_FZF_DIR/showhidden" ]]; then
        # Includes hidden files
        if command -v ls >/dev/null; then
            mapfile -t file_list < <(ls -A --group-directories-first --color=never 2>/dev/null)
        else
            mapfile -t file_list < <(find . -maxdepth 1 -not -path '.' -printf '%P\n' 2>/dev/null)
        fi
    else
        # Delete Hidden Files
        if command -v ls >/dev/null; then
            mapfile -t file_list < <(ls --group-directories-first --color=never 2>/dev/null)
        else
            mapfile -t file_list < <(find . -maxdepth 1 -not -path '*/\.*' -not -path '.' -printf '%P\n' 2>/dev/null)
        fi
    fi

    # Process each file
    marked_files=()
    for file in "${file_list[@]}"; do
        # Ignores empty lines and the current directory
        [[ -z "$file" ]] && continue
        
        # Get the absolute path
        local abs_path
        abs_path=$(realpath "$file" 2>/dev/null || echo "$PWD/$file")
        
        # Check if it is a valid file/directory
        if [[ -e "$abs_path" && "$abs_path" != "$PWD" ]]; then
            marked_files+=("$abs_path")
        fi
    done

    # Save in the Marking File
    if [[ ${#marked_files[@]} -gt 0 ]]; then
        printf "%s\n" "${marked_files[@]}" > "$MARKED_FILES_FILE"
    else
        : > "$MARKED_FILES_FILE" # Cleans the file if there are no files
    fi

    # Updates the interface
    "${redraw[@]}"
}

mark_all_toggle() {
    # Loads files currently marked
    local current_marked=()
    [[ -f "$MARKED_FILES_FILE" ]] && readarray -t current_marked < "$MARKED_FILES_FILE"

    # Get all files visible in the directory
    local all_files=()
    if [[ -f "$CACHE_FZF_DIR/showhidden" ]]; then
        # Includes hidden files
        if command -v ls >/dev/null; then
            mapfile -t all_files < <(ls -A --group-directories-first --color=never 2>/dev/null)
        else
            mapfile -t all_files < <(find . -maxdepth 1 -not -path '.' -printf '%P\n' 2>/dev/null)
        fi
    else
        # Delete Hidden Files
        if command -v ls >/dev/null; then
            mapfile -t all_files < <(ls --group-directories-first --color=never 2>/dev/null)
        else
            mapfile -t all_files < <(find . -maxdepth 1 -not -path '*/\.*' -not -path '.' -printf '%P\n' 2>/dev/null)
        fi
    fi

    # Processes inversion
    marked_files=()
    for file in "${all_files[@]}"; do
        [[ -z "$file" ]] && continue
        
        local abs_path
        abs_path=$(realpath "$file" 2>/dev/null || echo "$PWD/$file")
        
        # Check if the file is currently marked
        local is_marked=0
        for marked in "${current_marked[@]}"; do
            if [[ "$marked" == "$abs_path" ]]; then
                is_marked=1
                break
            fi
        done

        # Invert the state: if it was marked, unmarked; If it wasn't, brand
        [[ $is_marked -eq 0 ]] && marked_files+=("$abs_path")
    done

    # Update the marking file
    if [[ ${#marked_files[@]} -gt 0 ]]; then
        printf "%s\n" "${marked_files[@]}" > "$MARKED_FILES_FILE"
    else
        : > "$MARKED_FILES_FILE" # Clean if everyone was unmarked
    fi

    # Updates the interface
    "${redraw[@]}"
}

print_pwd() {
    basedir="$1"
    previous_directory=$(printf '%b\n' "\033[${PWD_PREVIOUS_DIRECTORY:-1;38;5;16}m") # Black ansi 256 
    last_dir=$(printf '%b\n' "\033[${PWD_LAST_DIR:-1;33}m")                          # Yellow
    bar=$(printf '%b\n' "\033[${PWD_BAR:-1;96}m")                                    # Cyan
    ncpf=$(printf '\033[0m')

    printf '%b\n' "$basedir" | awk -v pd="$previous_directory" -v bar="$bar" -v ld="$last_dir" -v reset="$ncpf" '
    {
        # Treat root special case
        if ($0 == "/") {
            print bar "/" reset;
            exit;
        }
        
        # Split keeping empty positions to treat absolute paths
        len = split($0, parts, "/");
        output = "";
        
        # Absolute Path (starts with /)
        if ($0 ~ /^\//) {
            output = bar "/" pd;
            start_idx = 2;
        } 
        # Relative Path
        else {
            start_idx = 1;
        }
        
        # Build every part of the Path
        for (i = start_idx; i <= len; i++) {
            if (parts[i] != "") {
                if (i == len) {
                    # Last Directory - Yellow
                    output = output ld parts[i] reset;
                } else {
                    # Intermediate Directories - Black
                    output = output parts[i] bar "/" pd;
                }
            }
        }
        
        print output;
    }'
}

print_filemanager_header() {
    header_top="  $(print_pwd "${1:-$PWD}")"
    echo -e "\033[${ICO_FOLDER:-1;96}m$header_top"
    { [[ "$PWD" == "/" ]] && echo -e "\033[${ICO_FOLDER:-1;96}m${HOME}"; } || echo -e "\033[${ICO_FOLDER:-1;96}m .."
}

# Safe Function to find Directories
safe_find_dirs_limited() {
    if command -v fd >/dev/null; then
        fd \
            --max-results 1000 --type d --absolute-path --max-depth 8 \
            --hidden --exclude "__pycache__" --exclude "*.default*" \
            --exclude ".git" --exclude ".subversion" --exclude ".mednafen" --exclude "*OpenWith*" 2>/dev/null
    else
        find . -maxdepth 2 -type d ! -path '*/\.*' ! -path '*__pycache__*' ! -path '*.subversion*' \
            ! -path '*OpenWith*' ! -path '*mednafen*' 2>/dev/null | sed 's|^\./||'
    fi
}

safe_find_dirs() {
	if command -v fd >/dev/null; then
        fd \
            --hidden --exclude "__pycache__" --exclude "*.default*" \
            --exclude ".git" --exclude ".subversion" --exclude ".mednafen" --exclude "*OpenWith*" 2>/dev/null
    else
        find . ! -path '*/\.*' ! -path '*__pycache__*' ! -path '*.subversion*' \
            ! -path '*OpenWith*' ! -path '*mednafen*' 2>/dev/null | sed 's|^\./||'
    fi
}

# Safe Function to List Directories
safe_ls() {
    if [[ -f "$CACHE_FZF_DIR/find" ]]; then
        print_filemanager_header "$1"
        safe_find_dirs
    else
        # First show the header
        print_filemanager_header "$1"
        
        # Command
        list_opts="--group-directories-first --color=always"

		{ [ -f "$CACHE_FZF_DIR/showhidden" ] && showhidden='-a'; } || showhidden=''

        # Lists the contents
        local file_list
        if command -v ls >/dev/null; then
            file_list=$(ls $showhidden $list_opts "${1:-$PWD}" 2>/dev/null | sed "s/\*$//g; s|/$||")
        else
            file_list=$(find "${1:-$PWD}" -maxdepth 1 -not -path '*/\.*' 2>/dev/null | sed "s|${1:-$PWD}/||")
        fi

        # Loads marked_files from the file
        readarray -t marked_files < "$MARKED_FILES_FILE"

        # Process the list to add [<] to marked files
        while IFS= read -r file; do
            [ -z "$file" ] && continue
            # Remove Clean Comparison Codes
            file_clean=$(echo "$file" | sed 's/\x1B\[[0-9;]*[a-zA-Z]//g')
            # Get the absolute path of the file
            local real_path
            real_path=$(realpath "${1:-$PWD}/$file_clean" 2>/dev/null) || {
                echo "$(date): safe_ls: Failure when obtaining realpath to '${1:-$PWD}/$file_clean'" >> "$MARK_LOG"
                echo "$file"
                continue
            }
            local marked=false
            for marked_file in "${marked_files[@]}"; do
                if [[ "$marked_file" == "$real_path" ]]; then
                    marked=true
                    break
                fi
            done
            if [[ "$marked" == true ]]; then
                echo "$file [<]"
            else
                echo "$file"
            fi
        done <<< "$file_list"
    fi
}

delete_file() {
	local path="$1"
	file="$(clean_path "$path")"
	file="${file% "[<]"}"

	delete_marked() {
		[[ ${#marked_files[@]} -le 0 ]] && messages "Warn" "warn: no files were marked" && return
		# Lists the files marked for confirmation
		local file_list=""
		for file in "${marked_files[@]}"; do
			local basename="${file##*/}"
			file_list+="\n'$basename'"
		done

		cmd_reply=$({ whiptail --yesno --scrolltext "Delete the following files? (y/N):\n\n$file_list" "$message_height" "$message_width" --yes-button "Yes" --no-button "No" >/dev/null 2>&1 >/dev/tty && echo "y"; } || echo "n")
		if [[ "$cmd_reply" =~ ^[Yy]$ ]]; then
			# Check permissions and delete
			local failed=false
			for file in "${marked_files[@]}"; do
				if [[ -w "$file" ]]; then
					if ! rm -rf "$file" 2>/dev/null; then
						failed=true
					fi
				else
					failed=true
					messages "Warn" "warn: no write access to '$file'."
				fi
			done

			if [[ "$failed" == false ]]; then
				generate_mark_file
				"${redraw[@]}"
				messages "Success" "Files deleted successfully!"
			else
				generate_mark_file
				[[ -f "$MARKED_FILES_FILE" ]] && rm -f "$MARKED_FILES_FILE" && touch "$MARKED_FILES_FILE"
				"${redraw[@]}"
				messages "Warn" "warn: some deletions failed."
			fi
		else
			generate_mark_file
			messages "Warn" "Deletion canceled."
		fi
	}

	if [[ "${file}" =~ ^"" ]]; then
		delete_marked
		return
    elif [[ ! -e "${file}" ]]; then
        return
    elif [[ ${#marked_files[@]} -le 0 ]]; then
        # Delete a single selected file
        local filename="${file##*/}"
        cmd_reply=$({ whiptail --yesno "Delete '${filename}'?" "$message_height" "$message_width" --yes-button "Yes" --no-button "No" >/dev/null 2>&1 >/dev/tty && echo "y"; } || echo "n")

        if [[ "$cmd_reply" =~ ^[Yy]$ ]]; then
            if [[ -w "${file}" ]]; then
                if rm -rf "${file}" 2>/dev/null; then
                    "${redraw[@]}"
					messages "Success" "File: \"$filename\" deleted successfully!"
                else
					messages "Warn" "warn: deletion failed."
                fi
            else
				messages "Warn" "warn: no write access to file/directory."
            fi
        else
			messages "Canceled" "Deletion canceled."
        fi
    # Delete marked files
    else
        # Checks writing permission in the current directory
        if [[ ! -w "$PWD" ]]; then
			messages "Warn" "No write permission in the current directory ($PWD)."
        else
			delete_marked
        fi
    fi
}

copy_file() {
    local path="$1"
	file="$(clean_path "$path")"
	file="${file% "[<]"}"

    copy_marked() {
        [[ ${#marked_files[@]} -le 0 ]] &&
        messages "Warn" "warn: no files were marked" && return
        # Check if any files already exist at destination
        local existing_files=""
        for file in "${marked_files[@]}"; do
            local basename="${file##*/}"
            if [[ -e "$PWD/$basename" ]]; then
                existing_files+="\n'$basename'"
            fi
        done

        if [[ -n "$existing_files" ]]; then
            cmd_reply=$({ whiptail --yesno --scrolltext "Already exist in $PWD. Overwrite? (y/N):\n\nSome files:\n\n($existing_files)" "$message_height" "$message_width" --yes-button "Yes" --no-button "No" >/dev/null 2>&1 >/dev/tty && echo "y"; } || echo "n")
            if [[ "$cmd_reply" =~ ^[Yy]$ ]]; then
                # Copy with Sobrescript
                if cp -rf "${marked_files[@]}" "$PWD" >&2; then
                    generate_mark_file
                    "${redraw[@]}"
                    messages "Success" "Copy completed successfully!"
                else
                    generate_mark_file
                    "${redraw[@]}"
                    messages "Warn" "warn: Failed to copy files."
                fi
            else
                messages "Canceled" "Copy operation canceled."
            fi
        else
            # Copy Without Sobrescript Necessary
            if cp -rf "${marked_files[@]}" "$PWD" >&2; then
                generate_mark_file
                "${redraw[@]}"
                messages "Success" "Copy completed successfully!"
            else
                generate_mark_file
                "${redraw[@]}"
                messages "Warn" "warn: Failed to copy files."
            fi
        fi
    }
    
    [[ "${file}" =~ ^"" ]] && 
        copy_marked && return
    [[ ! -w "$PWD" ]] && 
        messages "Warn" "No write permission in the current directory ($PWD)." && 
        return
	[[ ! -e "${file}" ]] && [[ ${#marked_files[@]} -le 0 ]] &&
        messages "Warn" "No file or directory has been selected!" &&
        return
    if [[ ${#marked_files[@]} -le 0 ]]; then
        # Generate suggested name with _copy suffix
        local filename="${file##*/}"
        local basename="${filename%.*}"
        local extension="${filename##*.}"
        
        # Handle files without extension
        if [[ "$basename" == "$extension" ]]; then
            suggested_name="${basename}_copy"
        else
            suggested_name="${basename}_copy.${extension}"
        fi
        
        cmd_reply=$(whiptail --title "New name" --inputbox "copy ${filename} to: " 10 60 "$suggested_name" 3>&1 1>&2 2>&3 >/dev/tty)

        [[ "$cmd_reply" ]] &&
            if [[ -e "${PWD}/${cmd_reply}" ]]; then
                cmd_reply=$({ whiptail --yesno "warn: '${cmd_reply}' already exists. Overwrite? (y/N): " "$message_height" "$message_width" --yes-button "Yes" --no-button "No" >/dev/null 2>&1 >/dev/tty && echo "y"; } || echo "n")
                if [[ "$cmd_reply" =~ ^[Yy]$ ]]; then
                    if cp -rf "${file}" "${PWD}/${cmd_reply}" 2>/dev/null; then
                        "${redraw[@]}"
                        messages "Success" "Copy completed successfully!"
                    else
                        messages "Warn" "warn: Failed to copy the file."
                    fi
                fi
            elif [[ -r "${file}" ]]; then
                if cp -rf "${file}" "${PWD}/${cmd_reply}" 2>/dev/null; then
                    "${redraw[@]}"
                    messages "Success" "Copy completed successfully!"
                else
                    messages "Warn" "warn: Failed to copy the file."
                fi
            else
                messages "Warn" "warn: Cannot read the file/directory."
            fi
    # Copy files marked to the current directory
    else
        # Checks writing permission in the current directory
        if [[ ! -w "$PWD" ]]; then
            return
        else
            copy_marked
        fi
    fi
}

extract_to_folder() {
    local path="$1"
	file="$(clean_path "$path")"
    
    # Check if the file exists
    if [ ! -f "$file" ]; then
        messages "Error" "Error: File '$file' not found"
        return 1
    fi
    
    # Convert to lowercase for better matching
    local file_lower="${file,,}"
    local file_extension="${file%.*}"          # Remove the file extension
    local folder_name="${file_extension%.*}"   # Remove the file extension
    local only_file="${file##*/}" 
    
    # Create the destination directory
    if [[ -d "$folder_name" ]]; then
        messages "Error" "Error: The '${folder_name##*/}' directory exists"
        return 1
    elif ! mkdir -p "$folder_name"; then
        messages "Error" "Error: Could not create directory '$folder_name'"
        return 1
    fi
    
    # Function to check if a command is available
    check_command() {
        if ! command -v "$1" >/dev/null 2>&1; then
        	messages "Error" "Error: '$2' is not installed. Please install it to extract this format."
            return 1
        fi
        return 0
    }

    printf '\e7\e[%sH\e[K%s\e8' "$LINES" "Extracting '$file' to '$folder_name'..."
    
    case "$file_lower" in
        *.tar.bz2|*.tbz2)
            check_command tar tar && tar -xjf "$file" -C "$folder_name" ;;
        *.tar.gz|*.tgz)
            check_command tar tar && tar -xzf "$file" -C "$folder_name" ;;
        *.tar.xz)
            check_command tar tar && tar -xJf "$file" -C "$folder_name" ;;
        *.tar.zst)
            check_command tar tar && tar --zstd -xvf "$file" -C "$folder_name" ;;
        *.tar.lzma)
            check_command tar tar && tar --lzma -xvf "$file" -C "$folder_name" ;;
        *.tar)
            check_command tar tar && tar -xvf "$file" -C "$folder_name" ;;
        *.bz2)
            { check_command bunzip2 bzip2 && bunzip2 -c "$file" > "$folder_name/${only_file%.bz2}"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.gz)
            { check_command gunzip gzip && gunzip -c "$file" > "$folder_name/${only_file%.gz}"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.xz)
            { check_command unxz xz && unxz -c "$file" > "$folder_name/${only_file%.xz}"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.zst)
            { check_command unzstd zstd && unzstd "$file" -o "$folder_name/${only_file%.zst}"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.zip|*.zipx|*.apk|*.xapk|*.apk+)
            { check_command unzip unzip && unzip -q "$file" -d "$folder_name"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.rar)
            { check_command unrar unrar && unrar x -inul "$file" "$folder_name/"; } || 
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.7z|*.7za|*.7zz|*.7zr|*.dmg|*.cbz|*.cbr)
            check_command 7z 7zip && 7z x "$file" -o"$folder_name" ;;
        *.iso)
            check_command 7z 7zip && 7z x "$file" -o"$folder_name" ;;
        *.cab)
            { check_command cabextract cabextract && cabextract "$file" -d "$folder_name"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.arj)
            { check_command unarj unarj && unarj x "$file" "$folder_name/"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.lzh|*.lha)
            { check_command lha lhasa && lha -x "$file" -w "$folder_name"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.rpm)
            { check_command rpm2cpio rpm-tools && rpm2cpio "$file" | cpio -idmv -D "$folder_name"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.deb)
            { check_command dpkg-deb dpkg && dpkg-deb -x "$file" "$folder_name"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.z)
            { check_command uncompress gzip && uncompress -c "$file" > "$folder_name/${only_file%.z}"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.ace)
            { check_command unace unace && unace x "$file" "$folder_name/"; } ||
            { check_command 7z 7zip && 7z x "$file" -o"$folder_name"; } ;;
        *.exe)
            # Might be a self-extracting archive
            check_command 7z 7zip && 7z x "$file" -o"$folder_name" ;;
        *)
            printf '\e[%sH\e[K\e8' "$LINES" # Clear lines
			messages "Warn" "Unsupported format: $file"
            rmdir "$folder_name" 2>/dev/null  # Remove directory if empty
            return 1 ;;
    esac
    
    # Check if extraction was successful
    if [ $? -eq 0 ]; then
        "${redraw[@]}"
		messages "Success" "Extraction completed successfully!"
        return 0
    else
        rmdir "$folder_name"
        "${redraw[@]}"
		messages "Error" "Error: Error during extraction of '$file'"
        return 1
    fi
}

# Function for dealing with selected files
handle_selected_files() {
    local path="$1"
	file=$(clean_path "$path")
	
    case "$(file --mime-type -bL "$file")" in
        */json|*/csv|*/xml|*script*|text/*) 
            "$EDITOR" "$file" ;;
        image/*) 
            feh -Z -x -F -B black "$file" ;;
        audio/*) 
            ffplay -i "$file" -hide_banner -nodisp -autoexit ;;
        video/*) 
            mpv -fs "$file" ;;
        *)
            xdg-open "$file" &>/dev/null &  # Fallback to open with standard app
            ;;
    esac
}

reverse_directory() {
	while IFS= read -r line; do
		if [[ "$line" == */ ]]; then
			echo "2_$line"
		else
			echo "1_$line"
		fi
	done | \
	sort -t'_' -k1,1 -k2,2 | \
	while IFS= read -r line; do
		echo "${line#*_}"
	done  | sed 's|/$||'
}

directory_view() {
    local file="$1"
    { [ ! -f "$CACHE_FZF_DIR/list_files" ] && list_files='-1'; } || list_files=''
    { [ -f "$CACHE_FZF_DIR/longfilemanager" ] && longfilemanager='-l'; } || longfilemanager=''
    { [ -f "$CACHE_FZF_DIR/reverse_directory" ] && reverse_dir="reverse_directory"; } || reverse_dir=
	
	local ls_args=(
		"$list_files" "$longfilemanager" --classify
        --group-directories-first --color=always
	)
    if command -v eza >/dev/null; then
		eza "${ls_args[@]}" --icons \
        "$file" 2>/dev/null | { { [[ -n "${reverse_dir}" ]] && "${reverse_dir}"; } || sed 's|/$||'; }
    elif command -v exa >/dev/null; then
		exa "${ls_args[@]}" --icons \
        "$file" 2>/dev/null | { { [[ -n "${reverse_dir}" ]] && "${reverse_dir}"; } || sed 's|/$||'; }
    else
        ls "${ls_args[@]}" -F \
        "$file" 2>/dev/null | { { [[ -n "${reverse_dir}" ]] && "${reverse_dir}"; } || sed 's|/$||'; }
    fi
}

preview_file() {
    local path="$1"
    file=$(clean_path "$path")
	file=${file% "[<]"}

	if [[ "$file" == " .." ]]; then
		directory_view ".."
		return
	elif [[ "$file" =~ " " ]]; then
		echo -e "\033[${CURRENT_DIR:-1;33}mCurrent Directory:\033[0m ["$(print_pwd "$PWD")"]"
		return
    # Check if the file exists
    elif [ ! -e "$file" ]; then
        echo "File not found: $file"
        return 1
    fi
    
    # Get the Mime Type
    mime_type=$(file --mime-type -b "$file" 2>/dev/null || echo "application/octet-stream")
	sixel_size="${PREVIEW_SIXEL_W:-800}x${PREVIEW_SIXEL_H:-600}!"
    
    case "$mime_type" in
        text/*|*/json|*/csv|*/xml|*script*)
            if command -v bat >/dev/null; then
                bat --color=always --style=plain --paging=never "$file" 2>/dev/null
            elif command -v highlight >/dev/null; then
                highlight -O ansi --force "$file" 2>/dev/null
            else
                head -n 100 "$file" 2>/dev/null
            fi
            ;;
        image/*)
            if command -v magick >/dev/null; then
				magick -quiet -- "${file}" -auto-orient -resize "${sixel_size}" sixel:-
            elif command -v viu >/dev/null; then
                viu -t "$file" 2>/dev/null
            elif command -v chafa >/dev/null; then
                chafa --format=symbols -s 80x40 "$file" 2>/dev/null
            else
                echo "Image: $file"
                file -b "$file"
            fi
            ;;
        application/pdf)
            if command -v pdftotext >/dev/null; then
                pdftotext -l 10 -nopgbrk -q "$file" - 2>/dev/null
            else
                echo "PDF: $file"
                file -b "$file"
            fi
            ;;
        *)
            if [ -d "$file" ]; then
				directory_view "$file"
            else
                file -b "$file" 2>/dev/null
				any_file "$file"
            fi
            ;;
    esac
}

fzf_pid() {
    { fzf "$@" || echo $? > "$TMP_FZF_DIR/signal"; } &
    fzf_pid=$!
	#disown
    wait "$fzf_pid" 
    return 0
}

fzf_binds() {
    local path="$1"
	prompt_text="Search 🔍: "
    path=$(clean_path "$path")
    header_text=$(f_header_text)
    margin_preview=$(cat "$MARGIN_PREVIEW")
	query=$(cat "$TMP_FZF_DIR/query" || echo "")
    { [ -f "$CACHE_FZF_DIR/cycle" ] && cycle="--cycle"; } || cycle="--ansi"
    { [ -f "$CACHE_FZF_DIR/hidepreview" ] && hidepreview=":hidden"; } || hidepreview=''
    { [ ! -f "$CACHE_FZF_DIR/header" ] && header="--header=$header_text"; } || header="--ansi"
    
    # Build fzf's arguments in an array
    local fzf_args=(
        "$cycle"
        --ansi
        --no-bold
        "$header"
		--query="$query"
        --bind shift-tab:up
        --bind 'enter:accept'
        --bind "right:accept"
        --prompt="$prompt_text"
        --bind 'ctrl-space:jump'
        --preview="$preview_cmd"
        --bind 'left:top+up+accept'
        --bind "ctrl-r,f5:top+accept"
        --bind "f1,?:execute(bash \"$SCRIPT_PATH\" --show-help {})"
        --preview-window="right:$margin_preview:noborder$hidepreview"
        --bind "ctrl-q:execute(echo 130 > \"$TMP_FZF_DIR/signal\")+abort"
        --bind "ctrl-y:execute(bash \"$SCRIPT_PATH\" --copy-file {})+top+accept"
        --bind "ctrl-e:execute(bash \"$SCRIPT_PATH\" --delete-file {})+top+accept"
        --bind "ctrl-d:execute(echo \"Selected: {}\" > \"$TMP_FZF_DIR/selected.log\")+accept"
		--bind "alt-x:execute(bash \"$SCRIPT_PATH\" --mark-all-only)+reload(bash \"$SCRIPT_PATH\" --list-files {q})+refresh-preview"
		--bind "ctrl-a:execute(bash \"$SCRIPT_PATH\" --mark-all-toggle)+reload(bash \"$SCRIPT_PATH\" --list-files {q})+refresh-preview"
        --bind "ctrl-f:execute-silent({ [ ! -f \"$CACHE_FZF_DIR/find\" ] && touch \"$CACHE_FZF_DIR/find\"; } || rm -f \"$CACHE_FZF_DIR/find\")+top+accept"
        --bind "alt-c:execute-silent({ [ ! -f \"$CACHE_FZF_DIR/cycle\" ] && touch \"$CACHE_FZF_DIR/cycle\"; } || rm -f \"$CACHE_FZF_DIR/cycle\")+top+accept"
        --bind "alt-z:execute-silent({ [ ! -f \"$CACHE_FZF_DIR/header\" ] && touch \"$CACHE_FZF_DIR/header\"; } || rm -f \"$CACHE_FZF_DIR/header\")+top+accept"
        --bind "alt-h:execute-silent({ [ ! -f \"$CACHE_FZF_DIR/showhidden\" ] && touch \"$CACHE_FZF_DIR/showhidden\"; } || rm -f \"$CACHE_FZF_DIR/showhidden\")+top+accept"
        --bind "alt-l:execute-silent({ [ ! -f \"$CACHE_FZF_DIR/longfilemanager\" ] && touch \"$CACHE_FZF_DIR/longfilemanager\"; } || rm -f \"$CACHE_FZF_DIR/longfilemanager\")+top+accept"
        --bind "ctrl-p:toggle-preview+execute-silent({ [ ! -f \"$CACHE_FZF_DIR/hidepreview\" ] && touch \"$CACHE_FZF_DIR/hidepreview\"; } || rm -f \"$CACHE_FZF_DIR/hidepreview\")+top+accept"
        --bind "ctrl-l:execute-silent(current=\$(cat \"$MARGIN_PREVIEW\"); if [ \$current -gt 20 ]; then new=\$((current - 5)); echo \$new > \"$MARGIN_PREVIEW\"; fi)+reload(bash \"$SCRIPT_PATH\" --list-files {})+top+accept"
        --bind "ctrl-h:execute-silent(current=\$(cat \"$MARGIN_PREVIEW\"); if [ \$current -lt 150 ]; then new=\$((current + 5)); echo \$new > \"$MARGIN_PREVIEW\"; fi)+reload(bash \"$SCRIPT_PATH\" --list-files {})+top+accept"
		--bind "alt-a:execute(bash \"$SCRIPT_PATH\" --mark-file {}; bash \"$SCRIPT_PATH\" --update-header > \"$TMP_FZF_DIR/header\"; echo {q} > \"$TMP_FZF_DIR/query\"; echo {} > \"$TMP_FZF_DIR/selected\"; echo \$(( {n} + 1 )) > \"$TMP_FZF_DIR/fzf_pos\")+reload(bash \"$SCRIPT_PATH\" --list-files {q})+refresh-preview+pos($FZF_POS)"
    )

    select="$(safe_ls "$path" | \
    fzf_pid "${fzf_args[@]}" \
        --expect=enter,right 2>&1)"

    selected=$(clean_path "$select")

    if [ -f "$TMP_FZF_DIR/signal" ]; then
        fzf_error=$(cat "$TMP_FZF_DIR/signal")
        rm -f "$TMP_FZF_DIR/signal"  # Clean to avoid false positives
        [ "$fzf_error" -eq 130 ] && return 1  # Returns error only if it is ctrl+c
    fi

    return 0
}

main() {
	setup_config
    # Starts in the initial directory
    builtin cd "$initial_dir" || exit 1
    
    while true; do 
        # Loads marked_files from the file
        readarray -t marked_files < <(cat "$MARKED_FILES_FILE" 2>/dev/null || true)
                
        # Selection logic with new binds
        fzf_binds "$PWD" || { cleanup && exit 130; }
        
        # Determines the action based on the pressed key
        key="$(head -1 <<< "$selected")"
        selected="$(tail -n +2 <<< "$selected")"
        selected=$(clean_path "$selected")
		selected=${selected% "[<]"}
        
        # Selection processing
        if [ -d "$selected" ]; then
            builtin cd "$selected" || continue
        elif [[ "$selected" == " .." ]]; then
            builtin cd .. || true
        else
            file_path=$(realpath "$PWD/$selected" 2>/dev/null || echo "$PWD/$selected")
            # If it was pressed right or enter
            if [[ "$key" == "right" || "$key" == "enter" ]]; then
                handle_selected_files "$file_path"
            fi
        fi
    done
}

case "$1" in
    --version)
        echo "$SCRIPT $VERSION"
        ;;
    --help)
        help
        ;;
    --show-help)
        dialog_help
        ;;
	--update-header)
        f_header_text
        ;;
	--mark-all-only)
    	mark_all_only
		;;
	--mark-all-toggle)
    	mark_all_toggle
    	;;
    --preview-file)
        shift
        preview_file "$1"
        ;;
    --list-files)
		shift
        safe_ls "$PWD"
        ;;
	--delete-file)
		shift
        delete_file "$1"
		;;
	--copy-file)
		shift
        copy_file "$1"
		;;
    --mark-file)
        shift
        # Removes the suffix [<] if present
        file_clean=${1% "[<]"}
        mark "$file_clean"
        ;;
    *)
        main "$@"
        ;;
esac