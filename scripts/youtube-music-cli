#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes

: <<'DOCUMENTATION'
Base: https://github.com/sayan01/scripts/blob/master/yt
Modified for YouTube Music with autoplay and more results

dependencies: mpv yt-dlp fzf rofi/dmenu grep (GNU grep)
NOTE:  if you dont have GNU grep you can replace grep with rg
DOCUMENTATION

clear

# Check dependencies
for cmd in mpv yt-dlp fzf; do
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: $cmd is not installed"
        exit 1
    fi
done

# ====================== IMPROVED SIGNAL HANDLING ======================
# Define cleanup function
cleanup() {
    echo ""
    echo "Encerrando script e processos relacionados..."
    
    # Kill mpv processes
    pkill -INT mpv 2>/dev/null
    sleep 0.1
    pkill -TERM mpv 2>/dev/null
    sleep 0.1
    pkill -KILL mpv 2>/dev/null
    
    # Kill background jobs
    kill $(jobs -p) 2>/dev/null
    
    # Clean up temporary files
    rm -f /tmp/yt_music_volume_*.lua
    
    exit 0
}

# Set up trap for common termination signals
trap cleanup SIGINT SIGTERM SIGQUIT

# explain usage
function usage () {
    echo "usage: ${0##*/}"
    echo "    -h, --help            help"
    echo "    -c                    channels/subscriptions"
    echo "    -s query              search"
    echo "    -g, -r                gui mode (rofi/dmenu)"
    echo "    -v, --video           enable video (default: audio only)"
    echo "    -f, --filter N        filter number of results (default: 100)"
    echo "  nothing                 use defaults (search from prompt)"
	echo
	echo "add channel names to the file $sublistpath to show them"
	echo "in ${0##*/} -c option. First word should be channel url, optionally"
	echo "followed by tab and then anything else (channel name/description)"
	echo -e "channels not in sublist can be viewed by typing their url in the prompt\n"
  exit 0
}

# dont use defaults
useDefaults="f"

# no args -> use defaults
if [[ ${#} -eq 0 ]]; then
    useDefaults="t"
fi

# available flags - added v for video, support for --video will be handled separately
optstring=":s:cgrhf:"

defcmd="fzf"
defaction="s"
guicmd="rofi -dmenu -i" #uncomment next line for dmenu
#guicmd="dmenu -i -l 15"

#Defaults
promptcmd="$defcmd"
action="$defaction"
isGui="f"
showVideo="f"
query=""
filter_results=100

# ========================= VOLUME CACHE SYSTEM =========================
# Setup cache directory for volume persistence between sessions
SCRIPT="${0##*/}"
CACHE_DIR="${XDG_CACHE_HOME:=${HOME}/.cache}/${SCRIPT%.*}"
mkdir -p "$CACHE_DIR"
VOLUME_CACHE_FILE="$CACHE_DIR/volume_cache"

# Initialize volume cache with 100 (default volume) if it doesn't exist
if [ ! -f "$VOLUME_CACHE_FILE" ]; then
    echo "100" > "$VOLUME_CACHE_FILE"
fi

# Function to get cached volume with validation
get_cached_volume() {
    local vol
    vol=$(cat "$VOLUME_CACHE_FILE" 2>/dev/null)
    # Validate volume is a number between 0 and 200 (MPV typical range)
    if [[ $vol =~ ^[0-9]+$ ]] && [ "$vol" -ge 0 ] && [ "$vol" -le 200 ]; then
        echo "$vol"
    else
        # Reset to default if invalid
        echo "100" > "$VOLUME_CACHE_FILE"
        echo "100"
    fi
}

# Audio only options by default - maintains terminal control
# We'll modify this if -v or --video flag is used
ytdlformats="bestaudio"

# ========================= ARGUMENT PARSING =========================
# First check for --video, --filter and --help long options
for arg in "$@"; do
    case "$arg" in
        --video)
            showVideo="t"
            ;;
        --help)
            usage
            ;;
        --filter)
            # Handle --filter in the getopts loop
            ;;
        *)
            # Check if argument is a number (for --filter value)
            if [[ $arg =~ ^[0-9]+$ ]] && [[ "$1" == "--filter" ]]; then
                filter_results="$arg"
                shift
            fi
            ;;
    esac
done

# Now parse standard options with getopts
if [[ $useDefaults = "f" ]]; then
    while getopts ${optstring} arg; do
        case "${arg}" in
            s)
                # search in youtube for a query
                action="s"
                query="${OPTARG}" ;;
            c)
                # search in subscriptions for specific channel
                action="c"
                query="${OPTARG}" ;;
            g|r)
                # set gui mode to true and change the prompt to gui prompt
                isGui="t"
                promptcmd="$guicmd" ;;
            v)
                # enable video
                showVideo="t" ;;
            f)
                # filter number of results
                if [[ ${OPTARG} =~ ^[0-9]+$ ]] && [ "${OPTARG}" -gt 0 ]; then
                    filter_results="${OPTARG}"
                else
                    echo "Error: -f requires a positive numeric argument"
                    echo
                    usage
                fi ;;
            h)
                # display help / usage
                usage ;;
            \?)
                # wrong args -> exit with explanation of usage
                echo "invalid option: -${OPTARG}"
                echo
                usage ;;
            :)
                # missing args -> exit with explanation of usage
                echo "Option -${OPTARG} needs an argument"
                echo
                usage ;;
        esac
    done
fi

# Set MPV options based on video flag
if [[ $showVideo = "t" ]]; then
    # With video - show window and download best quality (video+audio)
    mpv_options="--force-window=yes --input-conf=/dev/null"
    ytdlformats="best"
    echo "Video mode enabled"
else
    # Audio only (default) - no video, no window, download best audio only
    mpv_options="--force-window=no --no-video --input-conf=/dev/null"
    echo "Audio-only mode (use -v or --video for video)"
fi

echo "Filtering up to $filter_results results"

# subscription list
mkdir -p "${HOME:-}/.config/yt"
sublistpath="${HOME:-}/.config/yt/sublist"
sublist=""
[ -f "$sublistpath" ] && sublist=$(cat "$sublistpath")

# if no query is set with flags then ask for one
if [ -z "$query" ]; then
    # ask for a channel
    if [[ $action = "c" ]]; then
        # if in gui mode use gui prompt
        if [[ $isGui = "t" ]]; then
			query=$($promptcmd -p "Channel: " <<< "$sublist")
            promptcmd="$promptcmd -p Music:"
        else
            query=$($promptcmd --print-query <<< "$sublist" | tail -n1)
        fi
		query=$(echo "$query" | awk '{print $1}')
    else
        # ask for a query
        # if in gui mode use gui prompt
        if [[ $isGui = "t" ]]; then
            query=$(echo | $promptcmd -p "Search Music: ")
            promptcmd="$promptcmd -p Music:"
        else
            echo -n "Search Music: "
            read -r query
        fi
    fi
fi

# program cancelled -> exit
if [ -z "$query" ]; then cleanup; fi

# clean query / channel - escape special characters for URL
query=$(sed \
  -e 's|+|%2B|g'\
  -e 's|#|%23|g'\
  -e 's|&|%26|g'\
  -e 's| |+|g' <<< "$query")

# ========================= SEARCH FUNCTIONS =========================

# Function to get more search results using yt-dlp
get_enhanced_search_results() {
    local query="$1"
    local max_results="$2"
    
    # Try to get more results with yt-dlp
    echo "Fetching up to $max_results results..." >&2
    
    # Use yt-dlp to search - get specified number of results
    yt-dlp --flat-playlist --get-title --get-id --playlist-end "$max_results" "ytsearch${max_results}:$query" 2>/dev/null | \
    awk 'NR%2==1 {title=$0} NR%2==0 {print $0 "\t" title}'
}

# Function to get channel videos using yt-dlp
get_channel_videos() {
    local channel="$1"
    local max_results="$2"
    
    # Use yt-dlp to get channel videos
    yt-dlp --flat-playlist --get-title --get-id --playlist-end "$max_results" "https://www.youtube.com/c/$channel/videos" 2>/dev/null | \
    awk 'NR%2==1 {title=$0} NR%2==0 {print $0 "\t" title}'
}

# ========================= VOLUME TRACKING LUA SCRIPT =========================

# Function to play music with volume cache support
play_music() {
    local url="$1"
    local title="$2"
    
    echo "========================================"
    echo "Playing: $title"
    echo "URL: $url"
    echo "Current volume: $(get_cached_volume)"
    echo "========================================"
    echo "MPV Controls:"
    echo "  Space    - Play/Pause"
    echo "  →        - Seek forward 5s"
    echo "  ←        - Seek backward 5s"
    echo "  ↑        - Seek forward 1min"
    echo "  ↓        - Seek backward 1min"
    echo "  >        - Next track (in playlist)"
    echo "  <        - Previous track (in playlist)"
    echo "  q        - Quit and stop ALL playback (Ctrl+C to exit script)"
    echo "  Q        - Quit and continue to next song"
    echo "  f        - Toggle fullscreen"
    echo "  L        - Toggle loop/repeat"
    echo "  m        - Mute"
    echo "  9/0      - Volume down/up"
    echo "========================================"
    echo "Press q on the MPV to stop the current song, or"
    echo "Ctrl+C to completely exit the script."
    echo ""
    
    # Get current cached volume
    local current_volume
    current_volume=$(get_cached_volume)
    
    # Create Lua script for volume tracking with DEBOUNCING optimization
    # Debouncing prevents too many disk writes by waiting a bit between writes
    local VOLUME_LUA="/tmp/yt_music_volume_$$.lua"
    cat > "$VOLUME_LUA" << 'LUA'
mp = require 'mp'

local cache_file = os.getenv('VOLUME_CACHE_FILE')
if not cache_file then return end

local last_saved_volume = nil
local last_save_time = 0
local SAVE_DELAY = 0.5 -- 500ms debounce delay

-- Function to save volume with debouncing
local function save_volume_with_debounce(volume)
    local current_time = mp.get_time()
    
    -- Only save if volume changed AND enough time has passed since last save
    if volume ~= last_saved_volume and (current_time - last_save_time) >= SAVE_DELAY then
        local f = io.open(cache_file, 'w')
        if f then
            f:write(tostring(math.floor(volume + 0.5))) -- Round to nearest integer
            f:close()
            last_saved_volume = volume
            last_save_time = current_time
        end
    end
end

-- Function to handle volume changes
local function on_volume_change(name, value)
    if value ~= nil then
        save_volume_with_debounce(value)
    end
end

-- Function to save volume on shutdown (ensure final volume is saved)
local function save_final_volume()
    local volume = mp.get_property_number("volume", 100)
    local f = io.open(cache_file, 'w')
    if f then
        f:write(tostring(math.floor(volume + 0.5)))
        f:close()
    end
end

-- Observe volume changes
mp.observe_property('volume', 'number', on_volume_change)

-- Register shutdown handler
mp.register_event('shutdown', save_final_volume)

-- Save initial volume
local initial_volume = mp.get_property_number("volume", 100)
save_volume_with_debounce(initial_volume)
LUA

    # Export cache file path for Lua script
    export VOLUME_CACHE_FILE="$VOLUME_CACHE_FILE"

    # Play with MPV using cached volume and Lua tracking script
    mpv $mpv_options \
        --no-resume-playback \
        --no-save-position-on-quit \
        --term-playing-msg="Initial Volume: ${current_volume}" \
        --volume="$current_volume" \
        --ytdl-format="$ytdlformats" \
        --script="$VOLUME_LUA" \
        "$url" &
    
    local mpv_pid=$!
    
    # Wait for MPV to finish or for Ctrl+C
    wait $mpv_pid 2>/dev/null
    local mpv_exit_code=$?
    
    # Clean up Lua script
    rm -f "$VOLUME_LUA"
    
    # Check if MPV was terminated by signal (like Ctrl+C)
    if [ $mpv_exit_code -eq 130 ] || [ $mpv_exit_code -eq 143 ]; then
        echo "MPV interrupted. Exiting script..."
        cleanup
    fi
    
    echo "Track finished, continuing to next..."
    return 0
}

# ========================= CHANNEL MODE =========================

if [[ $action = "c" ]]; then
    echo "Fetching channel videos (this may take a moment)..."
    
    # Try to get more results with yt-dlp first
    ids=$(get_channel_videos "$query" "$filter_results")
    
    # If yt-dlp fails, fall back to original method
    if [ -z "$ids" ]; then
        echo "Using fallback method..."
        response=$(curl -s "https://www.youtube.com/c/$query/videos" |\
          sed "s/{\"videoRenderer/\n\n&/g" |\
          sed "s/}]}}}]}}/&\n\n/g" |\
          awk -v ORS="\n\n" '/videoRenderer/')

        if ! grep -q "videoRenderer" <<< "$response"; then 
            echo "unable to fetch yt"; exit 1; 
        fi

        ids=$(awk -F '[""]' '{print $6 "\t" $50;}' <<< "$response" | grep "^\S")
    fi

    # url prefix for videos
    videolink="https://youtu.be/"

    # prompt the results to user to select starting point
    choice=$(echo -e "$ids" | cut -d'	' -f2- | $promptcmd)
    if [ -z "$choice" ]; then cleanup; fi
    
    # get starting index using exact matching
    start_index=$(echo -e "$ids" | cut -d'	' -f2- | grep -n -x -F -- "$choice" | cut -d: -f1)
    
    # get all ids and titles from starting point onwards
    total_lines=$(echo -e "$ids" | wc -l)
    
    echo "Found $total_lines tracks total"
    echo "Playing $((total_lines - start_index + 1)) tracks starting from: $choice"
    echo ""
    
    # play from selected song onwards
    for ((i=start_index; i<=total_lines; i++)); do
        current_line=$(echo -e "$ids" | sed -n "${i}p")
        id=$(echo "$current_line" | cut -d'	' -f1)
        title=$(echo "$current_line" | cut -d'	' -f2-)
        
        # Play with control
        play_music "$videolink$id" "$title"
        
        # Small pause between tracks
        sleep 0.5
        
        # Show progress
        echo ""
        echo "Progress: $((i - start_index + 1)) of $((total_lines - start_index + 1)) tracks played"
        echo ""
    done
    
    echo "Playlist finished!"
    
# ========================= SEARCH MODE =========================

else
    echo "Searching for: $(echo "$query" | sed 's/+/ /g')"
    
    # Try to get more results with yt-dlp first
    enhanced_ids=$(get_enhanced_search_results "$query" "$filter_results")
    
    # If we got enhanced results, use them
    if [ -n "$enhanced_ids" ]; then
        ids="$enhanced_ids"
        echo "Found enhanced results"
    else
        # Fall back to original method
        echo "Using original search method..."
        response="$(curl -s "https://www.youtube.com/results?search_query=$query" |\
          sed 's|\\.||g')"
        
        if ! grep -q "script" <<< "$response"; then 
            echo "unable to fetch yt"; exit 1; 
        fi
        
        vgrep='"videoRenderer":{"videoId":"\K.{11}".+?"text":".+?[^\\](?=")'
        pgrep='"playlistRenderer":{"playlistId":"\K.{34}?","title":{"simpleText":".+?[^\"](?=")'
        
        getresults() {
            grep -oP "$1" <<< "$response" |\
              awk -F\" -v p="$2" '{ print $1 "\t" p " " $NF}'
        }
        
        videoids=$(getresults "$vgrep")
        playlistids=$(getresults "$pgrep" "(playlist)")
        
        [ -n "$playlistids" ] && ids="$playlistids\n"
        [ -n "$videoids" ] && ids="$ids$videoids"
    fi
    
    # url prefix for videos and playlists
    videolink="https://youtu.be/"
    playlink="https://youtube.com/playlist?list="
    
    # Count total results
    result_count=$(echo -e "$ids" | wc -l)
    echo "Found $result_count results"
    
    # prompt the results to user to select starting point
    choice=$(echo -e "$ids" | cut -d'	' -f2- | $promptcmd)
    if [ -z "$choice" ]; then cleanup; fi
    
    # get starting index using exact matching
    start_index=$(echo -e "$ids" | cut -d'	' -f2- | grep -n -x -F -- "$choice" | cut -d: -f1)
    
    # get all ids and titles from starting point onwards
    total_lines=$(echo -e "$ids" | wc -l)
    
    echo "Playing $((total_lines - start_index + 1)) tracks starting from: $choice"
    echo ""
    
    # play from selected song onwards
    for ((i=start_index; i<=total_lines; i++)); do
        current_line=$(echo -e "$ids" | sed -n "${i}p")
        id=$(echo "$current_line" | cut -d'	' -f1)
        title=$(echo "$current_line" | cut -d'	' -f2-)
        
        # Check if it's a video or playlist
        case $id in
            # 11 digit id = video
            ???????????) 
                url="$videolink$id"
                ;;
            # 34 digit id = playlist
            ??????????????????????????????????) 
                url="$playlink$id"
                echo "NOTE: Playing playlist - use MPV controls to navigate within playlist"
                ;;
            *) 
                echo "Skipping invalid ID: $id"
                continue
                ;;
        esac
        
        # Play with control
        play_music "$url" "$title"
        
        # Small pause between tracks
        sleep 0.5
        
        # Show progress
        echo ""
        echo "Progress: $((i - start_index + 1)) of $((total_lines - start_index + 1)) tracks played"
        echo ""
    done
    
    echo "Playlist finished!"
fi

# Final cleanup
cleanup