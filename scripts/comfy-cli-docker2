#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes
# Source: https://github.com/comfyanonymous/ComfyUI

container="comfy"
docker_root="${HOME}/.dockers"
docker_base="${docker_root}/${container}"
docker_file="${docker_base}/Dockerfile"

# Function to display help menu
show_help() {
    cat << EOF

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
   COMFYUI DOCKER INSTALLER
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DESCRIPTION:
    Instala e executa ComfyUI em container Docker

USAGE:
    ${0##*/} [install|run|stop|status|help]

COMMANDS:
    install   - Cria a imagem Docker
    run       - Inicia o container em background e entra nele
    stop      - Para o container
    status    - Mostra status do container
    shell     - Entra no container se jÃ¡ estiver rodando
    help      - Mostra esta ajuda

EXAMPLES:
    ${0##*/} install   # Cria o container
    ${0##*/} run       # Inicia o container
    ${0##*/} status    # Verifica status

EOF
    exit 0
}

create_comfy_script() {
    # Cria o script comfy-cli
    cat > "$docker_base/comfy-cli.sh" << 'EOF'
#!/usr/bin/env bash
# License: GPLv3
# Credits: Felipe Facundes
# Source: https://github.com/comfyanonymous/ComfyUI

py_base="comfy-cli"
py_root="${HOME}/.python"
py_venv="${py_root}/${py_base}"
activate="${py_venv}/bin/activate"

# Configura pyenv se disponÃ­vel
setup_pyenv() {
    if [[ -f "$HOME/.pyenv/bin/pyenv" ]]; then
        export PYENV_ROOT="$HOME/.pyenv"
        export PATH="$PYENV_ROOT/bin:$PATH"
        eval "$(pyenv init --path)"
        eval "$(pyenv init -)"
        
        # Verifica se Python 3.13 estÃ¡ instalado
        if pyenv versions | grep -q "3.13"; then
            echo "ğŸ Python 3.13 available via pyenv"
            PYTHON_CMD="python"
            return 0
        else
            echo "âš ï¸ Python 3.13 not installed in pyenv, installing..."
            pyenv install 3.13.1 -s
            pyenv global 3.13.1
            PYTHON_CMD="python"
            return 0
        fi
    fi
    
    return 1
}

# Tenta usar pyenv primeiro
if setup_pyenv; then
    echo "âœ… Using pyenv Python"
else
    # Fallback para system python
    echo "âš ï¸ pyenv not found, using system Python"
    if command -v python3 >/dev/null 2>&1; then
        PYTHON_CMD="python3"
    else
        PYTHON_CMD="python"
    fi
fi

nvidia_universal() {
    echo "âš ï¸ Using CUDA 12.6 as fallback"
    python -m pip install torch==2.9.0 torchvision==0.24.0 torchaudio==2.9.0 --index-url https://download.pytorch.org/whl/cu126
    return 0
}

gpu_detect() {
    if lspci | grep -E "VGA|3D" | grep -i "NVIDIA" >/dev/null 2>&1; then
        echo "ğŸ” NVIDIA GPU detected"        
        nvidia_universal && return
        
    elif lspci | grep -E "VGA|3D" | grep -Ei "AMD|ATI" >/dev/null 2>&1; then
        echo "ğŸ” AMD GPU detected"
        python -m pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/rocm6.4
        
    elif lspci | grep -E "VGA|3D" | grep -i "Intel" >/dev/null 2>&1; then
        echo "ğŸ” Intel GPU detected"
        python -m pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/xpu
        
    else
        echo "âš ï¸ No GPU detected - installing for CPU"
        python -m pip install torch torchvision torchaudio
    fi
}

if [[ ! -d "$py_venv" ]]; then
    echo "ğŸ”§ Creating Python virtual environment..."
    
    # Usa o Python disponÃ­vel (do pyenv ou system)
    $PYTHON_CMD -m venv "$py_venv"
    
    if [[ ! -d "$py_venv" ]]; then
        echo "âŒ Failed to create venv, trying alternative method..."
        mkdir -p "$py_venv"
        
        # Tenta usar virtualenv como fallback
        if $PYTHON_CMD -m pip install virtualenv --quiet; then
            $PYTHON_CMD -m virtualenv "$py_venv"
        fi
    fi
    
    if [[ ! -f "$activate" ]]; then
        echo "âŒ Failed to create virtual environment"
        exit 1
    fi
    
    cd "$py_venv" || true
    wget -q https://raw.githubusercontent.com/comfyanonymous/ComfyUI/refs/heads/master/requirements.txt
    
    #shellcheck source=/dev/null
    source "$activate"
    
    export VIRTUAL_ENV="$py_venv"
    
    # Atualiza pip primeiro
    python -m pip install --upgrade pip setuptools wheel
    
    gpu_detect
    
    pip install -r requirements.txt
    
    # Instala versÃ£o compatÃ­vel do comfy-cli
    pip install comfy-cli
    
    echo "âœ… Environment configured with Python $(python --version | cut -d' ' -f2)"
    echo "ğŸ“¦ Running: comfy-cli install"
    comfy-cli install
fi

if [[ -z "$VIRTUAL_ENV" ]] && [[ -f "$activate" ]]; then
    export VIRTUAL_ENV="$py_venv"
    #shellcheck source=/dev/null
    source "$activate"
fi

if ! command -v comfy-cli >/dev/null; then
    pip install comfy-cli
fi

if [[ -n "$VIRTUAL_ENV" ]] && [[ "$nv_universal" != "1" ]] && \
    command -v comfy-cli >/dev/null 2>&1; then
    exec comfy-cli "$@"
elif [[ "$nv_universal" != "1" ]]; then
    echo "âŒ Error: Environment not properly configured. Check installation."
    echo "Tip: Execute 'source $activate' manually and try again."
    exit 1
fi
EOF
}

create_docker_context() {
    echo "ğŸ“ Creating Docker build context..."
    [[ -f "$docker_file" ]] && return
    
    # Cria o script primeiro
    create_comfy_script
    
    # Create Dockerfile corrigido
    cat > "$docker_file" << 'EOF'
FROM archlinux:latest

# Atualiza o sistema e instala pacotes essenciais
RUN pacman -Syu --noconfirm && \
    pacman -S --noconfirm sudo wget base libsm libxext libxrender mesa clinfo \
    pkgconf libxrandr libxinerama libxi libxcursor libglvnd pciutils ocl-icd \
    base-devel python python-pip python-pipx git zsh pciutils pyenv && \
    pacman -Scc --noconfirm

# Cria usuÃ¡rio comfy
RUN useradd -m -G wheel -s /bin/bash comfy && \
    echo "comfy:123" | chpasswd && \
    echo "comfy ALL=(ALL:ALL) NOPASSWD:ALL" >> /etc/sudoers.d/comfy && \
    chmod 0440 /etc/sudoers.d/comfy

# ConfiguraÃ§Ãµes do usuÃ¡rio comfy
USER comfy
WORKDIR /home/comfy

# Configura environment para pyenv
ENV PYENV_ROOT="/home/comfy/.pyenv"
ENV PATH="$PYENV_ROOT/bin:$PATH"

# Instala Python 3.13 via pyenv
RUN export PYENV_ROOT="$HOME/.pyenv" && eval "$(pyenv init - bash)" && \
    pyenv install 3.13.1 -v && \
    pyenv global 3.13.1 && \
    pip install --upgrade pip setuptools wheel

# Cria e configura o diretÃ³rio .local/bin
RUN mkdir -p /home/comfy/.local/bin && \
    chown -R comfy:comfy /home/comfy/.local

# Configura o PATH para incluir ~/.local/bin
ENV PATH="/home/comfy/.local/bin:${PATH}"
RUN echo 'export PATH="/home/comfy/.local/bin:$PATH"' >> /home/comfy/.zshrc && \
    echo 'export PATH="/home/comfy/.local/bin:$PATH"' >> /home/comfy/.bashrc

# Instala Python 3.13 via pyenv
RUN export PYENV_ROOT="$HOME/.pyenv" && \
    export PATH="$PYENV_ROOT/bin:$PATH" && \
    eval "$(pyenv init -)" && \
    pyenv install 3.13.1 && \
    pyenv global 3.13.1 && \
    pip install --upgrade pip
    
# Instala o pipx e configura
RUN pipx ensurepath

# Copia o script comfy-cli para ~/.local/bin e torna executÃ¡vel
COPY --chown=comfy:comfy comfy-cli.sh /home/comfy/.local/bin/comfy-cli
RUN chmod +x /home/comfy/.local/bin/comfy-cli

# CORREÃ‡ÃƒO IMPORTANTE: MantÃ©m o container rodando com processo infinito
CMD ["tail", "-f", "/dev/null"]
EOF
}

install_container() {
    if [[ ! -d "$docker_base" ]]; then
        mkdir -p "$docker_base"
        create_docker_context
        echo "ğŸ”¨ Building Docker image..."
        
        if docker build -t "$container" -f "$docker_file" "$docker_base"; then
            echo "âœ… Container image created successfully!"
            echo "ğŸ”‘ Login: comfy | Password: 123"
            echo "ğŸ“¦ Comfy-cli installed at: /home/comfy/.local/bin/comfy-cli"
            echo "ğŸ’¡ Run: ${0##*/} run  # to start the container"
        else
            echo "âŒ Failed to create container"
            exit 1
        fi
    else
        echo "â„¹ï¸  Container image already exists at: $docker_base"
        echo "ğŸ’¡ To rebuild, remove directory first: rm -rf $docker_base"
    fi
}

run_container() {
    if docker images | grep -q "^$container "; then
        echo "ğŸš€ Starting container..."
        
        # Verifica se container jÃ¡ existe e estÃ¡ rodando
        if docker ps --format '{{.Names}}' | grep -q "^${container}$"; then
            echo "âœ… Container '$container' is already running!"
            echo "ğŸ’¡ Use '${0##*/} shell' to enter or '${0##*/} stop' to stop it"
            read -p "Enter container now? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                docker exec -it "$container" bash
            fi
            return
        fi
        
        # Se existe mas estÃ¡ parado, remove para recriar
        if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
            echo "ğŸ”„ Removing stopped container..."
            docker rm "$container" 2>/dev/null
        fi
        
        # Monta variÃ¡veis para configuraÃ§Ãµes
        local gpu_args=""
        local display_args=""
        
        # Verifica NVIDIA
        if command -v nvidia-smi >/dev/null 2>&1; then
            echo "ğŸ® NVIDIA GPU detected, enabling GPU support..."
            gpu_args="--gpus all"
        # Verifica AMD/Intel
        elif [[ -d "/dev/dri" ]]; then
            echo "ğŸ® GPU device detected (/dev/dri), enabling GPU support..."
            gpu_args="--device /dev/dri"
        fi
        
        # Verifica X11
        if [[ -n "$DISPLAY" ]] && [[ -S "/tmp/.X11-unix/X${DISPLAY#*:}" ]]; then
            display_args="-v /tmp/.X11-unix:/tmp/.X11-unix:rw -e DISPLAY=$DISPLAY"
            echo "ğŸ¨ X11 display enabled: $DISPLAY"
        fi
        
        # CRÃTICO: Roda em background com -d (detached)
        echo "ğŸ³ Creating container in background mode..."
        if docker run -d \
            --name "$container" \
            --hostname "$container" \
            --restart unless-stopped \
            $gpu_args \
            $display_args \
            -p 8188:8188 \
            "$container" >/dev/null 2>&1; then
            
            sleep 2  # Aguarda container iniciar
            
            # Verifica se realmente estÃ¡ rodando
            if docker ps --format '{{.Names}}' | grep -q "^${container}$"; then
                echo "âœ… Container '$container' started successfully in background!"
                echo ""
                echo "ğŸ“Š Container status:"
                docker ps --filter "name=$container" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
                echo ""
                echo "ğŸ”§ Available commands:"
                echo "   ${0##*/} shell    - Enter container"
                echo "   ${0##*/} stop     - Stop container"
                echo "   ${0##*/} status   - Check status"
                echo "   docker logs $container  - View logs"
                echo ""
                
                read -p "Enter container now? [Y/n] " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                    docker exec -it "$container" bash
                fi
            else
                echo "âŒ Container failed to start in background"
                echo "Checking logs..."
                docker logs "$container" 2>&1 | tail -20
                exit 1
            fi
        else
            echo "âŒ Failed to start container"
            exit 1
        fi
    else
        echo "âŒ Container image '$container' not found"
        echo "ğŸ’¡ Run first: ${0##*/} install"
        exit 1
    fi
}

stop_container() {
    if docker ps --format '{{.Names}}' | grep -q "^${container}$"; then
        echo "ğŸ›‘ Stopping container '$container'..."
        docker stop "$container"
        echo "âœ… Container stopped"
    elif docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
        echo "â„¹ï¸  Container '$container' is already stopped"
    else
        echo "âŒ Container '$container' not found"
    fi
}

status_container() {
    echo "ğŸ“Š Docker containers status:"
    echo ""
    
    # Mostra container especÃ­fico se existir
    if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
        echo "Container '$container':"
        docker ps -a --filter "name=$container" --format "table {{.Names}}\t{{.Status}}\t{{.Image}}\t{{.Ports}}"
        echo ""
        
        # Se estiver rodando, mostra mais informaÃ§Ãµes
        if docker ps --format '{{.Names}}' | grep -q "^${container}$"; then
            echo "ğŸ“ˆ Resource usage:"
            docker stats "$container" --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"
            echo ""
            echo "ğŸ“ Last logs (tail):"
            docker logs "$container" --tail 10 2>/dev/null || echo "No logs available"
        fi
    else
        echo "âŒ Container '$container' not found"
        echo ""
        echo "All containers:"
        docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}\t{{.Ports}}"
    fi
}

shell_container() {
    if docker ps --format '{{.Names}}' | grep -q "^${container}$"; then
        echo "ğŸšª Entering container '$container'..."
        docker exec -it "$container" bash
    elif docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
        echo "âŒ Container '$container' exists but is not running"
        read -p "Start it now? [Y/n] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Nn]$ ]]; then
            docker start "$container"
            sleep 2
            docker exec -it "$container" bash
        fi
    else
        echo "âŒ Container '$container' not found"
        echo "ğŸ’¡ Run first: ${0##*/} install"
        exit 1
    fi
}

# Processa argumentos
case "${1:-}" in
    "install"|"i")
        install_container
        ;;
    "run"|"r")
        run_container
        ;;
    "stop")
        stop_container
        ;;
    "status")
        status_container
        ;;
    "shell"|"sh")
        shell_container
        ;;
    "help"|"h"|""|"--help")
        show_help
        ;;
    *)
        echo "âŒ Invalid option: $1"
        echo "ğŸ’¡ Use: ${0##*/} help"
        exit 1
        ;;
esac